# 251104

## 1. 상태관리: zustand (persist 미들웨어)

### 장점

- **가볍고 단순**: create() 한 줄로 바로 상태와 액션 선언 가능하며 보일러플레이트가 거의 없다.
- **필요한 부분만 구독 가능**: `useStore((s) => s.slice)`처럼 필요한 slice만 선택적으로 구독하여 불필요한 리렌더가 줄어든다.
- **간단한 영속화**: persist 미들웨어로 로컬스토리지나 세션스토리지에 상태를 쉽게 저장 가능하다. (부분 저장도 가능)

### 단점 / 주의점

- **너무 자유로워서 구조가 흐트러지기 쉬움**: API 호출, 비즈니스 로직, UI 로직이 섞이기 쉬우므로 역할 분리 규칙을 미리 정해야 함.
- **Next.js(SSR/RSC) 환경 주의**: localStorage는 클라이언트에서만 접근 가능 하이드레이션 이슈가 생기면 hasHydrated 사용 필요하다.
- **타입스크립트 가이드 부족**: 팀 단위에서는 상태/액션 네이밍 규칙, 폴더 구조, 미들웨어 사용 방식 등을 통일해두는 게 안정적이다.

### 기존 프로젝트와 차이점

- 기존: 컴포넌트에서 authRepo를 직접 호출 -> 응답을 컴포넌트가 받아서 상태 세팅한다.
- 현재: 스토어 내부에서 authRepo 호출 -> 컴포넌트는 `useAuthStore()`에서 가져온 `login()` 같은 액션만 호출한다.

컴포넌트가 얇아지고, 재사용 쉬움(여러 화면에서 동일 로직 공유)

### 활용 방식

- **다크모드(테마) 관리에 Zustand 사용**
  - persist 미들웨어를 사용해 다크모드 설정을 로컬스토리지에 저장, 새로고침 후에도 이전 테마 상태를 복원하도록 구현하였다.
  - `useThemeStore()`의 `toggleTheme()` 액션으로 모드 전환을 처리하였다.

## 2. 데이터 페칭: React Query (@tanstack/react-query)

### 장점

- **서버 상태 관리에 특화**: 캐싱, 리페치, 리트라이, 동기화 등을 자동으로 처리해 서버 데이터 일관성을 유지한다.
- **로딩/에러 상태 자동 관리**: `isLoading`, `isError`, `data`, `error` 등 내장 상태를 제공해 별도 로직이 필요 없다.
- **자동 리페치 / 백그라운드 업데이트**: 포커스 복귀, 네트워크 재연결 시 자동으로 최신 데이터 요청.
- **데이터 캐싱 및 공유**: 동일한 쿼리 키로 여러 컴포넌트가 데이터를 공유해 불필요한 API 호출 감소.
- **Devtools 지원**: 쿼리 상태(캐시, 요청, 에러 등)를 시각적으로 확인할 수 있다.

### 단점 / 주의점

- **로컬 상태 관리에는 부적합**: 클라이언트 전용 상태(모달, 토글, 폼 등)는 Zustand 같은 전역 상태 관리가 더 적합하다.
- **쿼리 키 관리 복잡도**: 프로젝트 규모가 커질수록 쿼리 키 이름 규칙을 통일하지 않으면 유지보수가 어려워진다.

### 활용 방식

- **블로그 글 조회에 React Query를 사용**
  - `useQuery` 훅으로 게시글 리스트 혹은 게시글을 데이터를 비동기 요청하고, 캐싱된 데이터를 활용해 페이지 이동 시에도 빠르게 가져왔다.
  - `isLoading`, `isError` 상태를 통해 로딩 스피너 및 에러 메시지 UI를 제어하였다.
  - 동일한 쿼리 키 `(['posts', page])`로 페이지 간 데이터 공유 및 캐싱 재활용을 구현하였다.

## 3. 테스트: Jest + React Testing Library

### 장점

- **단위 테스트(Unit Test) 환경 표준**: Jest는 React 생태계에서 가장 널리 사용되는 테스트 러너로, 빠른 실행 속도와 간단한 설정을 제공한다.
- **React 전용 테스트에 최적화**: React Testing Library(RTL)는 DOM 중심으로 컴포넌트의 실제 동작을 테스트할 수 있게 도와준다.
- **사용자 관점의 테스트 철학**: RTL은 내부 구현보다는 **사용자가 화면에서 보는 결과**를 기준으로 테스트하도록 유도한다.
  - 예: 버튼 클릭 -> 문구 출력 같은 **UI 상호작용** 중심 테스트.
- **mock 처리 지원**: Jest의 `jest.fn()`이나 `jest.mock()`으로 API 호출, 외부 모듈 등을 가짜로 만들어 독립적으로 테스트 가능하다.
- **커버리지(coverage) 측정 용이**: 명령어 한 줄로 전체 테스트 커버리지(라인, 함수, 브랜치 기준)를 확인 가능하다.

### 단점 / 주의점

- **러닝커브 존재**: Jest의 mock 함수, spy, matcher 등에 익숙해지기까지 시간이 필요하다.
- **테스트 코드 유지보수 비용**: UI 변경이 잦을 경우 테스트 코드도 함께 수정해야 하므로, 테스트 전략(단위/통합)을 명확히 나눠야 한다.
- **환경 의존성 주의**: DOM API(window, document)를 사용하는 테스트는 jsdom 환경 설정이 필요하다.
- **비즈니스 로직과 UI 로직 혼합 테스트 지양**: 복잡한 로직은 별도 함수로 분리해 단위 테스트, UI는 RTL로 별도 검증하는 것이 효율적이다.

### 활용 방식

- 컴포넌트 단위 테스트 작성

  - Jest와 React Testing Library를 함께 사용하여 컴포넌트 렌더링, 텍스트 출력, 버튼 클릭 동작 등을 검증한다.
  - 예시:

    ```javascript
    import { render, screen, fireEvent } from "@testing-library/react";
    import { Counter } from "@/components/Counter";

    test("버튼 클릭 시 count가 증가한다", () => {
      render(<Counter />);
      const button = screen.getByText("Increase");
      fireEvent.click(button);
      expect(screen.getByText("Count: 1")).toBeInTheDocument();
    });
    ```

- 비즈니스 로직 테스트

  - 상태 관리 로직(Zustand store, reducer 등)은 Jest 단독으로 테스트하여 UI와 분리된 로직의 정확성을 검증한다.
  - 예시:

    ```javascript
    import { useCounterStore } from "@/stores/counter";

    test("increment 함수가 count를 증가시킨다", () => {
      const store = useCounterStore.getState();
      store.increment();
      expect(store.count).toBe(1);
    });
    ```

### 요약

| 구분           | Jest                             | React Testing Library                 |
| -------------- | -------------------------------- | ------------------------------------- |
| 역할           | 테스트 러너 및 mock 지원         | React 컴포넌트 렌더링/상호작용 테스트 |
| 관점           | 코드 로직 중심                   | 사용자(UI) 중심                       |
| 장점           | 빠른 속도, 강력한 mock 기능      | 직관적이고 유지보수 쉬운 테스트       |
| 함께 쓰는 이유 | 로직 + UI를 통합적으로 검증 가능 | React 생태계 표준 조합                |
