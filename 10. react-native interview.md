# React Native 면접 질문 젇리

## 1. 기본 개념

### RN 기본 동작 원리

<details>
<summary>React Native가 어떻게 브리지를 통해 네이티브와 통신하는지 설명할 수 있나요?</summary>

RN은 JavaScript 영역과 iOS/Android 네이티브 영역이 브리지라는 비동기 메시지 채널을 통해 데이터를 주고받는 구조입니다.
UI 렌더링은 네이티브에서 처리하고 로직은 JS 스레드에서 실행되며, RN은 이 둘을 연결해 네이티브 성능을 유지하면서 JS 개발 경험을 제공합니다.

</details>

<details>
<summary>React Native와 React의 가장 큰 차이는 무엇인가요?</summary>

React는 DOM을 렌더링하지만, RN은 네이티브 UI 컴포넌트로 렌더링합니다.
그래서 JSX는 동일하지만 렌더 타겟과 생태계가 완전히 다르며, 성능 이슈나 브리지 병목 같은 네이티브 특성도 고려해야 합니다.

</details>

<details>
<summary>RN의 렌더링 과정과 React의 렌더링 과정의 차이를 설명해 주세요.</summary>

리액트는 Virtual DOM → 실제 DOM 순으로 렌더링되지만, RN은 Virtual DOM을 기반으로 네이티브 UI 명령을 생성해 브리지로 전달합니다.
즉 DOM이 없고, 네이티브 컴포넌트로 직접 렌더링된다는 점이 가장 큰 차이입니다.

</details>

<details>
<summary>RN에서의 스타일링은 어떻게 동작하나요?</summary>

RN 스타일은 CSS-in-JS 형태지만 실제로는 네이티브의 스타일 시스템으로 변환됩니다.
웹 CSS와 비슷하지만 완전히 동일하지 않고, RN만의 스타일 속성 규칙을 따라야 합니다.

</details>

### 네비게이션

<details>
<summary>React Navigation을 사용할 때 주의할 점이 뭐가 있나요?</summary>
</details>

<details>
<summary>Stack / Tab / Drawer 각각 어떤 상황에 사용해야 하나요?</summary>
</details>

### 상태 관리

<details>
<summary>Zustand나 Recoil을 RN에서 사용한 경험이 있나요?</summary>
</details>

<details>
<summary>RN에서 상태 관리가 React 웹과 다르다고 느낀 점이 있나요?</summary>
</details>

## 2. 성능 & 최적화

### RN 성능 이슈

<details>
<summary>React Native 성능 저하가 주로 나타나는 원인은 무엇인가요?</summary>

JS 스레드가 오래 걸리는 작업에 막히거나, 브리지로 과도한 데이터가 오갈 때 성능 저하가 발생합니다.
특히 리스트나 이미지가 많은 화면에서 이 병목이 두드러집니다.

</details>

<details>
<summary>리스트 렌더링 최적화를 위해 어떤 기법을 사용했나요?</summary>

FlatList의 keyExtractor, getItemLayout, memoized renderItem을 적극 활용했습니다.
스크롤 중 불필요한 렌더링을 막고, 초반 렌더링을 줄이기 위해 pagingEnabled 구조를 적용한 적도 있습니다.

</details>

<details>
<summary>Reanimated 또는 Gesture Handler를 사용한 경험이 있나요?</summary>

Reanimated는 JS 스레드를 거치지 않는 애니메이션이라 성능 최적화에 효과적이었습니다.
Gesture Handler는 터치 이벤트를 네이티브가 직접 처리하기 때문에 스와이프 UI에서 부드러운 동작을 구현할 수 있었습니다.

</details>

### 브리지 병목

<details>
<summary>JS Thread와 Native Thread가 왜 병목을 만들 수 있는지 설명해 주세요.</summary>

Reanimated는 JS 스레드를 거치지 않는 애니메이션이라 성능 최적화에 효과적이었습니다.
Gesture Handler는 터치 이벤트를 네이티브가 직접 처리하기 때문에 스와이프 UI에서 부드러운 동작을 구현할 수 있었습니다.

이미지·애니메이션 처리에서 네이티브 기반 모듈을 활용하고, 리스트 데이터는 필요한 부분만 요청해 브리지 트래픽을 줄였습니다.
또한 Reanimated 같은 JS-Free 애니메이션 방식을 적극 사용했습니다.

</details>

### 이미지 & 애니메이션

<details>
<summary>RN에서 이미지 최적화를 어떻게 처리했나요?</summary>

이미지 사이즈를 서버에서 미리 리사이즈하여 전송하고 캐싱 라이브러리를 활용했습니다.
RN은 이미지 렌더링 비용이 높기 때문에 필요 이상으로 큰 이미지는 지양했습니다.

</details>

<details>
<summary>Lottie나 Reanimated 사용 경험이 있나요?</summary>

Lottie는 가벼운 애니메이션 구현에 유리했고, Reanimated는 성능이 중요한 작업에서 사용했습니다.

</details>

## 3. 네이티브 모듈 & 환경 구성

<details>
<summary>React Native에서 .env 파일을 불러오지 못하는 문제를 어떻게 해결했나요?</summary>

RN에서는 빌드 단계에서 env를 주입해야 하기 때문에 react-native-config를 사용했습니다.
iOS/Android 각각 설정이 필요해 빌드 캐시 초기화와 Xcode 설정까지 점검했습니다

</details>

<details>
<summary>expo와 pure RN의 차이점은 무엇인가요?</summary>

Expo는 설정이 단순하고 빠르게 개발할 수 있지만 네이티브 커스터마이징이 제한됩니다.
Pure RN은 설정이 복잡하지만 네이티브 기능을 자유롭게 붙일 수 있어 실무 확장성이 좋습니다.

</details>

<details>
<summary>iOS/Android 빌드 환경에서 발생했던 문제를 해결한 경험이 있나요?</summary>

iOS에서는 Xcode provisioning 및 pod 설치 문제를 해결한 적이 있습니다.

</details>

## 4. 네트워킹 / API / 인증

<details>
<summary>RN에서 axios를 사용할 때 주의해야 하는 점이 있나요?</summary>

쿠키 기반 인증이 되지 않기 때문에 토큰 기반 인증이 기본입니다.
또 AsyncStorage 접근이 비동기라 요청마다 토큰을 읽는 비용도 고려해야 했습니다.

</details>

<details>
<summary>RN에서는 쿠키 기반 인증이 어렵다고 하는데 이유는 무엇인가요?</summary>

브라우저 환경이 아니기 때문에 Set-Cookie 자동 처리나 SameSite 정책 기반 인증이 불가능합니다.
그래서 RN에서는 accessToken을 직접 저장하고 Authorization 헤더로 전달하는 방식이 일반적입니다.

</details>

## 5. 스토리지 / 보안

<details>
<summary>RN에서 AsyncStorage의 특징과 한계를 설명해 주세요.</summary>

간단한 key-value 저장에 적합하지만 암호화 기능이 없고 속도도 빠르지 않습니다.
또 많은 데이터를 저장하면 JS 스레드를 잠시 점유하는 문제도 있습니다.

</details>

<details>
<summary>accessToken을 AsyncStorage에 저장하는 것의 보안 리스크는 무엇인가요?</summary>

암호화되지 않은 저장소라서 루팅·탈옥 환경에서는 쉽게 노출될 수 있습니다.
그래서 중요한 데이터는 secure storage를 사용하는 것이 안전합니다.

</details>

## 6. 네비게이션 & 딥링크

<details>
<summary>딥링크 란 무엇인가요?</summary>

딥링크는 외부 앱이나 브라우저에서 특정 화면을 직접 열 수 있도록 하는 URI 기반 라우팅 기능입니다.
React Navigation과 Linking API로 구현됩니다.

</details>

<details>
<summary>다른 앱에서 내 앱을 직접 호출하려면 어떻게 구성해야 하나요?</summary>

iOS는 URL Scheme을 Info.plist에 등록하고, Android는 intent filter로 설정해야 합니다.

</details>

## 7. 포트폴리오 기반 질문

<details>
<summary>RN을 이용한 프로젝트에서 가장 기술적으로 어려웠던 문제는 무엇이었나요?</summary>

네트워킹 구조와 AsyncStorage 기반 토큰 관리가 가장 복잡했습니다.
또 초기에는 코드 중복이 많아 모듈화를 적용하면서 구조 개선이 필요했습니다.

</details>

<details>
<summary>RN을 선택한 이유는 무엇인가요?</summary>

iOS와 Android를 동시에 개발해야 했고, 빠른 MVP가 필요해 RN을 선택했습니다.

</details>

<details>
<summary>Alert / AsyncStorage 유틸 모듈화를 어떻게 개선했나요?</summary>

중복되는 Alert·Storage 코드를 모듈로 추출해 한 곳에서 관리하도록 구조화했습니다.
덕분에 유지보수성과 가독성이 크게 좋아졌습니다.

</details>

<details>
<summary>첫 번째 RN 프로젝트 코드가 비효율적이었다고 했는데, 어떤 점을 개선했나요?</summary>

반복 로직을 모두 util·hook으로 분리하고, 화면 내 로직을 컴포넌트 단위로 정리했습니다.
상태 관련 처리가 분산돼 있던 것도 하나로 모으는 방향으로 수정했습니다.

</details>

<details>
<summary>무거운 UI에서 렌더링 지연 문제를 어떻게 해결했나요?</summary>

불필요한 상태 업데이트를 막고 memoization을 적용했으며, FlatList 최적화도 함께 적용했습니다.

</details>

<details>
<summary>FlatList의 성능을 위해 어떤 props를 활용했나요?</summary>

keyExtractor, getItemLayout, initialNumToRender, windowSize 등을 조합했습니다.

</details>

## 8. 아키텍처 / 구조

<details>
<summary>RN 프로젝트 구조를 어떻게 설계했나요?</summary>

API, UI, 상태 관리, 유틸을 명확하게 분리해 기능별로 관리했습니다.
반복되는 요청·Alert·Storage 코드는 재사용성을 위해 모듈화했습니다.

</details>

<details>
<summary>네트워크, 라우팅, 상태 관리 등을 어떤 기준으로 분리했나요?</summary>

변경 가능성이 큰 부분(API, 인증)은 모듈로 따로 뺐고, 화면 로직은 hook 기반으로 격리했습니다.
라우팅은 React Navigation, 상태는 store/hook으로 role을 분리했습니다.

</details>
