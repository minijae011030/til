# JavaScript

## 1. 자바스크립트 개요

### ⭐ 자바스크립트는 무슨 언어인가요?

자바스크립트는 웹 브라우저에서 동작하는 인터프리터 기반의 스크립트 언어로,
동적 타입을 가지며 이벤트 기반, 비동기 프로그래밍을 지원하는 언어입니다.
현재는 브라우저뿐 아니라 Node.js 환경에서도 서버 사이드에서 사용됩니다.

## 2. 실행 컨텍스트 & 변수 동작 원리

### ⭐ 실행 컨텍스트와 호이스팅

JS 실행 전 실행 컨텍스트가 생성되며,
이 과정에서 선언 정보가 미리 메모리에 등록됩니다.

호이스팅이란,
자바스크립트 엔진이 코드 실행 전에
변수·함수의 선언 정보를 미리 스코프에 등록하는 동작입니다.

- var:선언이 호이스팅되고, 초기화(undefined)가 함께 진행됨
- let/const: 선언은 호이스팅되지만 TDZ로 접근 불가

→ 호이스팅은 실행 컨텍스트 생성 단계에서 발생합니다.

### ⭐ 변수 선언, 초기화, 할당의 차이

- 선언: 변수를 식별자 이름으로 등록
- 초기화: 메모리에 공간을 만들고 기본값(undefined) 할당
- 할당: 변수에 실제 값을 대입

```js
let a; // 선언 + 초기화
a = 10; // 할당
let b = 5; // 선언 + 초기화 + 할당
```

### ⭐ var, let, const 차이

- var
  - 함수 스코프
  - 재선언 가능
  - undefined로 호이스팅
- let
  - 블록 스코프
  - 재할당 가능
  - TDZ 존재
- const
  - 블록 스코프
  - 재할당 불가
  - 객체 내부 변경 가능
  - TDZ 존재
  - 선언과 동시에 초기화 반드시 필요

→ 기본적으로 const → let 순서로 사용

### ⭐ TDZ (Temporal Dead Zone)

TDZ는 let, const로 선언된 변수가
선언 위치에 도달하기 전까지 접근할 수 없는 구간을 의미합니다.

자바스크립트는 실행 전 실행 컨텍스트 생성 단계에서
변수 선언을 미리 메모리에 등록(호이스팅)하지만,
let / const는 초기화되기 전까지 접근을 금지합니다.

이 접근 불가능한 구간이 TDZ(Temporal Dead Zone) 입니다.

#### 왜 TDZ가 필요한가?

TDZ는 선언 전에 변수를 사용하는 실수를 막기 위한 안전장치입니다.

- var의 문제점
  - 선언 전에 접근해도 undefined 반환
  - 버그를 조기에 발견하기 어려움
- let / const
  - 선언 전 접근 시 즉시 ReferenceError 발생
  - 오류를 빠르게 발견 가능

## 3. 스코프 & 클로저

### ⭐ 스코프(Scope)

스코프는 변수에 접근할 수 있는 유효 범위를 의미합니다.
자바스크립트는 렉시컬 스코프(Lexical Scope)를 사용하며,
변수가 선언된 위치 기준으로 스코프가 결정됩니다.

- 전역 스코프
  - 어디서든 접근 가능
  - 남용 시 변수 충돌 위험
- 함수 스코프
  - 함수 내부에서만 접근 가능
  - var는 함수 스코프를 가짐
- 블록 스코프
  - {} 단위로 범위가 제한됨
  - let, const가 해당

→ 스코프를 잘 나누면 변수 충돌 방지, 코드 안정성 향상

### ⭐ 스코프 체인 (Scope Chain)

현재 스코프에서 변수를 찾지 못하면
상위 스코프로 순차적으로 탐색하는 구조입니다.

- 가장 가까운 스코프부터 탐색
- 전역 스코프까지 올라가도 없으면 ReferenceError

### ⭐ 클로저(Closure)

함수와 해당 함수가 선언된 렉시컬 환경의 조합입니다.

함수가 자신이 선언될 당시의 스코프를 기억하기 때문에,
함수 실행이 끝난 이후에도 외부 변수에 접근 가능합니다.

```js
function outer() {
  let count = 0;
  return function inner() {
    count++;
    return count;
  };
}

const fn = outer();
fn(); // 1
fn(); // 2
```

outer 실행은 끝났지만 inner는 count를 계속 기억

#### 클로저 사용 목적

- 상태 유지
- 캡슐화
- 정보 은닉

⚠️ 불필요한 클로저는 메모리 사용 증가 가능

## 4. this & 객체 생성

### ⭐ this

this는 함수가 호출되는 방식에 따라 결정되는 참조값입니다.

- 함수가 어디서 정의되었는지가 아닌 어떻게 호출되었는지에 따라 결정됩니다.
- this는 런타임에 결정됩니다.
- 화살표 함수만 예외적으로 선언시점의 this를 사용합니다.

→ **this는 함수의 소유자가 아니라 호출 주체를 가리킨다.**

- 전역 / 일반 함수 호출: window
  - func() → this === window
- 객체 메서드: 메서드를 호출한 해당 객체
  - obj.method() → this === obj
- 생성자 함수: 새로 생성된 인스턴스
  - new Constructor() → this === 생성된 인스턴스
- 화살표 함수: 상위 스코프의 this, 자신만의 this를 가지지 않음
  - () => {} → this === 상위 스코프의 this

### ⭐ 생성자(Constructor)

생성자 함수는 new 키워드를 통해 객체를 생성하기 위한 함수입니다.

new 호출 시 내부 동작

1. 빈 객체 생성
2. this가 해당 객체를 가리킴
3. 생성자 함수 본문 실행
4. 객체가 반환됨

→ 동일한 구조의 객체를 반복 생성할 때 사용

→ this와 prototype을 기반으로 동작

### ⭐ 프로토타입 체인(Prototype Chain)

객체에서 프로퍼티를 찾을 때 다음 순서로 탐색합니다.

> 자기 자신 → 프로토타입 → 상위 프로토타입 → Object.prototype

- 생성자 함수의 prototype을 통해 메서드 공유
- 이 구조가 자바스크립트의 상속 방식

→ 프로토타입 기반 언어의 핵심 개념

### ⭐ 함수 선언식 vs 화살표 함수

자바스크립트에서 함수는 선언 방식에 따라
호이스팅, this 바인딩, 생성자 사용 가능 여부가 달라집니다.

```js
function foo() {}
const bar = () => {};
```

#### 1. 정의 방식과 호이스팅 차이

**함수 선언식 (Function Declaration)**

```js
foo(); // 가능
function foo() {}
```

- 실행 컨텍스트 생성 시 함수 전체가 호이스팅
- 선언 이전에도 호출 가능

**화살표 함수 (Arrow Function)**

```js
bar(); // ReferenceError
const bar = () => {};
```

- 변수에 함수 값을 할당하는 함수 표현식
- 변수만 호이스팅되고, 함수는 런타입에 할당됨
- TDZ로 인해 선언 전 호출 불가

#### 2. this 바인딩 차이

**함수 선언식**

- 호출 방식에 따라 this가 결정됨 (동적 this)

**화살표 함수**

- 자신만의 this를 가지지 않음
- 선언 시점의 상위 스코프 this를 그대로 사용

→ 콜백, React 컴포넌트에서 this 문제를 피하기 위해 자주 사용

### ⭐ 화살표 함수가 new 생성자를 사용할 수 없는 이유

1. 자신만의 this가 없음
   - new는 this를 새 객체로 바인딩해야 함
   - 화살표 함수는 this 바인딩 불가
2. prototype이 없음
   - 화살표 함수는 prototype 프로퍼티를 가지지 않음
   - 프로토타입 체인 구성 불가 → 상속 불가
3. [[Construct]] 내부 슬롯이 없음
   - new는 내부적으로 [[Construct]] 호출
   - 화살표 함수는 해당 슬롯이 없어 TypeError 발생

→ 따라서 객체 생성, 상속 구조에는 사용할 수 없음

### ⭐ 사용 목적 정리

- 함수 선언식
  - 일반 함수
  - 생성자 함수
  - prototype 기반 로직
- 화살표 함수
  - 콜백 함수
  - this 고정이 필요한 경우
  - React 컴포넌트, 이벤트 핸들러

## 5. 타입 & 값 저장 방식

### ⭐ 원시 타입 vs 참조 타입 (값 저장 방식)

#### 원시 타입 (Primitive Type)

- number, string, boolean, null, undefined, symbol, bigint
- 값 자체가 저장됨
- 불변(immutable)

```js
let a = 10;
let b = a;
b = 20;

console.log(a); // 10
```

- a의 값 10이 그대로 복사됨
- b를 바꿔도 a에는 영향 없음

#### 참조 타입 (Reference Type)

- object, array, function
- 값은 힙(Heap)에 저장
- 변수는 메모리 주소(참조)를 가짐

```js
let obj1 = { count: 1 };
let obj2 = obj1;

obj2.count = 2;

console.log(obj1.count); // 2
```

- obj1, obj2가 같은 객체를 가리킴
- 한쪽을 수정하면 다른 쪽도 같이 변경됨

→ 얕은/깊은 복사, 불변성 문제의 출발점

### ⭐ 불변성과 상태 변경

#### 원시 값

```js
let a = 1;
a = 2;
```

- 기존 값 변경 ❌
- 새 값 생성 후 참조 변경

#### 객체

```js
let obj = { value: 1 };
obj.value = 2;
```

- 같은 객체 주소 유지
- 내부 값만 변경

→ 이 때문에 React에서 문제가 발생

#### React에서 state 직접 수정 시 문제

```js
state.count = 2; // ❌
```

- 객체 주소가 바뀌지 않음
- React는 변경을 감지하지 못함
- 리렌더링 발생 ❌

```js
setState({ ...state, count: 2 }); // ⭕
```

- 새로운 객체 생성
- 주소 변경 → React가 변경 감지

### ⭐ 깊은 복사 vs 얕은 복사

#### 얕은 복사 (Shallow Copy)

- 1단계까지만 복사
- 내부 객체는 여전히 같은 참조

```js
const obj1 = { user: { name: "A" } };
const obj2 = { ...obj1 };

obj2.user.name = "B";
console.log(obj1.user.name); // "B"
```

- 겉은 복사되지만 안쪽 객체는 공유

#### 깊은 복사 (Deep Copy)

- 중첩된 객체까지 전부 새로 복사
- 완전히 독립된 객체 생성

```js
const obj1 = { user: { name: "A" } };
const obj2 = structuredClone(obj1);

obj2.user.name = "B";
console.log(obj1.user.name); // "A"
```

### ⭐ 깊은 복사 방법과 한계

- JSON 방식: 간단하지만 Date, 함수, undefined, 순환 참조 불가
- structuredClone: 비교적 안전(환경 확인 필요)
- 라이브러리: lodash cloneDeep, immer

→ 데이터 형태에 따라 선택

## 6. 비동기 처리 & 이벤트 루프

### ⭐ 동기와 비동기

- 동기: 작업 순서 보장, 블로킹 발생 가능
- 비동기: 병렬 처리, UI 반응성 향상

### ⭐ 비동기 함수란

작업이 완료될 때까지 기다리지 않고
다음 코드를 실행할 수 있는 함수입니다.
네트워크 요청, 타이머 처리에 사용됩니다.

### ⭐ 콜백 함수

다른 함수의 인자로 전달되어 특정 시점에 실행되는 함수입니다.
비동기 처리에 자주 사용됩니다.

- 문제점: 콜백 지옥
- 해결: Promise, async/await

### ⭐ Promise

비동기 작업의 상태를 객체로 표현합니다.

- pending
- fulfilled
- rejected

.then(), .catch()로 처리

### ⭐ Promise vs Callback

- Callback
  - 중첩 증가 → 가독성 저하
  - 에러 처리 복잡
- Promise
  - 체이닝 가능
  - 에러 처리 일관적

### ⭐ Async/Await 설명

Promise 기반 비동기 처리를
동기 코드처럼 작성하는 문법입니다.

- async 함수는 항상 Promise 반환
- await은 resolve까지 대기

### ⭐ Promise와 Async/Await의 차이

- Promise: .then(), .catch()
- Async/Await: try-catch → 에러 처리 직관적

### ⭐ async/await 에러 처리는 왜 try-catch인가요?

에러가 Promise reject로 전달되기 때문에
동기 코드처럼 try-catch로 처리합니다.

### ⭐ try/catch가 비동기에서 안 먹는 경우

setTimeout 콜백 내부 에러는
외부 try/catch로 잡히지 않습니다.

- 다른 실행 컨텍스트에서 실행되기 때문

→ Promise/async-await로 에러 전달 필요

### ⭐ 이벤트 루프란?

자바스크립트는 기본적으로 싱글 스레드라서 한 번에 한 작업만 콜 스택(Call Stack) 에서 실행합니다.

그런데 네트워크 요청, 타이머, DOM 이벤트 같은 작업은 오래 걸릴 수 있기 때문에, 브라우저(또는 Node)는 이런 작업을 Web APIs(또는 백그라운드 영역) 로 보내 비동기로 처리하고, 완료된 작업을 큐(Queue) 에 쌓아두었다가 적절한 시점에 다시 콜 스택으로 올려 실행합니다.

이때 **언제 어떤 큐의 작업을 콜 스택으로 올릴지**를 관리하는 게 이벤트 루프입니다.

#### 구성 요소

1. Call Stack (콜 스택)

   - 지금 실행 중인 함수들이 쌓이는 실행 공간
   - 스택 구조(LIFO)라서 마지막에 들어온 함수가 먼저 끝남
   - 콜 스택이 바쁘면(작업이 길면) 화면/입력 반응이 늦어짐(“메인 스레드 블로킹”)

2. Web APIs (브라우저 제공 비동기 처리 영역)

   - setTimeout, fetch, DOM 이벤트 리스너, requestAnimationFrame 같은 작업을 처리
   - JS 엔진(V8 등) 바깥의 영역에서 비동기 작업이 수행됨
   - 작업이 완료되면 콜백을 큐로 이동시킴

3. Queue (대기열): 작업 완료 콜백들이 쌓이는 곳이며, 대표적으로 두 종류가 중요합니다.

   - **Task Queue** (Macrotask Queue)
     - setTimeout, setInterval, DOM 이벤트 콜백 등
   - **Microtask Queue**
     - Promise.then/catch/finally, queueMicrotask, MutationObserver
     - 현재 실행이 끝나자마자 바로 처리되는 우선순위가 높은 큐

#### 이벤트 루프 동작 순서 (핵심)

이벤트 루프는 기본적으로 다음 규칙을 반복합니다.

1. 콜 스택이 비면
2. 마이크로태스크 큐를 먼저 **완전히** 비울 때까지 실행
3. 그 다음 태스크 큐에서 하나 꺼내 실행
4. 다시 1~3 반복

- Microtask Queue는 **현재 작업이 끝난 직후** 최우선으로 처리
- Task Queue는 그 다음 순서

그래서 Promise.then()이 setTimeout(0)보다 먼저 실행됩니다.

## 7. 이벤트 & 이벤트 최적화

### ⭐ 이벤트(Event) 기본 개념

이벤트란 사용자의 행동(클릭, 입력, 스크롤 등)이나
브라우저에서 발생하는 상태 변화를 의미합니다.

브라우저는 이벤트가 발생하면
DOM 트리를 따라 이벤트를 전파시키며,
이 과정에는 캡처링 → 타겟 → 버블링 단계가 존재합니다.

### ⭐ 이벤트 버블링과 캡처링

이벤트는 DOM 트리를 따라 전파됩니다.

- 캡처링
  - 상위 요소 → 하위 요소 방향으로 이벤트 전파
  - (이벤트가 실제 대상에 도달하기 전 단계)
- 버블링
  - 하위 요소 → 상위 요소 방향으로 이벤트 전파
  - 기본 이벤트 동작 방식

→ 대부분의 이벤트 처리는 버블링 단계에서 이루어집니다.

### ⭐ target vs currentTarget

- target: 실제로 이벤트가 발생한 요소
- currentTarget: 이벤트 핸들러가 등록된 요소

→ 이 차이를 이용해 이벤트 위임을 구현합니다.

### ⭐ preventDefault vs stopPropagation

- preventDefault: 브라우저의 기본 동작을 막음 (링크 이동, form 제출 등) → 기본 동작 제어
- stopPropagation: 이벤트 전파(버블링/캡처링)를 중단 → 이벤트 전파 제어

### ⭐ 이벤트 위임(Event Delegation)

부모 요소에 이벤트를 등록해
자식 요소에서 발생한 이벤트를 처리하는 방식입니다.

- 이벤트 버블링을 활용
- 동적으로 생성된 요소도 처리 가능
- 이벤트 리스너 수 감소 → 성능·유지보수에 유리

### ⭐ 디바운스 vs 쓰로틀

이벤트가 너무 자주 발생할 때 성능을 최적화하는 기법입니다.

- 디바운스
  - 이벤트가 끝난 후 한 번만 실행
  - 검색 입력, 자동완성에 적합
- 쓰로틀
  - 일정 시간 간격으로만 실행
  - 스크롤, 리사이즈 이벤트에 적합

## 8. 자료구조 & 배열 메서드

### ⭐ forEach

배열의 각 요소를 순회하며 콜백 함수를 실행하는 메서드

- 반환값 없음 (undefined)
- 배열의 각 요소에 대해 동일한 로직을 수행
- 원본 배열을 직접 변경할 수 있음
- 순회 자체가 목적일 때 사용

→ 결과를 만들어내지 않음

→ 사이드이펙트 (출력, 상태 변경 등)에 적합

### ⭐ map

배열의 각 요소를 변환하여 새로운 배열을 생성하는 메서드

- 항상 새로운 배열을 반환
- 원본 배열은 변경되지 않음 (불변성 유지)
- 각 요소를 1:1로 매핑

→ 기존 배열 -> 가공된 새 배열

→ React에서 리스트 렌더링 시 가장 많이 사용

### ⭐ filter

주어진 조건을 만족하는 요소만 추출하여 새로운 배열을 반환하는 메서드

- 조건을 통과한 요소들로만 구성된 배열 반환
- 반환 배열의 길이는 원본보다 같거나 작음
- 원본 배열은 변경되지 않음 (불변성 유지)

→ 조건 기반 데이터 선별

→ 검색, 필터링 로직에 적합

### ⭐ find

주어진 조건을 만족하는 첫번째 요소 하나를 반환하는 메서드

- 조건을 만족하는 요소 하나만 반환
- 없으면 undefined
- 배열 전체를 반환하지 않음

→ 단일 객체 탐색 목적

→ id, key 기반 조회에 적합

### ⭐ reduce

배열의 각 요소를 누적하여 하나의 결과값을 생성하는 메서드

- 배열 -> 숫자, 객체, 배열, Map 등 다양한 형태로 축약 가능
- 초기값 설정 가능

→ 합게, 개수, 그룹화, 상태 집계에 사용

→ 복잡한 로직은 가독성을 해칠 수 있음

### ⭐ Map / Set이 Object / Array보다 유리한 경우

- Map: 키 제약 없음, 탐색 유리
- Set: 중복 제거 최적

## 9. 모듈 & 언어 기능

### ⭐ ES6 주요 기능

- let, const
- arrow function
- Promise
- async/await
- destructuring
- spread operator
- class, module

### ⭐ 모듈 시스템

- CommonJS: require, module.exports
- ES Module: import/export (트리 쉐이킹 유리)

## 10. 메모리 & 실행 구조

### ⭐ JS 메모리 관리

- 힙: 객체, 참조 타입
- 스택: 실행 컨텍스트, 원시 타입
- 가비지 컬렉션 자동 관리

### ⭐ 콜 스택과 힙

- 콜 스택: 함수 실행 순서 관리
- 힙: 객체 저장 공간

## 11. 기타 핵심 개념

### ⭐ 클래스

객체 생성을 위한 템플릿
prototype 기반 문법을 클래스 문법으로 표현

### ⭐ 제너레이터

yield를 사용해 실행을 중단·재개
이터러블 객체 생성

### ⭐ 엄격 모드(strict mode)

- 문법 오류를 에러로 처리
- 암묵적 전역 변수 방지

### ⭐ undefined / null / undeclared

- undefined: 값이 할당되지 않은 상태를 의미
  - 변수를 선언만 하고 값이 할당되지 않음
  - 자바스크립트 엔진이 자동으로 부여
  - 의도 ❌ (개발자가 명시적으로 쓰는 경우는 드묾)
  - 선언만 한 변수
  - 객체에 존재하지 않는 프로퍼티 접근
  - 함수에서 return 값이 없는 경우
- null: 의도적으로 비어 있음을 명시하는 값
  - 개발자가 직접 할당
  - 값이 없음을 의도적으로 표현
  - 객체 참조를 끊을 때 자주 사용
- undeclared: 선언되지 않음

### ⭐ == 와 === 차이

- ==: 타입 변환 후 비교
- ===: 타입 + 값 비교 (권장)

## 12. 원시 타입 메서드 & 자동 박싱

### ⭐ 원시 타입 메서드와 자동 박싱 (Auto Boxing)

자바스크립트의 원시 타입(string, number, boolean)은 객체가 아니지만,
메서드나 프로퍼티에 접근하는 순간 JS 엔진이 내부적으로 임시 객체로 변환해 처리합니다.

이 과정을 자동 박싱(auto-boxing) 이라고 합니다.

```js
"hello".length; // 가능
"hello".toUpperCase(); // 가능
```

동작 과정

1. 원시 타입 값 생성
2. 해당 타입의 객체(String, Number, Boolean)로 일시적 변환
3. 메서드/프로퍼티 접근
4. 사용 후 즉시 객체 제거

⚠️ 임시 객체이기 때문에 값을 저장할 수는 없습니다.

```js
let a = "hi";
a.custom = 1;
console.log(a.custom); // undefined
```

→ 원시 타입은 여전히 불변 값이며,

→ 메서드 호출만 가능하도록 일시적으로 객체처럼 동작합니다.
