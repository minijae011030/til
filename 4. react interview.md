# React 면접 질문 리스트

## 1. React 기본 개념

<details>
<summary>⭐️ React는 무엇이며 어떤 문제를 해결하기 위해 등장했나요?</summary>

React는 사용자 인터페이스를 효율적으로 만들기 위한 라이브러리로, 상태 변화에 따라 UI를 직접 조작하던 기존 프론트엔드 개발 방식의 복잡함을 줄이기 위해 등장했습니다.

데이터 변화에 따라 화면이 자동으로 다시 그려지도록 하여 UI 상태 관리와 유지보수를 쉽게 만듭니다.

✅ UI, 라이브러리, 상태 변화

</details>

<details>
<summary>React를 프레임워크가 아닌 라이브러리로 보는 이유는 무엇인가요?</summary>

리액트는 라우팅, 상태 관리, 테이터 패칭 등을 강제하지 않고 UI 렌더링에만 집중합니다. 전체 개발 흐름을 리액트가 제어하지 않고, 개발자가 필요한 도구를 선택해 조합할 수 있어 라이브러리로 분류됩니다.

반면에 프레임워크는 전체 개발 흐름의 제어권을 가지고 있다는 차이점이 있습니다.

✅ 개발 흐름

</details>

<details>
<summary>React의 핵심 철학(설계 사상)은 무엇인가요?</summary>

UI를 상태의 함수로 바라보는 선언형 접근과, 컴포넌트 단위로 UI를 분리해 재사용성과 예측 가능성을 높이는 것이 핵심 철학입니다.

</details>

<details>
<summary>선언형, 명령형 프로그래밍의 차이점은 무엇인가요></summary>

명령형 프로그래밍은 '어떻게'에 집중하여 절차를 직접 제어하는 방식이지만, 선언형 프로그래밍은 '무엇'이 보여야 하는지에 집중해서 결과 상태를 표현하는 방식입니다.

리액트는 선언형 접근 방식을 택하여 개발자가 직접 DOM을 조작해야 하는 복잡한 과정을 생략하게 해줍니다.

</details>

<details>
<summary>⭐️ 컴포넌트 기반 구조의 장점은 무엇인가요?</summary>

UI를 독립적인 단위로 나눌 수 있어 재사용이 쉽고, 변경 범위가 명확해 유지보수와 테스트가 용이합니다.

</details>

<details>
<summary>⭐️ 선언형 UI란 무엇인가요?</summary>

UI를 어떻게 그릴지보다 어떤 상태일 때 어떤 화면이 나와야 하는지를 선언하는 방식으로, 상태 변화에 따라 React가 필요한 UI 업데이트를 알아서 처리합니다.

</details>

## 2. JSX & 렌더링 구조

<details>
<summary>⭐️ JSX는 무엇이며 왜 필요한가요?</summary>

JSX는 JavaScript 안에서 UI 구조를 HTML처럼 작성할 수 있게 해주는 문법으로, UI 구조를 직관적으로 표현하고 가독성을 높이기 위해 사용됩니다.

</details>

<details>
<summary>JSX는 브라우저에서 어떻게 실행되나요?</summary>

JSX는 브라우저에서 직접 실행되지 않고, Babel을 통해 React.createElement 호출로 변환된 뒤 JavaScript로 실행됩니다.

</details>

<details>
<summary>Babel은 무엇인가요?</summary>

자바스크립트 트랜스파일러로, ES6+나 JSX처럼 브라우저가 이해하지 못하는 코드를 구형 브라우저도 이해할 수 있도록 ES5로 변환해줍니다.

</details>

<details>
<summary>React 17 이전과 이후의 JSX 컴파일 차이점에 대해서 아시나요?</summary>

React 17부터 도입된 새로운 JSX 변환 과정은 jsx-runtime을 활용합니다. 과거에는 모든 JSX 파일에 React를 수동으로 임포트해야 했고 React.createElement로 변환되었지만, 현재는 컴파일러가 자동으로 \_jsx 함수를 호출하도록 변환합니다.

이를 통해 React 임포트 없이도 JSX를 사용할 수 있게 되었으며, 함수 호출 방식이 단순화되어 런타임 성능 최적화와 번들 크기 감소라는 이점을 얻게 되었습니다.

✅ jsx-runtime

</details>

<details>
<summary>JSX와 HTML의 차이는 무엇인가요?</summary>

HTML은 정적인 마크업 언어로, 브라우저가 그대로 해석해 화면을 그리는 역할을 합니다.

반면 JSX는 JavaScript 안에서 UI 구조를 표현하기 위한 문법으로 브라우저에서 직접 실행되지 않고, JavaScript 코드로 변환되어 실행됩니다.

</details>

<details>
<summary>⭐️ React Element와 Component의 차이는 무엇인가요?</summary>

React Element는 UI를 설명하는 불변 객체이고, Component는 Element를 반환하는 함수 또는 클래스입니다.

한 번 생성된 Element는 수정되지 않으며, 변경이 필요하면 새로운 Element를 만들어 비교합니다.

</details>

## 3. Virtual DOM & Fiber

<details>
<summary>⭐️ Virtual DOM이란 무엇인가요?</summary>

Virtual DOM은 실제 DOM 구조를 **메모리 상 객체**로 표현한 것으로, 변경 전후를 비교해 최소한의 DOM 업데이트만 수행하기 위해 사용됩니다.

DOM 조작은 비용이 크기 때문에, Virtual DOM으로 변경 사항을 계산한 뒤 필요한 부분만 반영해 성능을 최적화합니다.

✅ 메모리 상 객체, 최소한의 DOM 업데이트, 성능 최적화

</details>

<details>
<summary>Virtual DOM의 동작 과정을 설명해보세요.</summary>

- 상태나 props가 변경되면 새로운 Virtual DOM 트리가 생성되고,
- 이전 Virtual DOM과 비교하는 diff 과정이 수행됩니다.
- 이 비교 결과를 바탕으로 실제 DOM에 꼭 필요한 변경만 반영함으로써 불필요한 DOM 조작을 줄입니다.

</details>

<details>
<summary>Diffing 알고리즘의 핵심 가정은 무엇인가요?</summary>

서로 다른 타입의 컴포넌트는 완전히 다른 트리로 간주하고, 같은 타입의 컴포넌트는 key를 기준으로 비교한다는 가정을 합니다. 이를 통해 비교 비용을 선형 시간으로 줄입니다.

key는 리스트 렌더링 시 각 요소를 고유하게 식별해 React가 변경, 추가, 삭제를 정확히 판단하도록 돕기 위해 필요합니다.

</details>

<details>
<summary>Fiber란 무엇인가요?</summary>

Fiber는 React의 새로운 렌더링 아키텍처로, **렌더링 작업을 작은 단위로 쪼개 관리**하는 내부 자료구조입니다.

기존 동기 렌더링 구조에서는 렌더링이 길어지면 사용자 인터랙션이 막히는 문제가 있었는데, Fiber는 작업을 중단하고 재개할 수 있게 해 이를 해결했습니다.

</details>

<details>
<summary>⭐️ React에서 비동기 렌더링이 가능한 이유는 무엇인가요?</summary>

Fiber 구조를 통해 렌더링 작업을 작은 단위로 나누고 중단·재개할 수 있어, 사용자 인터랙션을 막지 않는 비동기 렌더링이 가능합니다.

</details>

<details>
<summary>⭐️ React 컴포넌트는 언제 재렌더링되나요?</summary>

React 컴포넌트는 다음 상황에서 재렌더링됩니다.

- state가 변경될 때
- 새로운 props가 전달될 때
- 구독 중인 context 값이 변경될 때
- 부모 컴포넌트가 렌더링되며 새로운 props가 내려올 때

또한 재렌더링은 Virtual DOM을 다시 계산하는 과정이고, 실제 DOM은 변경이 필요한 부분만 최소로 반영되기 때문에, **재렌더링이 일어난다고 해서 항상 실제 DOM이 바뀌는 건 아닙니다.**

</details>

## 4. Batch Update & 상태 처리

<details>
<summary>Batch Update란 무엇인가요?</summary>

여러 상태 업데이트를 하나의 렌더링 사이클로 묶어 처리하는 방식입니다.

React 18 이후 이벤트 핸들러뿐 아니라 setTimeout, Promise 내부에서도 자동 배치가 적용됩니다.

</details>

<details>
<summary>⭐️ React는 왜 setState를 비동기적으로 처리하며, 여러 setState를 연속 호출하면 어떻게 동작하나요?</summary>

React는 여러 상태 변경을 하나의 렌더링 사이클로 묶어 처리하는 배치 업데이트를 통해 불필요한 재렌더링을 줄이고 성능을 최적화합니다.  
이 때문에 setState는 즉시 반영되지 않고 내부 큐에 쌓였다가 한 번에 처리됩니다.

여러 setState를 연속으로 호출할 경우, 객체 형태의 업데이트는 병합되어 처리되고, 함수형 업데이트는 이전 상태를 기준으로 순차적으로 실행됩니다.

이러한 방식은 상태 업데이트의 일관성을 유지하면서 렌더링 비용을 줄이기 위한 설계입니다.

```
const onClick = () => {
  setCount(count + 1); // count는 0이므로 (0 + 1) 예약
  setCount(count + 1); // 여전히 count는 0이므로 (0 + 1) 예약
  setCount(count + 1); // 여전히 count는 0이므로 (0 + 1) 예약
};
// 결과: count는 1이 됨
```

```
const onClick = () => {
  setCount(prev => prev + 1); // 큐에 "이전 값에 1 더해라"는 함수를 넣음
  setCount(prev => prev + 1); // 큐에 "그다음 값에 1 더해라"는 함수를 넣음
  setCount(prev => prev + 1); // 큐에 "또 그 다음 값에 1 더해라"는 함수를 넣음
};
// 결과: count는 3이 됨
```

</details>

## 5. 클래스 컴포넌트 vs 함수형 컴포넌트

<details>
<summary>클래스형 컴포넌트와 함수형 컴포넌트의 차이는 무엇인가요?</summary>

리액트에서 컴포넌트를 만드는 방법에는 클래스형 컴포넌트(class components)와 함수형 컴포넌트(functional components)가 있습니다.

- 클래스형 컴포넌트는 ES6의 클래스(class)를 사용하여 컴포넌트를 정의합니다.
- 반면에 함수형 컴포넌트는 ES6의 화살표 함수(arrow function)를 사용하여 컴포넌트를 정의합니다. 이 방식은 훅(hook) API와 함께 많이 사용됩니다.

클래스형 컴포넌트와 함수형 컴포넌트의 가장 큰 차이점은 상태와 생명주기의 다루는 방식입니다.

- 클래스형 컴포넌트는 상태를 this.state로 정의하고, 생명주기 메서드를 오버라이드하여 다양한 작업을 수행합니다.
- 반면에 함수형 컴포넌트는 상태를 useState 훅을 사용하여 정의하고, useEffect 훅을 사용하여 생명주기를 다룹니다.

- 또한, 클래스형 컴포넌트에서는 this 키워드를 사용하여 상태나 메서드를 참조하며,
- 함수형 컴포넌트에서는 this 키워드를 사용하지 않습니다. 이러한 차이점 때문에, 함수형 컴포넌트는 더 간결하고 가독성이 좋아지며, 테스트와 리팩토링이 쉽게 이루어질 수 있습니다.

</details>

<details>
<summary>⭐️ 함수형 컴포넌트를 권장하는 이유는 무엇인가요?</summary>

함수형 컴포넌트는 코드가 간결하고 상태와 로직의 흐름을 이해하기 쉬우며, Hooks를 통해 로직 재사용이 가능해 유지보수와 테스트에 유리합니다.

</details>

<details>
<summary>⭐️ Hooks는 왜 등장했나요?</summary>

기존 클래스 컴포넌트는 this 바인딩 문제와 생명주기 메서드에 로직이 흩어지는 구조로 인해 코드가 복잡해지고, 로직 재사용이 어려웠다는 한계가 있었습니다.

클래스 컴포넌트의 복잡성을 해결하고, 함수형 컴포넌트에서도 상태 관리와 사이드 이펙트를 처리할 수 있도록 하기 위해 등장했습니다.

</details>

<details>
<summary>⭐️ 클래스 컴포넌트의 라이프사이클을 설명해주세요.</summary>

클래스 컴포넌트는 컴포넌트의 생명주기가 메서드 단위로 명확하게 나뉘어 있습니다.

컴포넌트가 마운트(Mount) 되고, 업데이트(Update) 되고, 언마운트(Unmount) 되는 흐름에 따라 다음 단계가 있습니다.

1. Mount 단계

   - constructor: state 초기화, 메서드 바인딩을 수행합니다.
   - render: 화면에 그릴 UI를 반환합니다.
   - componentDidMount: 최초 렌더링 이후 한 번 실행되며, API 호출, 이벤트 등록 같은 작업에 사용됩니다.

2. Update 단계

   - shouldComponentUpdate: 렌더링 여부를 개발자가 제어할 수 있습니다.
   - render: 변경된 state/props를 기반으로 다시 렌더링합니다.
   - componentDidUpdate: 업데이트가 끝난 뒤 호출되며, 이전 값과 비교하여 추가 작업을 처리할 수 있습니다.

3. Unmount 단계

   - componentWillUnmount: 이벤트 제거, 타이머 해제 등 정리(clean-up) 작업을 담당합니다.

   </details>

<details>
<summary>⭐️ 함수형 컴포넌트의 라이프사이클을 설명해주세요.</summary>

함수형 컴포넌트는 별도의 생명주기 메서드가 없으며, 렌더링을 중심으로 동작하고,
생명주기 역할은 모두 useEffect 안에서 처리됩니다.

1. Mount 단계

   - useEffect(() => { ... }, [])
   - 의존성 배열이 빈 배열이면 컴포넌트가 마운트될 때 한 번만 실행됩니다.
     (API 호출, 이벤트 등록 등)

2. Update 단계

   - useEffect(() => { ... }, [deps])
   - 의존성 배열 값이 변경될 때마다 실행되며, 클래스의 componentDidUpdate 역할을 합니다.

3. Unmount 단계
   - useEffect(() => { return () => { ... } }, [])
   - clean-up 함수가 언마운트 시 실행되며, 이벤트 제거, 타이머 정리 등 componentWillUnmount 역할을 합니다.

</details>

## 6. 핵심 Hooks

### useState

<details>
<summary>⭐️ useState 훅에 대해 설명해주세요.</summary>

useState는 함수형 컴포넌트에서 상태를 관리하기 위해 사용하는 React Hook입니다.  
초기 상태 값을 전달하면 현재 상태 값과, 그 상태를 변경하기 위한 setter 함수를 배열 형태로 반환합니다.

상태가 변경되면 React는 해당 컴포넌트를 다시 렌더링하여, 변경된 상태가 UI에 반영되도록 합니다.  
이를 통해 함수형 컴포넌트에서도 클래스 컴포넌트와 동일하게 상태 기반 UI를 구성할 수 있습니다.

</details>

<details>
<summary>⭐️ useState는 상태 변경을 어떤 기준으로 감지하나요?</summary>

상태 값의 참조가 변경되었는지를 기준으로 변경을 감지합니다. 객체를 직접 수정하면 변경을 감지하지 못하므로, 항상 새로운 객체를 생성해 상태를 업데이트해야 합니다.

</details>

### useEffect

<details>
<summary>⭐️ useEffect 훅에 대해 설명해주세요.</summary>

렌더링 이후에 실행되어 데이터 패칭, 구독, DOM 조작 등 사이드 이펙트를 처리하는 역할을 합니다.

**컴포넌트가 렌더링된 이후에 실행**되며, 의존성 배열 값이 변경될 때마다 다시 실행됩니다.

</details>

<details>
<summary>clean-up 함수는 무엇이고 언제 실행되나요?</summary>

clean-up 함수는 useEffect 안에서 반환되는 함수로, 이전 effect에서 수행한 작업을 정리하기 위해 사용됩니다.  
주로 이벤트 리스너 제거, 타이머 해제, 구독 취소와 같은 정리 작업을 담당합니다.

이 clean-up 함수는 컴포넌트가 언마운트될 때 실행되거나, 의존성 배열 값이 변경되어 effect가 다시 실행되기 직전에 실행됩니다.

</details>

<details>
<summary>⭐️ 의존성 배열이 없는 경우와 빈 배열의 차이는 무엇인가요?</summary>

의존성 배열이 없으면 매 렌더링마다 실행되고, 빈 배열이면 최초 마운트 시 한 번만 실행됩니다.

</details>

<details>
<summary>useEffect가 재렌더링을 발생시키나요?</summary>

useEffect 자체는 재렌더링을 발생시키지 않지만, 내부에서 상태를 변경하면 재렌더링이 발생할 수 있습니다.

</details>

### useRef

<details>
<summary>⭐️ useRef 훅에 대해 설명해주세요.</summary>

useRef는 렌더링과 상관없이 유지되어야 하는 값을 저장하거나 DOM 요소를 **직접 참조**할 때 사용하는 Hook입니다.

ref 객체는 `{ current: … }` 형태로 값을 보관하며, 값이 변경되더라도 컴포넌트가 다시 렌더링되지 않는다는 것이 가장 큰 특징입니다.

</details>

<details>
<summary>⭐️ useRef와 useState의 차이는 무엇인가요?</summary>

useRef는 값이 변경돼도 렌더링을 발생시키지 않고, useState는 렌더링을 발생시킵니다. ref 값은 React의 렌더링 흐름과 무관하게 관리되기 때문에 렌더링을 발생시키지 않습니다.

- State는 UI에 영향을 미치는 값을 저장할 때 사용합니다.
  값이 변경되면 UI를 다시 그려야 하기 때문입니다.
- 반면 Ref는 렌더링과 무관한 값을 저장할 때 사용합니다.

즉, UI에 영향을 주면 state, UI와 무관하면 ref를 사용합니다.

</details>

<details>
<summary>DOM을 ref로 참조할 때 초기값을 null로 넣는 이유는 무엇인가요?</summary>

```ts
const divRef = useRef<HTMLDivElement>(null);
```

컴포넌트가 처음 렌더링될 때 DOM이 아직 존재하지 않기 때문에, ref의 초기값은 반드시 null이어야 합니다.

렌더링이 끝난 후 React가 ref.current = 실제 DOM 요소로 자동으로 넣어주기 때문에, 타입 안전성과 React 동작 방식 측면에서도 useRef<HTMLDivElement>(null)이 정석입니다.

</details>

### 의존성 배열

<details>
<summary>⭐️ 의존성 배열은 어떤 방식으로 비교되나요?</summary>

의존성 배열에는 내부에서 사용하는 모든 외부 값이 명시되어야 하며, 참조 값만 비교하는 방식인 **얕은 비교**를 통해 이전 값과 현재 값을 비교합니다.

</details>

<details>
<summary>⭐️ 객체/함수가 의존성에 들어가면 왜 문제가 되나요?</summary>

렌더링마다 새로운 참조가 생성되어 의존성이 변경된 것으로 판단될 수 있기 때문입니다.

</details>

<details>
<summary>⭐️ stale closure란 무엇인가요?</summary>

의존성 배열에 포함되지 않은 값이 오래된 상태로 캡처되어 최신 값을 참조하지 못하는 현상입니다.

</details>

## 7. 이벤트 & Form

<details>
<summary>⭐️ 제어 컴포넌트와 비제어 컴포넌트의 차이는 무엇인가요?</summary>

- 제어 컴포넌트는 상태로 값을 관리하고, (state)
- 비제어 컴포넌트는 DOM 자체에서 값을 관리합니다. (ref)

상태를 통해 값이 일관되게 관리되어 검증과 로직 처리가 쉽기 때문에 일반적으로 제어 컴포넌트가 권장됩니다.

</details>

<details>
<summary>forwardRef에 대해 설명해주시요.</summary>

forwardRef는 ref를 컴포넌트 간 전달하기 위해 사용합니다.

리액트에서 ref는 key와 마찬가지로 props 가 아닌 다른 용도로 전달되도록 설정되어 있습니다. 그래서 하위 컴포넌트의 props에서 전달받은 ref를 참조할 수 없습니다.

이때 하위 컴포넌트를 forwardRef 함수로 감싸게 되면, 부모 컴포넌트에서 전달한 ref를 하위 컴포넌트에서 참조할 수 있습니다.

</details>

<details>
<summary>Synthetic Event란 무엇인가요?</summary>

Synthetic Event는 브라우저의 네이티브 이벤트를 감싸 React에서 일관된 인터페이스로 제공하는 이벤트 시스템입니다. **브라우저 차이를 신경 쓰지 않고 동일한 방식으로 이벤트를 처리**할 수 있게 해줍니다.

</details>

## 8. 데이터 흐름 & 상태 전달

<details>
<summary>⭐️ React가 단방향 데이터 흐름을 사용하는 이유는 무엇인가요?</summary>

데이터 흐름을 예측 가능하게 만들어 디버깅과 유지보수를 쉽게 하기 위해서입니다.

만약 자식에서 부모 상태를 변경하려면 부모에서 상태 변경 함수를 props로 내려 자식에서 호출하도록 합니다.

</details>

<details>
<summary>⭐️ Props Drilling이란 무엇인가요?</summary>

중간 컴포넌트들이 필요 없는 props를 계속 전달하는 현상입니다.

컴포넌트 구조가 복잡해지고 유지보수가 어려워지는 문제점이 있는데,
Context API나 전역 상태 관리 라이브러리를 사용하여 해결할 수 있습니다.

</details>

## 9. 렌더링 최적화

<details>
<summary>key props에 대해 설명해주세요.</summary>

리스트 항목을 고유하게 식별해 효율적인 diff를 가능하게 합니다.
index를 key로 쓰면 요소 순서 변경 시 잘못된 재사용이 발생할 수 있습니다.

</details>

<details>
<summary>메모이제이션이란 무엇인가요?</summary>

이전 계산 결과를 저장해 불필요한 연산과 렌더링을 줄이는 기법입니다.

</details>

<details>
<summary>useMemo 훅을 설명해 주세요.</summary>

useMemo 훅은 이전에 저장된 값을 메모이제이션 하는 훅입니다.
useMemo 훅의 첫 번째 파라미터로 콜백 함수, 두 번째 파라미터로 배열을 저장합니다.

콜백 함수에서는 실제로 저장할 값을 계산하는 로직을 포함합니다.
useEffect의 의존성 배열과 마찬가지로 useMemo의 두 번째 파라미터인 의존성 배열에 포함된 값이 업데이트될 때마다 해당 콜백 함수를 다시 실행해서 값을 업데이트합니다.

useMemo를 적절히 활용하면 오래 걸리는 복잡한 연산의 결괏값을 저장해 놓고 사용해서 최적화를 할 수 있습니다.

</details>

<details>
<summary>useMemo와 React.memo의 차이는 무엇인가요?</summary>

React.memo는 HOC이고, useMemo는 훅입니다.
React.memo는 컴포넌트 자체를 메모이제이션한 용도로 사용하고, useMemo는 복잡한 계산의 결과 값을 메모이제이션하는 용도로 사용합니다. 물론 컴포넌트도 넣을 수는 있습니다.

</details>

<details>
<summary>⭐️ HOC(Higher-Order Component)란 무엇인가요?</summary>

HOC는 컴포넌트를 입력으로 받아 새로운 컴포넌트를 반환하는 함수를 의미합니다.
즉, 컴포넌트를 감싸 기능을 확장하는 패턴입니다.

React.memo, connect(React-Redux), withRouter(React Router v5) 등이 모두 HOC입니다.

</details>

<details>
<summary>useCallback 훅을 설명해 주세요.</summary>

useCallback 훅은 useMemo 훅과 비슷한 기능으로, 함수를 메모이제이션 하는 훅입니다.

useCallback 훅도 첫 번째 파라미터로 저장할 콜백 함수, 두 번째 파라미터로 배열을 저장합니다.
두 번째 파라미터로 제공된 의존성 배열에 포함된 값이 변경될 때마다 콜백 함수를 다시 생성합니다.

</details>

## 10. 고급 개념

<details>
<summary>⭐️ Context API에 대하여 설명해주세요</summary>

Props Drilling 없이 전역적으로 값을 공유할 수 있게 해줍니다.

Context를 상태 관리처럼 쓰면 Context 값 변경 시 불필요한 재렌더링이 발생할 수 있습니다.

</details>

<details>
<summary>Portal에 대해 설명해주세요.</summary>

Portal은 컴포넌트를 부모 컴포넌트 트리 안에서 렌더링하되, 실제 DOM은 다른 위치에 붙여 렌더링하는 기능입니다.  
주로 모달, 토스트, 툴팁처럼 부모 DOM 안에 두면 레이아웃/클리핑 문제가 생기는 UI를 처리할 때 사용합니다.

</details>

<details>
<summary>Error Boundary에 대해 설명해주세요.</summary>

Error Boundary는 렌더링 중 발생한 에러를 잡아 애플리케이션 전체 크래시를 방지합니다.

**에러는 렌더링 과정에서 발생하며, 이는 클래스 생명주기에서만 처리 가능하기 때문에 훅으로는 제공되지 않습니다.**

</details>

<details>

<summary>왜 Hook으로는 Error Boundary를 만들 수 없나요?</summary>

1. Hook은 렌더링 중 호출되기 때문에 에러를 처리할 수 없습니다.

   Hooks는 렌더링 과정 안에서 호출되어야 하는 규칙이 있습니다.
   하지만 Error Boundary는 렌더링 에러 자체를 잡아야 합니다.

   Hook은 이미 에러가 터진 후에는 호출될 수 없습니다.
   따라서 렌더링 자체가 실패한 상황을 Hook이 개입할 수 있는 구조가 아닙니다.

2. useEffect는 렌더링 이후 실행되므로 에러를 잡을 수 없습니다.

   렌더링 과정에서 에러가 발생하면 컴포넌트가 정상 렌더링 완료 상태가 아니기 때문에 useEffect, useLayoutEffect 둘 다 실행되지 않습니다.

   즉, 훅은 렌더링이 끝나야만 실행되는데,
   Error Boundary는 렌더링 중 에러를 잡아야 하므로 훅으로 구현할 수 없습니다.

</details>
