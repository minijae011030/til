# Architecture 면접 질문 리스트

## 1. Atomic Design

<details>
<summary>Atomic Design을 선택한 이유는 무엇인가요?</summary>

프로젝트에서 shadcn 같은 컴포넌트 라이브러리가 아니라 직접 디자인 시스템을 구성해야 했기 때문에, 일관성과 재사용성을 확보하는 것이 중요했습니다.
Atomic Design 구조를 적용하면서 공통 UI를 체계적으로 정리할 수 있었고, 컴포넌트 확장과 유지보수가 훨씬 용이했습니다.

</details>

<details>
<summary>Atomic Design의 각 단계(Atoms, Molecules, Organisms)를 프로젝트에서는 어떻게 분리했나요?</summary>

더 이상 쪼갤 수 없는 가장 기본 단위는 Atoms, 두세 개의 UI가 결합된 구조는 Molecules, 화면의 특정 영역을 구성하는 복합 UI는 Organisms로 구분했습니다.

예를 들어 Button 자체는 Atom, Label + Input 조합은 Molecule, Header나 Sidebar는 Organism으로 분리했습니다.

</details>

<details>
<summary>Atoms와 Molecules 기준을 어떻게 구분하셨나요?</summary>

**더 이상 나눌 수 있는지 없는지**와 **단독으로 의미가 있는 UI인지**를 기준으로 나눴습니다.

- 독립적인 UI 요소는 Atom,
- 서로 결합해 의미가 생기는 UI는 Molecule로 유지했습니다.

</details>

<details>
<summary>Organism과 Template을 지나치게 복잡하게 만들지 않기 위해 어떤 기준을 두셨나요?</summary>

조합된 UI 안에 로직이 섞이거나 지나치게 많은 역할을 하는 것을 피하려고 했습니다.
UI는 Atomic에서 관리하고, 비즈니스 로직은 FSD feature에서 관리하는 식으로 책임을 분리했습니다.

</details>

<details>
<summary>Atomic Design 적용 후 유지보수성이 어떻게 개선되었나요?</summary>

새로운 화면을 만들 때 기존 Atoms·Molecules를 재사용할 수 있어 속도가 빨라졌고, UI 스타일도 자연스럽게 통일되었습니다.
컴포넌트 중복이 줄고, 수정을 한 곳에서만 하면 되기 때문에 유지보수가 명확해졌습니다.

</details>

<details>
<summary>Atomic 구조가 너무 쪼개져서 오히려 복잡해지는 문제를 어떻게 방지했나요?</summary>

UI만 Atomic으로 나누고, 로직이 들어가는 순간 FSD로 넘겼습니다.
즉, Atoms/Molecules는 **멍청한 UI 컴포넌트**, 비즈니스 로직이 필요한 기능은 feature에서 관리하는 구조로 분리했습니다.

</details>

<details>
<summary>Atomic Design과 컴포넌트 재사용성 사이에 충돌이 생긴 적이 있나요? 어떻게 해결했나요?</summary>

UI 중심의 Atomic 구조는 재사용성에 유리했기 때문에 큰 충돌은 없었습니다.

다만 스타일만 조금 다른 케이스가 발생했을 때는 Variant 기반으로 해결하거나 Molecule을 새로 만들기보다 재구성해 재사용성을 우선했습니다.

</details>

## 2. FSD (Feature-Sliced Design)

<details>
<summary>왜 FSD를 사용했나요? 기존 레이어드 구조와 비교해 어떤 점이 더 좋았나요?</summary>

제가 진행했던 프로젝트는 ‘유저’, ‘스터디’처럼 기능이 명확히 분리된 구조였고, CRUD 중심 기능이 많았습니다.

FSD는 기능별로 폴더가 묶여 있어 파일이 흩어지지 않고, 한 기능을 완결성 있게 관리할 수 있어 적용했습니다.

</details>

<details>
<summary>FSD에서 features · entities · shared · widgets · pages 를 어떤 기준으로 나눴나요?</summary>

- Entities → 가장 큰 도메인 단위(예: user, study)
- Features → 엔티티 안에서 발생하는 구체적인 기능(예: createStudy, updateUserProfile)
- Widgets → 당시에는 사용하지 않았지만, 후반부엔 사용 필요성을 느꼈습니다
- Shared → 공통 컴포넌트, 유틸, 아토믹 컴포넌트
- Pages → Next.js 라우팅과 결합해 UI + 기능 조합이 이루어지는 구역

</details>

<details>
<summary>FSD 적용으로 실제 프로젝트에서 해결된 문제는 무엇이었나요?</summary>

파일들이 도메인별로 정리돼 기능 개발 시 필요한 파일들이 한곳에 모여 있어 작업 효율이 좋아졌습니다.

또 기능 확장 시 충돌이 줄고, 유지보수할 때 탐색 비용이 많이 줄었습니다.

</details>

## 3. 프로젝트 적용 방식

<details>
<summary>프로젝트에서 Atomic + FSD 구조를 어떻게 조합했나요?</summary>

UI는 Atomic으로 관리했고, 비즈니스 로직은 FSD의 feature·entity에서 담당하도록 역할을 나눴습니다.

결과적으로 UI/로직이 자연스럽게 분리되면서 구조적인 장점이 컸습니다.

</details>

<details>
<summary>이 기능이 feature인지 entity인지 모호한 상황을 어떻게 판단하셨나요?</summary>

그 기능이 **어떤 도메인의 소유인지**를 먼저 판단했습니다.
도메인 자체를 대표하면 entity이고, 그 도메인을 사용하는 구체적 기능이면 feature로 분리했습니다.

</details>

<details>
<summary>기능이 커질 때 FSD 디렉토리를 어떻게 확장하셨나요?</summary>

기능이 복잡해졌을 때 FSD 구조를 확장하는 부분에서 팀원 간 기준이 달라 조금 어려움이 있었던 경험이 있습니다.

그 경험을 바탕으로, 큰 프로젝트에서는 feature 안에서 sub-feature 단위로 한 번 더 나누고, 재사용되는 부분은 widgets나 shared로 흡수하는 식으로 확장하는 것이 좋은 방향이라고 생각합니다.

</details>

<details>
<summary>라우팅(TanStack Router / React Navigation 등)과 FSD 구조는 어떻게 연결하셨나요?</summary>

Next.js에서는 라우터 구조가 이미 app 단에서 정의되므로, 페이지 단에서 entity와 feature를 조합해 화면을 구성했습니다.

라우팅은 Next.js가 담당, 도메인 로직은 FSD가 담당하는 구조였습니다.

</details>

<details>
<summary>공통 UI 컴포넌트와 비즈니스 로직을 명확하게 분리한 기준은 무엇인가요?</summary>

UI는 완전히 dumb component여야 한다는 원칙을 유지했습니다.
로직이 한 줄이라도 들어가면 feature로 이동시키고, UI는 props만 받아서 렌더하는 방식으로 유지했습니다.

</details>

## 4. 상태 관리 + Architecture

<details>
<summary>Atomic/FSD 적용 시 상태 관리는 어디에 두는 것이 가장 적절하다고 판단했나요?</summary>
</details>

<details>
<summary>React Query(서버 상태)와 Zustand(클라이언트 상태)를 어떻게 분리해서 사용했나요?</summary>
</details>

<details>
<summary>Feature 내부에서 글로벌 상태를 사용해야 할 때 어떤 전략을 사용했나요?</summary>
</details>

<details>
<summary>서버 상태와 로컬 상태가 섞이면서 구조가 무너지는 것을 어떻게 방지했나요?</summary>
</details>

## 5. 확장성 / 유지보수 관점

<details>
<summary>컴포넌트/기능이 늘어날 때 아키텍처가 복잡해지지 않도록 어떤 기준을 유지했나요?</summary>
</details>

<details>
<summary>팀원들이 구조를 잘 이해하도록 어떤 네이밍 규칙과 분리 기준을 정했나요?</summary>
</details>

<details>
<summary>“이 컴포넌트 어디에 넣어야 맞는가?”가 모호할 때 어떤 판단 흐름을 가지고 결정했나요?</summary>
</details>

<details>
<summary>FSD 구조에서 기능 간 의존성을 최소화하기 위해 어떤 규칙을 적용했나요?</summary>
</details>

## 6. TanStack Router + Architecture (백오피스 인턴 경험 기반)

<details>
<summary>TanStack Router의 라우트 단위가 FSD 구조와 충돌하지 않도록 어떻게 설계했나요?</summary>
</details>

<details>
<summary>검색 파라미터(useSearchParams) 기반 화면 상태를 어디에 두는 것이 맞다고 판단했나요?</summary>
</details>

<details>
<summary>백오피스처럼 페이지가 많고 복잡한 앱에서 tanstack router  아키텍처가 어떤 점에서 도움을 줬나요?</summary>
</details>

<details>
<summary>동일 기능을 여러 화면에서 공유할 때 어떤 구조적 접근을 하셨나요?</summary>
</details>

## 7. 코드 품질 / 모듈화 관점

<details>
<summary>공통 로직(API, ErrorBoundary, Form, Pagination 등)을 어디에 배치했나요?</summary>
</details>

<details>
<summary>유틸 함수, 커스텀 훅, 공통 컴포넌트가 무분별하게 shared에 몰리는 문제를 어떻게 방지했나요?</summary>
</details>

<details>
<summary>Atomic/FSD 구조 덕분에 재사용된 컴포넌트 사례를 하나 설명해 주세요.</summary>
</details>

<details>
<summary>반대로 구조 때문에 오히려 복잡해졌던 부분은 무엇인가요? 어떻게 해결했나요?</summary>
</details>
