# 251104

## 1. 상태관리: zustand (persist 미들웨어)

### 장점

- **가볍고 단순**: create() 한 줄로 바로 상태와 액션 선언 가능하며 보일러플레이트가 거의 없다.
- **필요한 부분만 구독 가능**: `useStore((s) => s.slice)`처럼 필요한 slice만 선택적으로 구독하여 불필요한 리렌더가 줄어든다.
- **간단한 영속화**: persist 미들웨어로 로컬스토리지나 세션스토리지에 상태를 쉽게 저장 가능하다. (부분 저장도 가능)

### 단점 / 주의점

- **너무 자유로워서 구조가 흐트러지기 쉬움**: API 호출, 비즈니스 로직, UI 로직이 섞이기 쉬우므로 역할 분리 규칙을 미리 정해야 함.
- **Next.js(SSR/RSC) 환경 주의**: localStorage는 클라이언트에서만 접근 가능 하이드레이션 이슈가 생기면 hasHydrated 사용 필요하다.
- **타입스크립트 가이드 부족**: 팀 단위에서는 상태/액션 네이밍 규칙, 폴더 구조, 미들웨어 사용 방식 등을 통일해두는 게 안정적이다.

### 기존 프로젝트와 차이점

- 기존: 컴포넌트에서 authRepo를 직접 호출 -> 응답을 컴포넌트가 받아서 상태 세팅한다.
- 현재: 스토어 내부에서 authRepo 호출 -> 컴포넌트는 `useAuthStore()`에서 가져온 `login()` 같은 액션만 호출한다.

컴포넌트가 얇아지고, 재사용 쉬움(여러 화면에서 동일 로직 공유)

### 활용 방식

- **다크모드(테마) 관리에 Zustand 사용**
  - persist 미들웨어를 사용해 다크모드 설정을 로컬스토리지에 저장, 새로고침 후에도 이전 테마 상태를 복원하도록 구현하였다.
  - `useThemeStore()`의 `toggleTheme()` 액션으로 모드 전환을 처리하였다.

## 2. 데이터 페칭: React Query (@tanstack/react-query)

### 장점

- **서버 상태 관리에 특화**: 캐싱, 리페치, 리트라이, 동기화 등을 자동으로 처리해 서버 데이터 일관성을 유지한다.
- **로딩/에러 상태 자동 관리**: `isLoading`, `isError`, `data`, `error` 등 내장 상태를 제공해 별도 로직이 필요 없다.
- **자동 리페치 / 백그라운드 업데이트**: 포커스 복귀, 네트워크 재연결 시 자동으로 최신 데이터 요청.
- **데이터 캐싱 및 공유**: 동일한 쿼리 키로 여러 컴포넌트가 데이터를 공유해 불필요한 API 호출 감소.
- **Devtools 지원**: 쿼리 상태(캐시, 요청, 에러 등)를 시각적으로 확인할 수 있다.

### 단점 / 주의점

- **로컬 상태 관리에는 부적합**: 클라이언트 전용 상태(모달, 토글, 폼 등)는 Zustand 같은 전역 상태 관리가 더 적합하다.
- **쿼리 키 관리 복잡도**: 프로젝트 규모가 커질수록 쿼리 키 이름 규칙을 통일하지 않으면 유지보수가 어려워진다.

### 활용 방식

- **블로그 글 조회에 React Query를 사용**
  - `useQuery` 훅으로 게시글 리스트 혹은 게시글을 데이터를 비동기 요청하고, 캐싱된 데이터를 활용해 페이지 이동 시에도 빠르게 가져왔다.
  - `isLoading`, `isError` 상태를 통해 로딩 스피너 및 에러 메시지 UI를 제어하였다.
  - 동일한 쿼리 키 `(['posts', page])`로 페이지 간 데이터 공유 및 캐싱 재활용을 구현하였다.
