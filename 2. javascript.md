# JavaScript

## 1. 자바스크립트 개요

### ⭐ 자바스크립트는 무슨 언어인가요?

자바스크립트는 웹 브라우저에서 동작하는 인터프리터 기반의 스크립트 언어로,
동적 타입을 가지며 이벤트 기반, 비동기 프로그래밍을 지원하는 언어입니다.
현재는 브라우저뿐 아니라 Node.js 환경에서도 서버 사이드에서 사용됩니다.

## 2. 실행 컨텍스트 & 변수 동작 원리

### ⭐ 실행 컨텍스트와 호이스팅

JS 실행 전 실행 컨텍스트가 생성되며,
이 과정에서 선언 정보가 미리 메모리에 등록됩니다.

호이스팅이란,
자바스크립트 엔진이 코드 실행 전에
변수·함수의 선언 정보를 미리 스코프에 등록하는 동작입니다.

- var: 선언 + 초기화 호이스팅
- let/const: 선언은 호이스팅되지만 TDZ로 접근 불가

→ 호이스팅은 실행 컨텍스트 생성 단계에서 발생합니다.

### ⭐ 변수 선언, 초기화, 할당의 차이

- 선언: 변수를 식별자 이름으로 등록
- 초기화: 메모리에 공간을 만들고 기본값(undefined) 할당
- 할당: 변수에 실제 값을 대입

```js
let a; // 선언 + 초기화
a = 10; // 할당
let b = 5; // 선언 + 초기화 + 할당
```

### ⭐ var, let, const 차이

- var
  - 함수 스코프
  - 재선언 가능
  - undefined로 호이스팅
- let
  - 블록 스코프
  - 재할당 가능
  - TDZ 존재
- const
  - 블록 스코프
  - 재할당 불가
  - 객체 내부 변경 가능
  - TDZ 존재

→ 기본적으로 const → let 순서로 사용

### ⭐ TDZ (Temporal Dead Zone)

TDZ는 let, const로 선언된 변수가
선언 위치에 도달하기 전까지 접근할 수 없는 구간을 의미합니다.

자바스크립트는 실행 전 실행 컨텍스트 생성 단계에서
변수 선언을 미리 메모리에 등록(호이스팅)하지만,
let / const는 초기화되기 전까지 접근을 금지합니다.

이 접근 불가능한 구간이 TDZ(Temporal Dead Zone) 입니다.

#### 왜 TDZ가 필요한가?

TDZ는 선언 전에 변수를 사용하는 실수를 막기 위한 안전장치입니다.

- var의 문제점
  - 선언 전에 접근해도 undefined 반환
  - 버그를 조기에 발견하기 어려움
- let / const
  - 선언 전 접근 시 즉시 ReferenceError 발생
  - 오류를 빠르게 발견 가능

## 3. 스코프 & 클로저

### ⭐ 스코프(Scope)

스코프는 변수에 접근할 수 있는 유효 범위를 의미합니다.
자바스크립트는 렉시컬 스코프(Lexical Scope)를 사용하며,
변수가 선언된 위치 기준으로 스코프가 결정됩니다.
- 전역 스코프
  - 어디서든 접근 가능
  - 남용 시 변수 충돌 위험
- 함수 스코프
  - 함수 내부에서만 접근 가능
  - var는 함수 스코프를 가짐
- 블록 스코프
  - {} 단위로 범위가 제한됨
  - let, const가 해당

→ 스코프를 잘 나누면 변수 충돌 방지, 코드 안정성 향상

### ⭐ 스코프 체인 (Scope Chain)
 
현재 스코프에서 변수를 찾지 못하면
상위 스코프로 순차적으로 탐색하는 구조입니다.
- 가장 가까운 스코프부터 탐색
- 전역 스코프까지 올라가도 없으면 ReferenceError

### ⭐ 클로저(Closure)

함수와 해당 함수가 선언된 렉시컬 환경의 조합입니다.

함수가 자신이 선언될 당시의 스코프를 기억하기 때문에,
함수 실행이 끝난 이후에도 외부 변수에 접근 가능합니다.

```js
function outer() {
  let count = 0;
  return function inner() {
    count++;
    return count;
  };
}

const fn = outer();
fn(); // 1
fn(); // 2
```
 
outer 실행은 끝났지만 inner는 count를 계속 기억

클로저 사용 목적
- 상태 유지
- 캡슐화
- 정보 은닉

⚠️ 불필요한 클로저는 메모리 사용 증가 가능

## 4. this & 객체 생성

### ⭐ this

this는 함수가 호출되는 방식에 따라 결정되는 참조값입니다.

- 전역: window
- 객체 메서드: 해당 객체
- 생성자 함수: 새로 생성된 인스턴스
- 화살표 함수: 상위 스코프의 this

### ⭐ 생성자(Constructor)

객체를 생성하기 위한 함수로, new 키워드를 통해 호출되며
동일한 구조의 객체를 반복 생성할 때 사용합니다.

### ⭐ 프로토타입 체인(Prototype Chain)

객체에서 프로퍼티를 찾을 때
자기 자신 → 프로토타입 → 상위 프로토타입 순으로 탐색합니다.

- 이 구조가 상속을 구현하는 방식

→ 프로토타입 기반 언어의 핵심 개념

### ⭐ 함수 선언식 vs 화살표 함수

자바스크립트에서 함수는 선언 방식에 따라
호이스팅, this 바인딩, 사용 목적에 차이가 있습니다.

```js
function foo() {}
const bar = () => {};
```

#### 1. 정의 방식과 호이스팅 차이

**함수 선언식 (Function Declaration)**

```js
foo(); // 가능
function foo() {}
```

- 실행 컨텍스트 생성 시 함수 전체가 호이스팅
- 선언 이전에도 호출 가능

**화살표 함수 (Arrow Function)**

```js
bar(); // ReferenceError
const bar = () => {};
```

- 변수에 함수 값을 할당하는 함수 표현식
- 변수만 호이스팅되고, 함수는 런타입에 할당됨
- TDZ로 인해 선언 전 호출 불가

#### 2. this 바인딩 차이

**함수 선언식**

- 호출 방식에 따라 this가 결정됨 (동적 this)

**화살표 함수**

- 자신만의 this를 가지지 않음
- 선언 시점의 상위 스코프 this를 그대로 사용

→ 콜백, React 컴포넌트에서 this 문제를 피하기 위해 자주 사용

#### 3. 사용 목적 정리

- 함수 선언식
  - 공통 유틸 함수
  - 생성자 함수
  - 명확한 역할의 일반 함수
- 화살표 함수
  - 콜백 함수
  - React 컴포넌트
  - this를 고정해야 하는 경우

## 5. 타입 & 값 저장 방식

### ⭐ 원시 타입 vs 참조 타입 (값 저장 방식)

- 원시 타입: 값 자체 저장(불변), 복사 시 값 복사
- 참조 타입: 힙에 저장, 변수는 참조를 가짐

→ 얕은/깊은 복사, 불변성 논의의 기반

### ⭐ 불변성과 상태 변경

- 원시 값: 변경이 아닌 새 값 생성
- 객체: 같은 주소의 내부 값 변경

→ React에서 state 직접 수정 시 변경 감지 문제 발생

### ⭐ 깊은 복사 vs 얕은 복사

- 얕은 복사: 참조값 복사
- 깊은 복사: 실제 값 복사

### ⭐ 깊은 복사 방법과 한계

- JSON 방식: 간단하지만 Date, 함수, undefined, 순환 참조 불가
- structuredClone: 비교적 안전(환경 확인 필요)
- 라이브러리: lodash cloneDeep, immer

→ 데이터 형태에 따라 선택

## 6. 비동기 처리 & 이벤트 루프

### ⭐ 동기와 비동기

- 동기: 작업 순서 보장, 블로킹 발생 가능
- 비동기: 병렬 처리, UI 반응성 향상

### ⭐ 비동기 함수란

작업이 완료될 때까지 기다리지 않고
다음 코드를 실행할 수 있는 함수입니다.
네트워크 요청, 타이머 처리에 사용됩니다.

### ⭐ 콜백 함수

다른 함수의 인자로 전달되어 특정 시점에 실행되는 함수입니다.
비동기 처리에 자주 사용됩니다.

- 문제점: 콜백 지옥
- 해결: Promise, async/await

### ⭐ Promise

비동기 작업의 상태를 객체로 표현합니다.

- pending
- fulfilled
- rejected

.then(), .catch()로 처리

### ⭐ Promise vs Callback

- Callback
  - 중첩 증가 → 가독성 저하
  - 에러 처리 복잡
- Promise
  - 체이닝 가능
  - 에러 처리 일관적

### ⭐ Async/Await 설명

Promise 기반 비동기 처리를
동기 코드처럼 작성하는 문법입니다.

- async 함수는 항상 Promise 반환
- await은 resolve까지 대기

### ⭐ Promise와 Async/Await의 차이

- Promise: .then(), .catch()
- Async/Await: try-catch → 에러 처리 직관적

### ⭐ async/await 에러 처리는 왜 try-catch인가요?

에러가 Promise reject로 전달되기 때문에
동기 코드처럼 try-catch로 처리합니다.

### ⭐ try/catch가 비동기에서 안 먹는 경우

setTimeout 콜백 내부 에러는
외부 try/catch로 잡히지 않습니다.

- 다른 실행 컨텍스트에서 실행되기 때문

→ Promise/async-await로 에러 전달 필요

## 7. 이벤트 & 이벤트 최적화

### ⭐ 이벤트 루프 설명

자바스크립트는 기본적으로 싱글 스레드라서 한 번에 한 작업만 콜 스택(Call Stack) 에서 실행합니다.

그런데 네트워크 요청, 타이머, DOM 이벤트 같은 작업은 오래 걸릴 수 있기 때문에, 브라우저(또는 Node)는 이런 작업을 Web APIs(또는 백그라운드 영역) 로 보내 비동기로 처리하고, 완료된 작업을 큐(Queue) 에 쌓아두었다가 적절한 시점에 다시 콜 스택으로 올려 실행합니다.

이때 “언제 어떤 큐의 작업을 콜 스택으로 올릴지”를 관리하는 게 이벤트 루프입니다.

#### 구성 요소

1. Call Stack (콜 스택)

   - 지금 실행 중인 함수들이 쌓이는 실행 공간
   - 스택 구조(LIFO)라서 마지막에 들어온 함수가 먼저 끝남
   - 콜 스택이 바쁘면(작업이 길면) 화면/입력 반응이 늦어짐(“메인 스레드 블로킹”)

2. Web APIs (브라우저 제공 비동기 처리 영역)

   - setTimeout, fetch, DOM 이벤트 리스너, requestAnimationFrame 같은 작업을 처리
   - JS 엔진(V8 등) 바깥의 영역에서 비동기 작업이 수행됨
   - 작업이 완료되면 콜백을 “큐”로 이동시킴

3. Queue (대기열): 작업 완료 콜백들이 쌓이는 곳이며, 대표적으로 두 종류가 중요합니다.

   - Task Queue (Macrotask Queue)
     - setTimeout, setInterval, DOM 이벤트 콜백 등
   - Microtask Queue
     - Promise.then/catch/finally, queueMicrotask, MutationObserver
     - 현재 실행이 끝나자마자 바로 처리되는 우선순위가 높은 큐

#### 이벤트 루프 동작 순서 (핵심)

이벤트 루프는 기본적으로 다음 규칙을 반복합니다.

1. 콜 스택이 비면
2. 마이크로태스크 큐를 먼저 “완전히” 비울 때까지 실행
3. 그 다음 태스크 큐에서 하나 꺼내 실행
4. 다시 1~3 반복

- Microtask Queue는 “현재 작업이 끝난 직후” 최우선으로 처리
- Task Queue는 그 다음 순서

그래서 Promise.then()이 setTimeout(0)보다 먼저 실행됩니다.

### ⭐ 태스크 큐 / 마이크로태스크 큐

- 태스크 큐: setTimeout, setInterval, 이벤트
- 마이크로태스크 큐: Promise.then, async/await

### ⭐ 마이크로태스크가 먼저 실행되는 이유

현재 작업이 끝난 직후 바로 처리되기 때문

→ Promise가 setTimeout(0)보다 먼저 실행

### ⭐ 이벤트 버블링과 캡처링

- 캡처링: 상위 → 하위
- 버블링: 하위 → 상위 (기본)

### ⭐ target vs currentTarget

- target: 실제 이벤트 발생 요소
- currentTarget: 핸들러가 등록된 요소

→ 이벤트 위임 핵심 개념

### ⭐ preventDefault vs stopPropagation

- preventDefault(): 기본 동작 방지
- stopPropagation(): 이벤트 전파 중단

### ⭐ 이벤트 위임과 동작 방식

부모 요소에 이벤트를 등록해
자식 요소의 이벤트를 처리

- 동적 요소 대응
- 성능 및 유지보수 유리

### ⭐ 디바운스 vs 쓰로틀

- debounce: 마지막 호출만 실행
- throttle: 일정 시간 간격 실행

→ 이벤트 최적화 핵심

## 8. 자료구조 & 배열 메서드

### ⭐ map / forEach / reduce

- forEach: 단순 반복
- map: 새로운 배열 반환
- reduce: 누적 계산

### ⭐ Map / Set이 Object / Array보다 유리한 경우

- Map: 키 제약 없음, 탐색 유리
- Set: 중복 제거 최적

## 9. 모듈 & 언어 기능

### ⭐ ES6 주요 기능

- let, const
- arrow function
- Promise
- async/await
- destructuring
- spread operator
- class, module

### ⭐ 모듈 시스템

- CommonJS: require, module.exports
- ES Module: import/export (트리 쉐이킹 유리)

## 10. 메모리 & 실행 구조

### ⭐ JS 메모리 관리

- 힙: 객체, 참조 타입
- 스택: 실행 컨텍스트, 원시 타입
- 가비지 컬렉션 자동 관리

### ⭐ 콜 스택과 힙

- 콜 스택: 함수 실행 순서 관리
- 힙: 객체 저장 공간

## 11. 기타 핵심 개념

### ⭐ 클래스

객체 생성을 위한 템플릿
prototype 기반 문법을 클래스 문법으로 표현

### ⭐ 제너레이터

yield를 사용해 실행을 중단·재개
이터러블 객체 생성

### ⭐ 엄격 모드(strict mode)

- 문법 오류를 에러로 처리
- 암묵적 전역 변수 방지

### ⭐ undefined / null / undeclared

- undefined: 값 미할당
- null: 의도적 빈 값
- undeclared: 선언되지 않음

### ⭐ == 와 === 차이

- ==: 타입 변환 후 비교
- ===: 타입 + 값 비교 (권장)

## 12. 원시 타입 메서드 & 자동 박싱

### ⭐ 원시 타입 메서드와 자동 박싱 (Auto Boxing)

자바스크립트의 원시 타입(string, number, boolean)은 객체가 아니지만,
메서드나 프로퍼티에 접근하는 순간 JS 엔진이 내부적으로 임시 객체로 변환해 처리합니다.

이 과정을 자동 박싱(auto-boxing) 이라고 합니다.

```js
"hello".length; // 가능
"hello".toUpperCase(); // 가능
```

동작 과정

1. 원시 타입 값 생성
2. 해당 타입의 객체(String, Number, Boolean)로 일시적 변환
3. 메서드/프로퍼티 접근
4. 사용 후 즉시 객체 제거

⚠️ 임시 객체이기 때문에 값을 저장할 수는 없습니다.

```js
let a = "hi";
a.custom = 1;
console.log(a.custom); // undefined
```

→ 원시 타입은 여전히 불변 값이며,

→ 메서드 호출만 가능하도록 일시적으로 객체처럼 동작합니다.
