# JavaScript 면접 질문 리스트

## 1. 자바스크립트 개요

<details>
<summary>⭐️ 자바스크립트는 어떤 언어인가요?</summary>

자바스크립트는 웹 브라우저에서 동작하는 인터프리터 기반의 프로그래밍 언어로, 웹 페이지에 동적인 동작과 사용자 상호작용을 구현하기 위해 사용됩니다. 현재는 브라우저뿐만 아니라 서버(Node.js)와 다양한 환경에서도 사용되고 있습니다.

</details>

<details>
<summary>⭐️ 자바스크립트가 동적 타입 언어라는 말은 무슨 뜻인가요?</summary>

자바스크립트는 변수에 타입을 미리 선언하지 않고, 런타임에 값이 할당될 때 타입이 결정되는 언어입니다. 이로 인해 유연한 코드 작성이 가능하지만, 타입 관련 오류가 런타임에 발생할 수 있다는 단점도 있습니다.

</details>

<details>
<summary>⭐️ 자바스크립트가 싱글 스레드인데 비동기가 가능한 이유는 무엇인가요?</summary>

자바스크립트는 싱글 스레드로 동작하지만, 이벤트 루프와 브라우저 또는 런타임 환경이 제공하는 Web API를 통해 비동기 처리가 가능합니다. 시간이 오래 걸리는 작업은 별도의 영역에서 처리하고, 완료된 작업만 다시 메인 스레드로 전달하는 방식으로 동작합니다.

</details>

## 2. 실행 컨텍스트 & 변수 동작 원리

<details>
<summary>⭐️ 실행 컨텍스트(Execution Context)란 무엇인가요?</summary>

실행 컨텍스트는 자바스크립트 코드가 실행되기 위한 환경 정보를 담고 있는 객체입니다. 변수, 함수 선언, 스코프 체인, this 값 등이 실행 컨텍스트에 저장됩니다.

</details>

<details>
<summary>실행 컨텍스트가 생성되는 시점에 어떤 일이 일어나나요?</summary>

실행 컨텍스트가 생성되면 변수와 함수 선언이 메모리에 등록되고, 스코프 체인이 결정되며, this 값이 바인딩됩니다. 이 과정에서 호이스팅이 발생합니다.

</details>

<details>
<summary>⭐️ 호이스팅(Hoisting)이란 무엇인가요?</summary>

호이스팅은 변수와 함수 선언이 코드 실행 전에 실행 컨텍스트 상단으로 끌어올려진 것처럼 동작하는 현상을 말합니다. 실제로 코드가 이동하는 것은 아니며, 메모리에 미리 등록되는 개념입니다.

</details>

<details>
<summary>⭐️ var, let, const의 호이스팅 차이를 설명해보세요.</summary>

var는 선언과 초기화가 함께 이루어져 undefined로 접근이 가능하지만, let과 const는 선언만 호이스팅되고 초기화는 되지 않아 TDZ에 의해 접근 시 에러가 발생합니다.

</details>

<details>
<summary>⭐️ TDZ(Temporal Dead Zone)란 무엇인가요?</summary>

TDZ는 let과 const로 선언된 변수가 선언 시점부터 초기화되기 전까지 접근할 수 없는 구간을 의미합니다. 이 구간에서 변수를 참조하면 ReferenceError가 발생합니다.

TDZ는 변수를 선언 전에 사용하는 실수를 방지하고, 코드의 예측 가능성과 안정성을 높이기 위해 도입되었습니다.
</details>

<details>
<summary>⭐️ 선언, 초기화, 할당의 차이를 설명해보세요.</summary>

선언은 변수를 메모리에 등록하는 단계이고, 초기화는 변수에 기본 값을 할당하는 단계이며, 할당은 실제 값을 변수에 대입하는 단계입니다.

</details>

<details>
<summary>var, let, const의 스코프 차이를 설명해보세요.</summary>

var는 함수 스코프를 가지며, let과 const는 블록 스코프를 가집니다. 이로 인해 let과 const가 더 예측 가능하고 안전한 변수 선언 방식으로 권장됩니다.

</details>

<details>
<summary>⭐️ const에서 객체 내부 변경이 가능한 이유는 무엇인가요?</summary>

const는 변수 자체의 재할당을 막을 뿐, 객체가 참조하는 메모리 주소는 고정되어 있기 때문에 객체 내부의 속성 변경은 가능합니다.

</details>

## 3. 스코프 & 클로저

<details>
<summary>⭐️ 스코프(Scope)란 무엇인가요?</summary>

스코프는 변수에 접근할 수 있는 유효 범위를 의미하며, 자바스크립트에서는 전역 스코프와 지역 스코프가 존재합니다.

전역 스코프를 남용하면 변수 충돌 가능성이 높아지고, 코드 의존성이 증가하여 유지보수가 어려워집니다.

</details>

<details>
<summary>⭐️ 렉시컬 스코프(Lexical Scope)란 무엇인가요?</summary>

렉시컬 스코프는 함수가 선언된 위치에 따라 상위 스코프가 결정되는 방식입니다. 함수 호출 위치와는 관계없이 정의된 위치 기준으로 스코프가 결정됩니다.

</details>

<details>
<summary>스코프 체인(Scope Chain)이란 무엇인가요?</summary>

스코프 체인은 현재 스코프에서 변수를 찾지 못했을 때 상위 스코프로 순차적으로 탐색하는 구조를 의미합니다.

</details>

<details>
<summary>⭐️ 클로저(Closure)란 무엇인가요?</summary>

클로저는 함수가 자신이 선언된 환경의 변수에 접근할 수 있는 특성을 말합니다. 함수가 종료된 이후에도 외부 스코프의 변수를 기억하고 사용할 수 있습니다.

자바스크립트는 렉시컬 스코프를 기반으로 하기 때문에, 함수가 생성될 당시의 스코프 정보를 유지하고 있어 클로저가 동작할 수 있습니다.

</details>

<details>
<summary>⭐️ 클로저는 어떤 상황에서 유용하고, 단점은 무엇인가요?</summary>

클로저는 상태를 은닉하거나 데이터 보호가 필요할 때 유용하지만, 불필요하게 사용하면 메모리 누수의 원인이 될 수 있습니다.

</details>

## 4. this & 객체 생성

<details>
<summary>⭐️ this는 무엇이며 언제 결정되나요?</summary>

this는 함수가 호출되는 방식에 따라 동적으로 결정되는 객체 참조입니다. 함수 정의 시점이 아니라 호출 시점에 결정됩니다.

</details>

<details>
<summary>⭐️ 일반 함수 / 메서드 / 생성자 호출에서 this는 각각 무엇을 가리키나요?</summary>

일반 함수에서는 전역 객체를, 메서드 호출에서는 해당 객체를, 생성자 함수에서는 새로 생성된 인스턴스를 가리킵니다.

</details>

<details>
<summary>⭐️ 화살표 함수에서 this가 다른 이유는 무엇인가요?</summary>

화살표 함수는 자신만의 this를 가지지 않고, 선언 당시의 상위 스코프의 this를 그대로 사용하기 때문입니다.

</details>

<details>
<summary>생성자 함수(Constructor)란 무엇인가요?</summary>

생성자 함수는 new 키워드를 통해 객체를 생성하기 위한 함수로, 객체 초기화 로직을 담당합니다.

</details>

<details>
<summary>new 키워드로 호출될 때 내부적으로 어떤 과정이 일어나나요?</summary>

빈 객체가 생성되고, this가 해당 객체를 가리키며, 프로토타입이 연결된 후 생성자 함수가 실행되고 객체가 반환됩니다.

</details>

<details>
<summary>⭐️ 프로토타입 체인(Prototype Chain)이란 무엇인가요?</summary>

프로토타입 체인은 객체가 자신의 속성을 찾지 못했을 때 상위 프로토타입으로 탐색을 이어가는 구조를 말합니다.

</details>

<details>
<summary>자바스크립트에서 상속은 어떤 방식으로 구현되나요?</summary>

자바스크립트는 프로토타입 기반 상속을 사용하며, 객체 간 프로토타입 연결을 통해 상속을 구현합니다.

</details>

<details>
<summary>화살표 함수는 왜 생성자(new)로 사용할 수 없나요?</summary>

화살표 함수는 this와 prototype을 가지지 않기 때문에 생성자 함수로 사용할 수 없습니다.

</details>

## 5. 타입 & 값 저장 방식

<details>
<summary>⭐️ 원시 타입(Primitive)과 참조 타입(Reference)의 차이를 설명해보세요.</summary>

원시 타입은 값 자체가 저장되고 복사되며, 참조 타입은 객체가 저장된 메모리 주소를 참조합니다.

원시 타입에는 number, string, boolean, null, undefined, symbol, bigint가 있고,

참조 타입에는 object가 있으며 배열, 함수, 객체 등이 여기에 포함됩니다.

</details>

<details>
<summary>원시 타입은 왜 불변(immutable)이라고 하나요?</summary>

원시 타입은 값을 변경할 수 없고, 새로운 값을 할당하면 기존 값이 변경되는 것이 아니라 새로운 값이 생성되기 때문입니다.

</details>

<details>
<summary>⭐️ 참조 타입은 값이 어디에 저장되며 변수는 무엇을 들고 있나요?</summary>

객체는 힙 메모리에 저장되고, 변수는 해당 객체의 메모리 주소를 참조합니다.

</details>

<details>
<summary>얕은 복사(Shallow Copy)와 깊은 복사(Deep Copy)의 차이는 무엇인가요?</summary>

얕은 복사는 참조를 복사하고, 깊은 복사는 실제 객체 구조를 완전히 복사합니다.

</details>

<details>
<summary>⭐️ 얕은 복사에서 문제가 생기는 이유는 무엇인가요?</summary>

여러 변수가 같은 객체를 참조하게 되어 한쪽 변경이 다른 쪽에 영향을 주기 때문입니다.

</details>

<details>
<summary>⭐️ React에서 불변성이 중요한 이유는 무엇인가요?</summary>

React는 상태 변경 여부를 참조 비교로 판단하기 때문에, 불변성을 지켜야 변경 감지가 정확하게 이루어집니다.

</details>

## 6. 비동기 처리 & 이벤트 루프

<details>
<summary>⭐️ 동기(Synchronous)와 비동기(Asynchronous)의 차이는 무엇인가요?</summary>

동기는 작업이 순차적으로 실행되고, 비동기는 이전 작업 완료 여부와 상관없이 다음 작업이 실행됩니다.

</details>

<details>
<summary>⭐️ Promise란 무엇인가요?</summary>

Promise는 비동기 작업의 성공 또는 실패 결과를 나타내는 객체입니다.

</details>

<details>
<summary>Promise와 콜백의 차이는 무엇인가요?</summary>

Promise는 체이닝이 가능해 가독성이 좋고 에러 처리가 명확하지만, 콜백은 중첩이 깊어질 수 있습니다.

</details>

<details>
<summary>⭐️ async/await의 동작 원리는 무엇인가요?</summary>

async/await는 Promise를 기반으로 하며, 비동기 코드를 동기 코드처럼 작성할 수 있게 해줍니다.

async 함수 내부의 반환값은 자동으로 Promise로 감싸지기 때문에 항상 Promise를 반환합니다.

</details>

<details>
<summary>setTimeout 내부 에러가 바깥 try/catch로 잡히지 않는 이유는 무엇인가요?</summary>

setTimeout은 비동기적으로 실행되어 실행 컨텍스트가 분리되기 때문에 외부 try/catch에서 에러를 잡을 수 없습니다.

</details>

<details>
<summary>⭐️ 이벤트 루프(Event Loop)란 무엇인가요?</summary>

자바스크립트는 싱글 스레드 기반 언어이기 때문에, 비동기적으로 동작하는 것처럼 보이도록 이벤트 루프를 사용합니다.

이벤트 루프는 Call Stack이 비어 있을 때 Microtask Queue와 Task Queue를 확인하여, 
대기 중인 작업을 순서에 맞게 Call Stack으로 다시 실행시키는 역할을 합니다.

</details>

<details>
<summary>⭐️ Call Stack / Task Queue / Microtask Queue의 역할은 무엇인가요?</summary>

Call Stack은 실행 중인 함수가 쌓이는 공간이고, Task Queue는 일반 비동기 작업이 대기하며, Microtask Queue는 Promise 같은 우선순위 높은 작업이 대기합니다.

</details>

<details>
<summary>⭐️ Promise.then이 setTimeout(0)보다 먼저 실행되는 이유는 무엇인가요?</summary>

Microtask Queue가 Task Queue보다 우선적으로 처리되기 때문입니다.

</details>

## 7. 이벤트 & 이벤트 최적화

<details>
<summary>⭐️ 이벤트 버블링과 캡처링의 차이는 무엇인가요?</summary>

캡처링은 상위 요소에서 하위 요소로 이벤트가 전달되고, 버블링은 하위에서 상위로 전달됩니다.

</details>

<details>
<summary>⭐️ 이벤트 위임이란 무엇인가요?</summary>

이벤트 위임은 상위 요소에 이벤트를 등록해 하위 요소의 이벤트를 처리하는 방식입니다.

이벤트가 버블링을 통해 상위 요소로 전달되기 때문에 이벤트 위임이 가능합니다.

</details>

<details>
<summary>target과 currentTarget의 차이는 무엇인가요?</summary>

target은 실제 이벤트가 발생한 요소이고, currentTarget은 이벤트 리스너가 등록된 요소입니다.

</details>

<details>
<summary>preventDefault와 stopPropagation의 차이는 무엇인가요?</summary>

preventDefault는 기본 동작을 막고, stopPropagation은 이벤트 전파를 막습니다.

</details>

<details>
<summary>⭐️ 디바운스와 쓰로틀의 차이는 무엇인가요?</summary>

디바운스는 이벤트가 멈춘 후 한 번만 실행되고, 쓰로틀은 일정 시간마다 실행됩니다.

</details>

## 8. 자료구조 & 배열 메서드

<details>
<summary>⭐️ map / filter / find의 차이는 무엇인가요?</summary>

map은 배열을 변환하고, filter는 조건에 맞는 요소를 반환하며, find는 조건에 맞는 첫 요소를 반환합니다.

</details>

<details>
<summary>⭐️ reduce는 언제 사용하나요?</summary>

reduce는 배열을 하나의 값으로 축약할 때 사용합니다.

</details>

<details>
<summary>Map이 Object보다 유리한 점은 무엇인가요?</summary>

Map은 키 타입에 제한이 없고, 순서를 보장하며 성능이 안정적입니다.

</details>

<details>
<summary>Set이 Array보다 유리한 점은 무엇인가요?</summary>

Set은 중복을 자동으로 제거할 수 있어 고유 값 관리에 유리합니다.

</details>

## 9. 기타

<details>
<summary>strict mode는 왜 사용하나요?</summary>

엄격한 문법을 적용해 잠재적인 오류를 사전에 방지하기 위해 사용합니다.

</details>

<details>
<summary>⭐️ == 와 ===의 차이는 무엇인가요?</summary>

==는 타입 변환 후 비교하고, ===은 타입과 값 모두를 비교합니다.

</details>

<details>
<summary>⭐️ undefined와 null의 차이는 무엇인가요?</summary>

undefined는 값이 할당되지 않은 상태이고, null은 의도적으로 값이 없음을 표현합니다.

</details>

<details>
<summary>⭐️ 자동 박싱(auto-boxing)이란 무엇인가요?</summary>

원시 타입이 객체처럼 메서드를 사용할 수 있도록 임시 객체로 변환되는 현상입니다.

</details>
