# Vue.js 면접 질문 리스트

## 1. React vs Vue 비교

<details>
<summary>React와 Vue의 가장 큰 차이는 어떻게 설명하시나요?</summary>

React는 JSX 중심의 라이브러리로 구조를 개발자가 자유롭게 설계해야 해 유연하지만 일관성이 떨어질 수 있습니다.

반면 Vue는 템플릿·디렉티브·반응성 같은 핵심 개념이 프레임워크 차원에서 통합되어 있어 진입 장벽이 낮고 팀 간 스타일도 쉽게 통일된다는 점이 가장 큰 차이라고 생각합니다.

</details>

<details>
<summary>프로젝트를 시작할 때, React 대신 Vue를 선택할 상황은 어떤 경우라고 생각하나요?</summary>

빠르게 UI를 구축해야 하거나 퍼블리셔·디자이너와 협업 비중이 높은 프로젝트는 Vue가 직관적이라 더 효율적입니다.

또한 데이터 흐름이 단순한 관리형 UI나 MVP 개발처럼 속도가 중요한 경우 Vue가 개발 난이도와 유지보수 모두에서 장점이 있습니다.

</details>

<details>
<summary>Vue의 템플릿 기반 방식과 React의 JSX 기반 방식의 장단점을 비교해 주세요.</summary>

- Vue 템플릿은 HTML 구조가 그대로 유지되어 가독성이 좋고 UI 중심 작업에서 생산성이 높습니다.
- 반면 JSX는 자바스크립트 로직을 유연하게 조합할 수 있어 복잡한 UI나 조건이 많은 화면 개발에 더 강합니다.

</details>

<details>
<summary>상태 관리 관점에서 Vue의 reactivity 시스템과 React의 상태 관리 방식의 차이를 어떻게 이해하고 있나요?</summary>

Vue는 Proxy 기반으로 데이터 변화를 자동 추적해 UI를 업데이트하지만, React는 setState 호출을 기준으로 렌더링이 이루어지고 불변성을 명확히 유지해야 합니다. Vue는 직관적이고 React는 예측 가능성과 명시성이 강합니다.

</details>

## 2. Vue 핵심 개념(Options API / Composition API)

<details>
<summary>사용하신 Vue 버전과 API 스타일(Options API / Composition API)을 설명해 주세요.</summary>

저는 Vue 3 + Composition API 기반으로 개발했습니다.

Composition API는 React Hook과 유사해 로직 단위 분리가 용이하고, 재사용 가능한 composable 형태로 추출해 구조적으로 깔끔하게 유지할 수 있었습니다.

</details>

<details>
<summary>Composition API와 React Hooks의 차이점은?</summary>

Composition API는 반응성이 언어 차원에 내장되어 있어 ref/reactive만으로 자연스럽게 반응형 상태를 만들 수 있습니다.
반면 React Hooks는 렌더링 사이클에 강하게 결합돼 있어 규칙이 더 엄격하지만, 상태 흐름이 명확히 드러난다는 장점도 있습니다.

</details>

<details>
<summary>setup() 함수 내부에서 할 수 있는 일과, Options API 방식과의 차이를 설명해 주세요.</summary>

setup에서는 상태 정의, computed, watch, 라이프사이클, composable 호출 등 거의 모든 로직을 기능 단위로 묶어 구성할 수 있습니다.

Options API는 옵션별로 코드가 흩어지지만, Composition API는 같은 관심사를 한곳에 모아 복잡한 로직에서도 가독성이 좋습니다.

</details>

<details>
<summary>Vue의 computed와 React의 useMemo를 비교해서 설명해 주세요.</summary>

- computed는 의존성을 자동으로 추적해 가장 안정적인 캐싱을 제공하며, 개발자가 관리할 부분이 거의 없습니다.
- useMemo는 의존 배열을 직접 관리해야 하고 실수할 여지가 있지만, 로직 조합 면에서는 React가 조금 더 유연합니다.
</details>

## 3. Vue의 반응성(Reactivity) 관련

<details>
<summary>Vue의 반응성 시스템이 어떻게 동작하는지 아는 만큼 설명해 주세요.</summary>

Vue 3는 Proxy 기반으로 객체 속성을 읽을 때 의존성을 자동 기록하고, 값이 변경되면 연결된 UI 업데이트가 자동으로 발생합니다. 이 때문에 개발자가 불변성을 신경 쓰지 않아도 자연스럽게 렌더링이 이루어집니다.

</details>

<details>
<summary>ref와 reactive의 차이를 설명해 주세요.</summary>

- ref는 숫자·문자열 등 원시값 반응성에 적합하고 .value를 사용해야 합니다.
- reactive는 객체·배열을 Proxy로 감싸 전체 구조를 반응형으로 만들어줍니다.

</details>

<details>
<summary>Vue 2에서 배열/객체 변경을 감지하지 못하는 케이스가 있었는데, 이 문제를 어떻게 해결했는지 아시나요? (또는 3에서 어떻게 개선됐는지)</summary>

Vue 2는 defineProperty 기반이라 배열 인덱스 변경이나 새로운 속성 추가를 감지하지 못했지만, Vue 3에서는 Proxy로 전환되면서 이런 문제들이 모두 해결되었습니다.

</details>

## 4. 템플릿 / 디렉티브 / v-model

<details>
<summary>Vue 템플릿에서 자주 사용하는 디렉티브(v-if, v-for, v-bind, v-on)의 역할과 차이를 설명해 주세요.</summary>

- v-if: DOM 자체를 생성·제거
- v-show: CSS로 보이기만 토글
- v-for: 반복 렌더링
- v-bind: 속성 바인딩(:)
- v-on: 이벤트 바인딩(@)
</details>

<details>
<summary>v-if와 v-show의 차이점은 무엇인가요?</summary>

- v-if는 실제 DOM을 제거해 렌더링 비용이 높지만 초기 렌더링 최적화에 유리합니다.
- 반면 v-show는 렌더링 비용이 낮아 토글이 잦은 UI에 적합합니다.

</details>

<details>
<summary>v-for 사용 시 key를 왜 꼭 써야 하는지, React의 key와 비교해서 설명해 주세요.</summary>

key는 Virtual DOM diffing 최적화의 핵심으로, Vue·React 모두 요소의 정체성을 유지해 불필요한 리렌더링을 방지합니다.
특히 리스트에서 상태가 꼬이지 않도록 유지하려면 key가 필수입니다.

</details>

<details>
<summary>v-model이 내부적으로 어떤 일을 하는지 설명해 보실 수 있나요? (양방향 바인딩, :value + @input 조합 등)
</summary>

v-model은 :value와 @input의 조합을 축약한 문법이며, 부모는 value를 내려주고 자식은 input 이벤트를 emit하여 양방향 바인딩을 구현합니다.

즉, React의 단방향 흐름 + onChange 패턴을 자동화한 추상화입니다.

</details>

## 5. 컴포넌트 통신 / 상태 관리

<details>
<summary>부모 ↔ 자식 간 데이터 전달은 어떤 식으로 이루어지나요? (props, emit)</summary>

부모는 props로 데이터를 전달하고, 자식은 emit으로 이벤트를 올려 부모가 상태를 갱신합니다.

Vue는 이 흐름이 프레임워크 차원에서 명확하게 구조화되어 있어 협업 시 실수할 여지가 적었습니다.

</details>

<details>
<summary>형제 컴포넌트 간 데이터 전달이 필요할 때 어떻게 설계하셨나요?</summary>

형제 컴포넌트는 공통 부모를 통해 전달하거나 Pinia 같은 스토어를 통해 상태를 공유했습니다.
특히 해커톤처럼 빠르게 개발할 때는 composable + Pinia 조합이 가장 효율적이었습니다.

</details>

<details>
<summary>Vuex나 Pinia 같은 상태 관리 라이브러리를 사용해 보셨나요?</summary>

Pinia는 옵셔널 기반 구조와 타입 지원이 좋아 Redux보다 훨씬 가볍고 직관적이었습니다.
Zustand와 비교하면 사용성은 비슷하지만, Vue 내부 반응성과 연계된 부분은 Pinia가 더 자연스러웠습니다.

</details>

## 6. Vue + TypeScript + Tailwind 경험

<details>
<summary>Vue + TypeScript + Tailwind를 사용하셨다고 했는데, TypeScript를 Vue에서 사용할 때 어려웠던 점이 있었나요?</summary>

ref/reactive 타입 추론이 직관적이지 않을 때가 있었고, props/emit 타입을 명시적으로 선언해야 하는 점이 React보다 장황했습니다.
하지만 Composition API와 조합하면 구조 자체는 충분히 깔끔하게 유지할 수 있었습니다.

</details>

<details>
<summary>React + Tailwind와 Vue + Tailwind를 모두 써보셨다면, 개발 경험 측면에서 차이점이 어떤 게 있었나요?
</summary>

React는 JSX라 JavaScript 기반 스타일 조합이 자연스럽고 유연합니다.
Vue는 템플릿 기반이라 클래스를 선언적으로 관리하는 데 강점이 있어 단순 UI는 더 빠르게 개발할 수 있었습니다.

</details>

## 7. 실제 프로젝트 경험 기반 꼬리 질문

<details>
<summary>해커톤에서 Vue로 구현하면서, 가장 구조적으로 고민했던 부분이나 이건 React였어도 비슷했겠다 / 달랐겠다 싶은 지점이 있었나요?</summary>

Composition API로 로직을 composable로 분리하는 구조가 가장 큰 고민이었고, 실제로 React custom hook과 유사한 패턴을 적용해 유지보수성을 확보했습니다.
UI가 반복되는 부분이 많아 Vue 템플릿 방식이 개발 속도 측면에서 유리하다고 느꼈습니다.

</details>

<details>
<summary>Vue 프로젝트에서도 Next.js처럼 라우팅/상태/데이터 패칭 구조를 어떻게 잡으셨나요?
</summary>

Vue Router로 페이지 구조를 만들고, Pinia로 전역 상태를 관리했습니다.
데이터 패칭은 axios + composable 조합으로 구조화해 React의 custom hook 패턴처럼 모듈화했고, 재사용성과 유지보수성이 매우 좋았습니다.

</details>
