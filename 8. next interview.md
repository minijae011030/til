# Next.js 면접 질문 리스트

## 1. SSR, CSR, SSG / App Router 중심 질문

<details>
<summary>CSR 기반 React 프로젝트를 SSR 기반 Next.js로 마이그레이션한 이유는 무엇인가요?</summary>

- CSR 기반 React 앱은 초기 렌더링 시 모든 HTML을 클라이언트에서 생성하기 때문에 첫 화면이 뜨기까지 시간이 길어지고, 검색 엔진이 HTML을 제대로 읽지 못해 SEO에 취약하다는 한계가 있었습니다.
- 반면 Next.js는 서버에서 HTML을 미리 렌더링해 전달하기 때문에 초기 체감 속도가 빨라지고 검색 엔진 최적화가 자연스럽게 해결됩니다. 블로그 프로젝트에서는 SEO가 특히 중요했기 때문에 CSR 구조의 한계를 해결하고자 SSR 기반 Next.js로 마이그레이션했습니다.

</details>

<details>
<summary>Next.js App Router에서 SSR과 CSR의 차이를 설명해 주세요.</summary>

SSR은 서버에서 HTML을 만들어 클라이언트로 전달하는 방식이고, CSR은 클라이언트에서 JavaScript로 HTML을 그리는 방식입니다.

- App Router에서는 기본이 서버 렌더링이기 때문에 초기 렌더링 속도와 SEO 측면에서 유리합니다.
- 반면 상호작용이 많은 영역이나 브라우저 API가 필요한 부분은 클라이언트 컴포넌트로 동작하며 CSR 방식으로 실행됩니다.

즉 App Router는 SSR과 CSR을 페이지 단위가 아니라 컴포넌트 단위로 유연하게 섞어 사용할 수 있는 구조입니다.

</details>

<details>
<summary>페이지에서 어떤 부분을 SSR로 하고, 어떤 부분을 CSR로 처리할지 어떻게 결정하나요?</summary>

- 서버에서 미리 계산할 수 있는 정적인 데이터나 SEO가 필요한 영역은 SSR이 적합하고,
- 사용자 입력이나 브라우저 상태처럼 클라이언트 환경에 의존하는 부분은 CSR로 처리합니다.

저는 서버에서 HTML을 미리 준비하는 것이 유리한 영역을 SSR로 두고, 상호작용 중심의 UI는 클라이언트 컴포넌트로 처리하는 형태로 나누었습니다.

</details>

<details>
<summary>서버 컴포넌트와 클라이언트 컴포넌트의 차이를 설명해주세요.</summary>

- 서버 컴포넌트는 서버에서 렌더링되며 JavaScript 번들 크기를 늘리지 않는 장점이 있습니다. 브라우저에 노출되면 안 되는 로직이나 데이터 패칭을 안전하게 처리할 수 있고 성능적으로도 비용이 적습니다.
- 반면 클라이언트 컴포넌트는 상태 관리나 이벤트 처리처럼 브라우저에서 동작해야 하는 기능을 담습니다. 서버-클라이언트 분리를 명확하게 하면 렌더링 성능과 보안성이 모두 좋아집니다.

</details>

<details>
<summary>서버 컴포넌트를 기본으로 설계했을 때 어떤 장점이 있었나요?</summary>

서버 컴포넌트를 기본으로 설계하면 불필요한 클라이언트 번들이 줄어들고, 서버에서 데이터를 가져와 바로 렌더링할 수 있어 데이터 초기화 과정이 단순해집니다. 또한 API Key나 인증 관련 로직이 브라우저에 노출되지 않아 보안적으로도 안정적입니다. 실제 프로젝트에서도 클라이언트 컴포넌트를 최소화하면서 초기 렌더링 속도와 성능이 개선되는 효과를 체감했습니다

</details>

## 2. SEO 최적화 관련 질문

<details>
<summary>Next.js에서 SEO를 어떻게 개선했나요? CSR일 때 어떤 문제가 있었나요?</summary>

- CSR 기반 앱은 HTML이 비어 있는 상태로 응답되기 때문에 검색 엔진이 콘텐츠를 제대로 인식하기 어렵습니다.
- 반면 Next.js는 렌더링이 서버에서 이루어지기 때문에 검색 엔진이 완성된 HTML을 읽을 수 있어 SEO가 자연스럽게 해결됩니다.

저는 App Router의 metadata API를 활용해 제목, 설명, OG 태그를 동적으로 생성했고, SSR 덕분에 검색 결과에 메타데이터가 즉시 반영되었습니다.

</details>

<details>
<summary>App Router에서 metadata API와 기존 next/head의 차이는 무엇인가요?</summary>

App Router의 metadata API는 라우트 세그먼트 단위로 타입 세이프하게 메타데이터를 정의할 수 있고, 서버 컴포넌트 단계에서 함께 처리되기 때문에 SEO를 안정적으로 적용할 수 있습니다.

기존 next/head 방식은 컴포넌트 단위로 흩어져 관리되고, 중복 정의나 우선순위 관리가 어려워 대규모 라우트 구조에서 유지보수가 힘들다는 한계가 있습니다.

</details>

<details>
<summary>동적 메타데이터(dynamic metadata)는 어떤 상황에서 필요했나요?</summary>

블로그처럼 글마다 제목과 설명이 달라야 하는 페이지에서는 정적인 메타데이터로는 부족합니다. 저는 서버 컴포넌트에서 글의 상세 데이터를 먼저 불러온 뒤, 그 값을 기반으로 metadata를 생성해 SEO를 개선했습니다. 이렇게 하면 각 글의 제목이 검색 엔진에 정확히 반영됩니다.

</details>

## 3. 인증(Authentication) 관련 질문 — JWT + HttpOnly 쿠키

<details>
<summary>HttpOnly 쿠키 기반 인증을 선택한 이유는 무엇인가요?</summary>

일반적으로 accessToken을 로컬스토리지에 저장하면 XSS 공격에 노출될 위험이 있습니다. HttpOnly 쿠키는 자바스크립트로 접근할 수 없기 때문에 XSS에 안전하고, 브라우저가 자동으로 쿠키를 첨부해주기 때문에 인증 흐름도 단순해집니다. 보안성과 편의성 면에서 가장 적절한 선택이라고 판단했습니다.

</details>

<details>
<summary>HttpOnly 쿠키 인증을 Next.js App Router에서 어떻게 구현했나요?</summary>

인증이 필요한 라우트의 서버 컴포넌트에서 cookies() API로 토큰을 가져와 검증하는 방식으로 구현했습니다. 쿠키가 없거나 만료된 경우 서버에서 바로 redirect를 수행하고, 정상적인 경우에만 페이지가 렌더링되도록 구성했습니다. 이렇게 인증을 서버에서 처리하면 클라이언트에서 발생할 수 있는 상태 불일치 문제를 방지할 수 있습니다.

</details>

<details>
<summary>클라이언트에서 accessToken을 상태로 들고 있지 않고 서버가 검증하게 만든 이유는 무엇인가요?</summary>

클라이언트에서 토큰을 상태로 관리하면 새로고침하거나 다른 탭을 열었을 때 인증 흐름이 끊길 수 있습니다. 서버에서 직접 쿠키를 읽고 검증하면 클라이언트 상태를 유지할 필요가 없고, 인증 여부가 항상 서버 기준으로 일관되게 유지됩니다. 보안과 안정성을 동시에 확보할 수 있는 구조입니다.

</details>

<details>
<summary>새로고침 시 인증 상태가 초기화되던 문제를 어떻게 해결했나요?</summary>

CSR 방식에서는 클라이언트 상태가 초기화되기 때문에 로그인 여부를 다시 확인해야 했습니다. 이를 해결하기 위해 서버 컴포넌트 단계에서 HttpOnly 쿠키를 검사하도록 변경하고, 초기 렌더링 전에 인증 상태를 결정하도록 흐름을 바꾸었습니다. 이렇게 하면 새로고침하더라도 인증이 안정적으로 유지됩니다.

</details>

## 4. React Query + Next.js 조합 질문

<details>
<summary>React Query를 Next.js와 함께 사용할 때 주의할 점이 있나요?</summary>

React Query는 클라이언트에서 동작하기 때문에 서버 컴포넌트에서 직접 사용할 수 없습니다. 따라서 서버에서 필요한 데이터는 서버 컴포넌트에서 fetch로 가져오고, 사용자 입력처럼 클라이언트 중심의 데이터는 React Query로 관리하는 방식으로 역할을 분리해야 합니다. 두 시스템이 중복되지 않도록 설계하는 것이 중요합니다.

</details>

<details>
<summary>React Query로 서버 요청을 45% 줄였다고 했는데, 어떤 구조적 문제를 해결한 건가요?</summary>

CSR 기반 프로젝트에서는 동일한 데이터를 여러 컴포넌트에서 중복 요청하는 문제가 있었습니다. React Query의 캐싱을 적용한 뒤에는 한 번 가져온 데이터가 재사용되었고, 일정 시간 동안은 refetch 없이 캐시 데이터를 활용했기 때문에 서버 요청 횟수가 크게 줄었습니다. 특히 유저 정보나 반복적으로 호출되는 API에서 큰 효과를 봤습니다.

</details>
<details>
<summary>React Query의 캐싱과 Next.js의 서버 컴포넌트 FETCH 캐싱과 충돌하지 않나요?</summary>

두 캐싱은 서로 다른 계층에서 동작합니다. 서버 컴포넌트의 fetch 캐시는 서버 단에서 동작하는 반면 React Query 캐시는 클라이언트 상태에 집중합니다. 저는 서버에서 처리할 수 있는 데이터는 fetch로 가져오고, 사용자의 상호작용에 따라 변하는 데이터만 React Query로 다뤄 충돌 없이 분리했습니다.

</details>

<details>
<summary>Next.js 서버 컴포넌트에서 React Query를 사용할 수 없는데, 구조를 어떻게 나누었나요?</summary>

초기 로딩이 필요한 데이터나 SEO에 영향을 주는 데이터는 서버 컴포넌트에서 fetch로 가져오고, 검색·필터링처럼 클라이언트에서 상태가 계속 변하는 데이터는 React Query로 관리했습니다. 이 구조는 서버와 클라이언트 각각의 장점을 최대한 활용할 수 있는 방식입니다.

</details>

## 5. 데이터 패칭

<details>
<summary>App Router에서 fetch가 기본적으로 캐싱되는 방식은 어떻게 작동하나요?</summary>

App Router의 fetch는 기본적으로 요청 정보를 기반으로 자동 캐싱이 이루어지고, 동일한 요청은 서버에서 재사용됩니다. 또한 라우트 세그먼트별로 revalidate 시간을 지정해 캐시 갱신 타이밍을 제어할 수 있습니다.

</details>

<details>
<summary>fetch의 캐시 모드를 “force-cache · no-store · revalidate” 언제 사용하나요?</summary>

정적인 데이터는 force-cache로 캐시를 최대한 활용하고, 자주 변경되는 비정형 API는 no-store로 캐싱을 완전히 끕니다. 업데이트 주기가 명확한 데이터는 revalidate 시간을 설정해 주기적인 갱신을 적용합니다.

</details>

<details>
<summary>React Query vs Next 의 fetch 캐싱 중 어떤 걸 선택했나요?</summary>

서버에서 렌더링할 수 있는 영역은 Next.js fetch 캐싱을 사용했고, 사용자 입력에 따라 변하는 데이터는 React Query를 선택했습니다. 단일 방식으로 통일하기보다 두 방식의 장점을 조건에 맞게 섞는 것이 효율적이었습니다.

</details>

## 6. 라우팅 / 구조 설계 관련 질문

<details>
<summary>Next.js 라우팅과 TanStack Router의 가장 큰 차이점은 무엇인가요?</summary>

Next.js는 폴더 기반 파일 라우팅인 반면 TanStack Router는 코드 기반으로 타입 세이프한 라우팅이 가능합니다. 특히 쿼리 파라미터를 타입으로 검증할 수 있다는 점이 큰 차이입니다.

</details>

<details>
<summary>왜 백오피스 구조 검증에서 TanStack Router를 선택했나요?</summary>

백오피스는 필터와 쿼리 파라미터가 많은 화면이 많아서 문자열 중심의 searchParams만으로는 타입 안정성이 떨어졌습니다. TanStack Router에서는 search params를 타입으로 정의할 수 있어 변경 시 영향 범위를 명확히 알 수 있어 유지보수에 유리했습니다.

</details>

<details>
<summary>Next.js App Router의 route segment 구조의 장단점은?</summary>

폴더 구조만으로 라우트를 정의할 수 있어 직관적이고 유지하기 쉽지만, 세분화된 타입 검증이나 라우트 간 의존성을 코드로 표현하는 것은 제한적입니다. 반대로 단순하고 규칙 기반이라 팀 단위로 사용하기 좋은 방식입니다.

</details>

## 7. 서버 운영 및 배포

<details>
<summary>pnpm + PM2 + Nginx 조합을 선택한 이유는 무엇인가요?</summary>

pnpm은 디스크 사용량과 설치 속도가 뛰어나고, PM2는 Node 기반 서비스를 안정적으로 데몬 형태로 운영할 수 있습니다. Nginx는 HTTPS 적용과 리버스 프록시 구성에 필수적이며 Next.js 서버와 외부 요청 사이의 경량 레이어 역할로 적합합니다.

</details>

<details>
<summary>Next.js 프로젝트를 서버에서 직접 실행할 때 주의할 점은 무엇인가요?</summary>

빌드 결과가 Node 기반 서버로 실행된다는 점을 고려해 서버 메모리 사용량을 체크해야 하고, 정적인 자산(public 폴더 등)이 올바르게 매핑되도록 Nginx 설정을 신경 써야 합니다. 또한 프로세스 재시작 시 다운타임이 발생하지 않도록 PM2의 클러스터 모드를 활용하는 것도 중요했습니다.

</details>

<details>
<summary>프록시(Nginx) 구조를 어떻게 구성했나요?</summary>

Nginx에서 443 포트를 받아 HTTPS 인증을 처리하고, 내부 포트로 Next.js 서버(예: 3000)를 라우팅하는 구조로 구성했습니다. 또한 정적 파일에 대한 캐싱 정책을 별도로 설정해 응답 속도를 최적화했습니다.

</details>

<details>
<summary>HTTPS 적용 과정에서 어떤 문제를 해결했나요?</summary>

초기에는 인증서 경로와 권한 문제로 Nginx가 인증서를 읽지 못해 서버가 정상적으로 실행되지 않았습니다. 인증서 파일 권한을 조정하고 server block 설정에서 인증서와 private key 경로를 올바르게 지정해 문제를 해결했습니다.

</details>

## 8. 성능 최적화

<details>
<summary>SSR 전환 후 초기 렌더링 속도가 개선된 이유는 무엇인가요?</summary>

SSR에서는 HTML이 이미 완성된 상태로 전달되기 때문에 브라우저가 JS 번들을 다운로드하기 전에 화면을 먼저 보여줄 수 있습니다. CSR에서는 빈 HTML이 내려오기 때문에 JS가 실행되기 전까지 사용자는 빈 화면을 보게 됩니다. 이 차이 때문에 초기 체감 속도가 크게 개선됩니다.

</details>

<details>
<summary>React Query 캐싱과 Next.js의 서버 렌더링은 어떤 면에서 충돌할 수 있나요?</summary>

같은 데이터를 서버와 클라이언트에서 중복으로 패칭하면 의도하지 않은 refetch가 발생할 수 있습니다. 이를 방지하기 위해 서버에서 처리할 데이터는 서버 컴포넌트에서 fetch로 가져오고, 클라이언트 중심 데이터만 React Query로 관리해 충돌을 피했습니다.

</details>

<details>
<summary>대용량 데이터 조회 시 Next.js에서 어떤 최적화를 고려했나요?</summary>

필터 변경 같은 상호작용이 많은 페이지는 클라이언트 컴포넌트로 분리해 React Query 기반으로 관리했고, 스켈레톤 UI를 활용해 사용자 체감 속도를 높였습니다. 또한 서버 fetch에서는 캐싱과 revalidate를 적절히 조정해 API 부담을 줄였습니다.

</details>

## 9. 기술 선택 이유 질문

<details>
<summary>왜 Next.js를 선택했나요? React + Vite가 더 단순하지 않나요?</summary>

단순한 SPA라면 Vite가 더 가볍지만, SEO가 필요한 서비스나 인증·라우팅·서버 연동이 복잡한 프로젝트에서는 Next.js의 서버 렌더링과 App Router 구조가 장점이 많습니다. 저는 블로그 서비스처럼 SEO가 중요한 웹사이트에서는 Next.js가 훨씬 안정적이라고 판단했습니다.

</details>

<details>
<summary>SPA → SSR 전환에서 가장 어려웠던 지점은 무엇이었나요?</summary>

가장 어려웠던 부분은 서버 컴포넌트와 클라이언트 컴포넌트의 역할을 명확히 분리하는 것이었습니다. 특히 브라우저 API를 사용하는 컴포넌트는 모두 클라이언트에서만 실행되기 때문에 구조를 재설계해야 했습니다. 또한 인증 처리를 서버 단으로 옮기면서 흐름 전체를 다시 정리하는 과정도 많은 고민이 필요했습니다.

</details>

<details>
<summary>Observability나 로그 관점에서 Next.js는 어떤 장점이 있나요?</summary>

서버에서 렌더링이 이루어지기 때문에 서버 로그를 통해 렌더링 단계의 오류를 직접 확인할 수 있습니다. 또한 서버 액션이나 fetch 에러가 클라이언트가 아닌 서버에서 감지되기 때문에 문제 원인 추적이 더 수월하고 모니터링이 안정적입니다.

</details>
