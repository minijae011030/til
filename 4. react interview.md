# React 면접 질문 리스트

## 1. React 기본 개념

<details>
<summary>⭐️ React는 무엇이며 어떤 문제를 해결하기 위해 등장했나요?</summary>

React는 사용자 인터페이스를 효율적으로 만들기 위한 라이브러리로, 상태 변화에 따라 UI를 직접 조작하던 기존 방식의 복잡함을 줄이기 위해 등장했습니다.

데이터 변화에 따라 화면이 자동으로 다시 그려지도록 하여 UI 상태 관리와 유지보수를 쉽게 만듭니다.

</details>

<details>
<summary>React를 프레임워크가 아닌 라이브러리로 보는 이유는 무엇인가요?</summary>

React는 라우팅, 상태 관리, 데이터 패칭 등을 강제하지 않고 UI 렌더링에만 집중하기 때문에 전체 흐름을 제어하지 않습니다. 개발자가 필요한 도구를 선택해 조합할 수 있어 라이브러리로 분류됩니다.

</details>

<details>
<summary>React의 핵심 철학(설계 사상)은 무엇인가요?</summary>

UI를 상태의 함수로 바라보는 선언형 접근과, 컴포넌트 단위로 UI를 분리해 재사용성과 예측 가능성을 높이는 것이 핵심 철학입니다.

</details>

<details>
<summary>⭐️ 컴포넌트 기반 구조의 장점은 무엇인가요?</summary>

UI를 독립적인 단위로 나눌 수 있어 재사용이 쉽고, 변경 범위가 명확해 유지보수와 테스트가 용이합니다.

</details>

<details>
<summary>⭐️ 선언형 UI란 무엇인가요?</summary>

UI를 어떻게 그릴지보다 어떤 상태일 때 어떤 화면이 나와야 하는지를 선언하는 방식으로, 상태 변화에 따라 React가 필요한 UI 업데이트를 알아서 처리합니다.

</details>

## 2. JSX & 렌더링 구조

<details>
<summary>⭐️ JSX는 무엇이며 왜 필요한가요?</summary>

JSX는 JavaScript 안에서 UI 구조를 HTML처럼 작성할 수 있게 해주는 문법으로, UI 구조를 직관적으로 표현하고 가독성을 높이기 위해 사용됩니다.

</details>

<details>
<summary>JSX는 브라우저에서 어떻게 실행되나요?</summary>

JSX는 브라우저에서 직접 실행되지 않고, Babel을 통해 React.createElement 호출로 변환된 뒤 JavaScript로 실행됩니다.

</details>

<details>
<summary>JSX와 HTML의 차이는 무엇인가요?</summary>

HTML은 정적인 마크업 언어로, 브라우저가 그대로 해석해 화면을 그리는 역할을 합니다.

반면 JSX는 JavaScript 안에서 UI 구조를 표현하기 위한 문법으로 브라우저에서 직접 실행되지 않고, JavaScript 코드로 변환되어 실행됩니다.

</details>

<details>
<summary>⭐️ React Element와 Component의 차이는 무엇인가요?</summary>

React Element는 UI를 설명하는 불변 객체이고, Component는 Element를 반환하는 함수 또는 클래스입니다.

한 번 생성된 Element는 수정되지 않으며, 변경이 필요하면 새로운 Element를 만들어 비교합니다.

</details>

## 3. Virtual DOM & Fiber

<details>
<summary>⭐️ Virtual DOM이란 무엇인가요?</summary>

Virtual DOM은 실제 DOM 구조를 메모리 상 객체로 표현한 것으로, 변경 전후를 비교해 최소한의 DOM 업데이트만 수행하기 위해 사용됩니다.

</details>

<details>
<summary>⭐️ React는 왜 실제 DOM을 직접 조작하지 않나요?</summary>

DOM 조작은 비용이 크기 때문에, Virtual DOM으로 변경 사항을 계산한 뒤 필요한 부분만 반영해 성능을 최적화합니다.

</details>

<details>
<summary>Virtual DOM의 동작 과정을 설명해보세요.</summary>

상태나 props가 변경되면 새로운 Virtual DOM 트리가 생성되고, 이전 Virtual DOM과 비교하는 diff 과정이 수행됩니다. 이 비교 결과를 바탕으로 실제 DOM에 꼭 필요한 변경만 반영함으로써 불필요한 DOM 조작을 줄입니다.

</details>

<details>
<summary>Diffing 알고리즘의 핵심 가정은 무엇인가요?</summary>

서로 다른 타입의 컴포넌트는 완전히 다른 트리로 간주하고, 같은 타입의 컴포넌트는 key를 기준으로 비교한다는 가정을 합니다. 이를 통해 비교 비용을 선형 시간으로 줄입니다.

key는 리스트 렌더링 시 각 요소를 고유하게 식별해 React가 변경, 추가, 삭제를 정확히 판단하도록 돕기 위해 필요합니다.

</details>

<details>
<summary>Fiber란 무엇인가요?</summary>

Fiber는 React의 새로운 렌더링 아키텍처로, 렌더링 작업을 작은 단위로 쪼개 관리하는 내부 자료구조입니다.

기존 동기 렌더링 구조에서는 렌더링이 길어지면 사용자 인터랙션이 막히는 문제가 있었는데, Fiber는 작업을 중단하고 재개할 수 있게 해 이를 해결했습니다.

</details>

<details>
<summary>⭐️ React에서 비동기 렌더링이 가능한 이유는 무엇인가요?</summary>

Fiber 구조를 통해 렌더링 작업을 작은 단위로 나누고 중단·재개할 수 있어, 사용자 인터랙션을 막지 않는 비동기 렌더링이 가능합니다.

</details>

<details>
<summary>⭐️ React 컴포넌트는 언제 재렌더링되나요?</summary>

React 컴포넌트는 state가 변경되거나, 새로운 props가 전달되거나, 구독 중인 context 값이 변경될 때 재렌더링됩니다.

또한 재렌더링은 Virtual DOM을 다시 계산하는 과정이고, 실제 DOM은 변경이 필요한 부분만 최소로 반영되기 때문에, 재렌더링이 일어난다고 해서 항상 실제 DOM이 바뀌는 건 아닙니다.

마지막으로 부모가 렌더링되거나, 객체/함수 같은 참조 타입이 매번 새로 생성돼 전달되면 자식 컴포넌트에서 재렌더링이 발생할 수 있습니다.

</details>

## 4. Batch Update & 상태 처리

<details>
<summary>Batch Update란 무엇인가요?</summary>

여러 상태 업데이트를 하나의 렌더링 사이클로 묶어 처리하는 방식입니다.

React 18 이후 이벤트 핸들러뿐 아니라 setTimeout, Promise 내부에서도 자동 배치가 적용됩니다.

</details>

<details>
<summary>⭐️ React는 왜 setState를 비동기적으로 처리하며, 여러 setState를 연속 호출하면 어떻게 동작하나요?</summary>

React는 여러 상태 변경을 하나의 렌더링 사이클로 묶어 처리하는 배치 업데이트를 통해 불필요한 재렌더링을 줄이고 성능을 최적화합니다.  
이 때문에 setState는 즉시 반영되지 않고 내부 큐에 쌓였다가 한 번에 처리됩니다.

여러 setState를 연속으로 호출할 경우, 객체 형태의 업데이트는 병합되어 처리되고, 함수형 업데이트는 이전 상태를 기준으로 순차적으로 실행됩니다.  
이러한 방식은 상태 업데이트의 일관성을 유지하면서 렌더링 비용을 줄이기 위한 설계입니다.

</details>

## 5. 함수형 컴포넌트 & Hooks

<details>
<summary>⭐️ 함수형 컴포넌트를 권장하는 이유는 무엇인가요?</summary>

함수형 컴포넌트는 코드가 간결하고 상태와 로직의 흐름을 이해하기 쉬우며, Hooks를 통해 로직 재사용이 가능해 유지보수와 테스트에 유리합니다.

</details>

<details>
<summary>⭐️ Hooks는 왜 등장했나요?</summary>

기존 클래스 컴포넌트는 this 바인딩 문제와 생명주기 메서드에 로직이 흩어지는 구조로 인해 코드가 복잡해지고, 로직 재사용이 어려웠다는 한계가 있었습니다.

클래스 컴포넌트의 복잡성을 해결하고, 함수형 컴포넌트에서도 상태 관리와 사이드 이펙트를 처리할 수 있도록 하기 위해 등장했습니다.

</details>

## 6. 핵심 Hooks

### useState

<details>
<summary>⭐️ useState 훅에 대해 설명해주세요.</summary>

useState는 함수형 컴포넌트에서 상태를 관리하기 위해 사용하는 React Hook입니다.  
초기 상태 값을 전달하면 현재 상태 값과, 그 상태를 변경하기 위한 setter 함수를 배열 형태로 반환합니다.

상태가 변경되면 React는 해당 컴포넌트를 다시 렌더링하여, 변경된 상태가 UI에 반영되도록 합니다.  
이를 통해 함수형 컴포넌트에서도 클래스 컴포넌트와 동일하게 상태 기반 UI를 구성할 수 있습니다.

</details>

<details>
<summary>⭐️ useState는 상태 변경을 어떤 기준으로 감지하나요?</summary>

상태 값의 참조가 변경되었는지를 기준으로 변경을 감지합니다. 객체를 직접 수정하면 변경을 감지하지 못하므로, 항상 새로운 객체를 생성해 상태를 업데이트해야 합니다.

</details>

### useEffect

<details>
<summary>⭐️ useEffect 훅에 대해 설명해주세요.</summary>

렌더링 이후에 실행되어 데이터 패칭, 구독, DOM 조작 등 사이드 이펙트를 처리하는 역할을 합니다.

컴포넌트가 렌더링된 이후에 실행되며, 의존성 배열 값이 변경될 때마다 다시 실행됩니다.

</details>

<details>
<summary>clean-up 함수는 무엇이고 언제 실행되나요?</summary>

clean-up 함수는 useEffect 안에서 반환되는 함수로, 이전 effect에서 수행한 작업을 정리하기 위해 사용됩니다.  
주로 이벤트 리스너 제거, 타이머 해제, 구독 취소와 같은 정리 작업을 담당합니다.

이 clean-up 함수는 컴포넌트가 언마운트될 때 실행되거나, 의존성 배열 값이 변경되어 effect가 다시 실행되기 직전에 실행됩니다.

</details>

<details>
<summary>⭐️ 의존성 배열이 없는 경우와 빈 배열의 차이는 무엇인가요?</summary>

의존성 배열이 없으면 매 렌더링마다 실행되고, 빈 배열이면 최초 마운트 시 한 번만 실행됩니다.

</details>

<details>
<summary>useEffect가 재렌더링을 발생시키나요?</summary>

useEffect 자체는 재렌더링을 발생시키지 않지만, 내부에서 상태를 변경하면 재렌더링이 발생할 수 있습니다.

</details>

### useRef

<details>
<summary>⭐️ useRef와 useState의 차이는 무엇인가요?</summary>

useRef는 값이 변경돼도 렌더링을 발생시키지 않고, useState는 렌더링을 발생시킵니다. ref 값은 React의 렌더링 흐름과 무관하게 관리되기 때문에 렌더링을 발생시키지 않습니다.

</details>

<details>
<summary>useRef를 상태 저장 용도로 쓰는 경우는 언제인가요?</summary>

렌더링과 무관하지만 값은 유지돼야 하는 경우, 예를 들어 이전 값 저장 등에 사용합니다.

</details>

### 의존성 배열

<details>
<summary>⭐️ 의존성 배열은 어떤 방식으로 비교되나요?</summary>

의존성 배열에는 내부에서 사용하는 모든 외부 값이 명시되어야 하며, 참조 값만 비교하는 방식인 얕은 비교를 통해 이전 값과 현재 값을 비교합니다.

</details>

<details>
<summary>⭐️ 객체/함수가 의존성에 들어가면 왜 문제가 되나요?</summary>

렌더링마다 새로운 참조가 생성되어 의존성이 변경된 것으로 판단될 수 있기 때문입니다.

</details>

<details>
<summary>⭐️ stale closure란 무엇인가요?</summary>

의존성 배열에 포함되지 않은 값이 오래된 상태로 캡처되어 최신 값을 참조하지 못하는 현상입니다.

</details>

## 7. 이벤트 & Form

<details>
<summary>⭐️ 제어 컴포넌트와 비제어 컴포넌트의 차이는 무엇인가요?</summary>

제어 컴포넌트는 상태로 값을 관리하고, 비제어 컴포넌트는 DOM 자체에서 값을 관리합니다. 상태를 통해 값이 일관되게 관리되어 검증과 로직 처리가 쉽기 때문에 일반적으로 제어 컴포넌트가 권장됩니다.

</details>

<details>
<summary>forwardRef에 대해 설명해주시요.</summary>

forwardRef는 ref를 컴포넌트 간 전달하기 위해 사용합니다.

리액트에서 ref는 key와 마찬가지로 props 가 아닌 다른 용도로 전달되도록 설정되어 있습니다. 그래서 하위 컴포넌트의 props에서 전달받은 ref를 참조할 수 없습니다.

이때 하위 컴포넌트를 forwardRef 함수로 감싸게 되면, 부모 컴포넌트에서 전달한 ref를 하위 컴포넌트에서 참조할 수 있습니다.

</details>

<details>
<summary>Synthetic Event란 무엇인가요?</summary>

Synthetic Event는 브라우저의 네이티브 이벤트를 감싸 React에서 일관된 인터페이스로 제공하는 이벤트 시스템입니다. 브라우저 차이를 신경 쓰지 않고 동일한 방식으로 이벤트를 처리할 수 있게 해줍니다.

</details>

## 8. 데이터 흐름 & 상태 전달

<details>
<summary>⭐️ React가 단방향 데이터 흐름을 사용하는 이유는 무엇인가요?</summary>

데이터 흐름을 예측 가능하게 만들어 디버깅과 유지보수를 쉽게 하기 위해서입니다.

</details>

<details>
<summary>자식에서 부모 상태를 변경하려면 어떻게 하나요?</summary>

부모에서 상태 변경 함수를 props로 내려 자식에서 호출하도록 합니다.

</details>

<details>
<summary>⭐️ Props Drilling이란 무엇인가요?</summary>

중간 컴포넌트들이 필요 없는 props를 계속 전달하는 현상입니다.
컴포넌트 구조가 복잡해지고 유지보수가 어려워지는 문제점이 있는데,
Context API나 전역 상태 관리 라이브러리를 사용하여 해결할 수 있습니다.

</details>

## 9. 렌더링 최적화

<details>
<summary>key props에 대해 설명해주세요.</summary>

리스트 항목을 고유하게 식별해 효율적인 diff를 가능하게 합니다.
index를 key로 쓰면 요소 순서 변경 시 잘못된 재사용이 발생할 수 있습니다.

</details>

<details>
<summary>메모이제이션이란 무엇인가요?</summary>

이전 계산 결과를 저장해 불필요한 연산과 렌더링을 줄이는 기법입니다.

</details>

<details>
<summary>useMemo 훅을 설명해 주세요.</summary>

useMemo 훅은 이전에 저장된 값을 메모이제이션 하는 훅입니다.
useMemo 훅의 첫 번째 파라미터로 콜백 함수, 두 번째 파라미터로 배열을 저장합니다.

콜백 함수에서는 실제로 저장할 값을 계산하는 로직을 포함합니다.
useEffect의 의존성 배열과 마찬가지로 useMemo의 두 번째 파라미터인 의존성 배열에 포함된 값이 업데이트될 때마다 해당 콜백 함수를 다시 실행해서 값을 업데이트합니다.

useMemo를 적절히 활용하면 오래 걸리는 복잡한 연산의 결괏값을 저장해 놓고 사용해서 최적화를 할 수 있습니다.

</details>

<details>
<summary>useMemo와 React.memo의 차이는 무엇인가요?</summary>

React.memo는 HOC이고, useMemo는 훅입니다.
React.memo는 컴포넌트 자체를 메모이제이션한 용도로 사용하고, useMemo는 복잡한 계산의 결과 값을 메모이제이션하는 용도로 사용합니다. 물론 컴포넌트도 넣을 수는 있습니다.

</details>

<details>
<summary>useCallback 훅을 설명해 주세요.</summary>

useCallback 훅은 useMemo 훅과 비슷한 기능으로, 함수를 메모이제이션 하는 훅입니다.

useCallback 훅도 첫 번째 파라미터로 저장할 콜백 함수, 두 번째 파라미터로 배열을 저장합니다.
두 번째 파라미터로 제공된 의존성 배열에 포함된 값이 변경될 때마다 콜백 함수를 다시 생성합니다.

</details>

## 10. 고급 개념

<details>
<summary>⭐️ Context API에 대하여 설명해주세요</summary>

Props Drilling 없이 전역적으로 값을 공유할 수 있게 해줍니다.

Context를 상태 관리처럼 쓰면 Context 값 변경 시 불필요한 재렌더링이 발생할 수 있습니다.

</details>

<details>
<summary>Portal에 대해 설명해주세요.</summary>

Portal은 컴포넌트를 부모 컴포넌트 트리 안에서 렌더링하되, 실제 DOM은 다른 위치에 붙여 렌더링하는 기능입니다.  
주로 모달, 토스트, 툴팁처럼 부모 DOM 안에 두면 레이아웃/클리핑 문제가 생기는 UI를 처리할 때 사용합니다.

</details>

<details>
<summary>Error Boundary에 대해 설명해주세요.</summary>

Error Boundary는 렌더링 중 발생한 에러를 잡아 애플리케이션 전체 크래시를 방지합니다.

에러는 렌더링 과정에서 발생하며, 이는 클래스 생명주기에서만 처리 가능하기 때문에 훅으로는 제공되지 않습니다.

</details>

## 11. 데이터 패칭

<details>
<summary>⭐️ 서버 상태와 클라이언트 상태의 차이는 무엇인가요?</summary>

서버 상태는 서버에서 관리되며 네트워크 요청을 통해 가져와야 하는 데이터로, 변경 시 동기화와 캐싱 문제가 발생합니다. 반면 클라이언트 상태는 UI 상태나 사용자 입력처럼 애플리케이션 내부에서 관리되며 즉시 변경되고 예측이 가능합니다.

</details>

<details>
<summary>React Query에 대해 설명해주세요.</summary>

React Query는 서버 상태를 효율적으로 관리하기 위한 라이브러리입니다.
기존의 useEffect + fetch 방식에서 발생하던 중복 요청, 로딩·에러 상태 관리, 캐싱 처리의 복잡함을 줄이기 위해 등장했으며, 서버 데이터의 캐싱과 동기화를 자동으로 처리해줍니다.

</details>
