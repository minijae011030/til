# 리액트 라이브러리 면접 질문

## 상태 관리 (Zustand)

<details>
<summary>상태관리 라이브러리는 왜 사용하나요?</summary>

1. Prop Drilling: 리액트의 단방향 데이터 흐름으로 인해 발생하는 문제를 해결합니다.
2. 불필요한 리렌더링 방지: 전역상태를 효율적으로 관리합니다.
3. 유지보수성: 복잡한 상태 업데이트 로직과 UI 컴포넌트를 분리하여 유지보수성을 높이고 데이터의 일관성을 보장합니다.

</details>
<details>
<summary>Zustand란 무엇인가요?</summary>

Zustand는 Flux 패턴을 따르는 가볍고 직관적인 상태 관리 라이브러리입니다. 기존 Redux의 복잡한 구조(보일러 플레이트)를 걷어내고 하나의 스토어에 상태와 액션을 함께 정의하는 단순한 방식을 채택하고 있습니다.

특히 Context API와 달리 전역적인 Provider 지옥을 만들지 않으며, 컴포넌트가 필요한 상태만 선택적으로 구독할 수 있게 하여 리렌더링 성능을 최적화하기에 매우 용이하다는 장점이 있습니다.

</details>
<details>
<summary>Flux 패턴에 대해서 아시나요?</summary>
  
Flux 패턴은 데이터가 Action -> Dispatcher -> Store -> View라는 단방향 흐름으로만 움직이게 하는 아키텍처입니다.

기존 MVC 패턴에서 데이터가 양방향으로 흘러 발생하던 복잡성과 예측 불가능한 버그를 해결하기 위해 등장했습니다.

Zustand나 Redux 같은 현대적 상태 관리 라이브러리들은 이 Flux 패턴을 기반으로 하여, 상태 변경 과정을 투명하게 만들고 코드의 흐름을 예측 가능하게 관리할 수 있도록 돕습니다.

</details>

<details>
<summary>MVVM패턴과 Flux패턴의 차이점에 대해서 설명해보세요.</summary>

- MVVM은 데이터 바인딩을 사용하여 View와 ViewModel 간에 양방향 데이터 흐름을 유지합니다. 
- 반면 Flux는 단방향 데이터 흐름을 사용하여 Action -> Dispatcher -> Store -> View의 방향으로 데이터가 흐릅니다. 

- MVVM에서는 ViewModel이 Model의 역할을 수행하고, View와 ViewModel 사이에서 데이터를 중개합니다.
- 반면 Flux에서는 Store가 애플리케이션의 데이터와 비즈니스 로직을 담당하고, Dispatcher를 통해 Action을 처리합니다. 

- Flux는 단방향 데이터 흐름과 단일 책임 원칙을 따르므로 테스트하기 쉬운 코드를 작성하기 쉽습니다. 
- MVVM에서는 ViewModel과 View 간의 양방향 데이터 바인딩 때문에 테스트하기가 어려울 수 있습니다. 

- MVVM은 Angular, Vue.js 등의 프레임워크에서 사용되며, 
- Flux는 React에서 주로 사용됩니다.

</details>



<details>
<summary>Flux 패턴의 핵심 요소에 대해서 설명해주실 수 있나요?</summary>

1. Action: 무엇이 일어날지 정의하는 '객체'입니다. (예: "아이템 추가", "이름 변경")
2. Dispatcher: 모든 액션을 받아서 Store로 전달하는 중앙 허브입니다.
3. Store: 애플리케이션의 상태와 상태를 변경하는 로직이 담긴 곳입니다.
4. View: Store에서 데이터를 가져와 화면에 보여주고, 사용자 입력이 들어오면 다시 Action을 발생시킵니다.

</details>
<details>
<summary>Redux나 Context API와 비교했을 때 Zustand가 갖는 차별화된 장점은 무엇인가요?</summary>

Zustand의 가장 큰 장점은 단순함과 성능입니다.

1. 단순한 구조: Redux와 달리 복잡한 보일러플레이트 없이 하나의 함수로 상태와 액션을 정의할 수 있어 생산성이 높습니다.
2. 성능 최적화: Context API에서 발생하는 불필요한 전체 리렌더링 문제를 Selector 기능을 통해 해결하여 최적화된 성능을 제공합니다.
3. 단일 스토어: Provider 없이 단일 스토어로 상태를 관리할 수 있어 컴포넌트 구조를 유연하게 유지할 수 있습니다.

</details>

<details>
<summary>특정 컴포넌트의 불필요한 리렌더링을 방지하기 위한 Selector의 역할에 대해 설명해 주세요.</summary>
</details>

<details>
<summary>스토어의 상태를 업데이트할 때 불변성을 유지해야 하는 이유와 내부적으로 어떻게 처리되는지 설명해 주세요.</summary>
</details>

## React Query (TanStack Query)

<details>
<summary>React Query가 스스로를 '상태 관리 라이브러리'라고 부르는 이유는 무엇인가요?</summary>
</details>

<details>
<summary>staleTime과 gcTime의 차이점과 각각의 설정이 성능에 미치는 영향은 무엇인가요?</summary>
</details>

<details>
<summary>invalidateQueries의 역할은 무엇이며, 주로 어떤 상황에 사용하나요?</summary>
</details>

<details>
<summary>Query의 상태(Loading, Error, Success)와 데이터의 상태(Fetching, Stale, Fresh, Inactive)의 차이를 설명해 주세요.</summary>
</details>

## React Hook Form / Zod

<details>
<summary>React Hook Form이 비제어(Uncontrolled) 방식을 기반으로 성능을 최적화하는 원리는 무엇인가요?</summary>
</details>

<details>
<summary>왜 React Hook Form과 Zod를 함께 사용하나요? 유효성 검사 스키마를 분리했을 때의 이점을 설명해 주세요.</summary>
</details>

<details>
<summary>Zod의 `z.infer`를 활용하여 스키마로부터 타입을 추출하고 이를 활용하는 방식의 장점은 무엇인가요?</summary>
</details>

<details>
<summary>폼 데이터를 서버로 전송하기 전, Zod 스키마를 통해 런타임에서 데이터를 검증하는 프로세스에 대해 설명해 주세요.</summary>
</details>

## 라우터 (React Router / Tanstack Router)

<details>
<summary>라우터는 왜 사용하나요?</summary>
</details>

<details>
<summary>React Router와 TanStack Router의 가장 차이점은 무엇인가요?</summary>
</details>

<details>
<summary>React Router v6.4+에서 도입된 loader와 action의 역할은 무엇이며, UX 측면에서 어떤 이점이 있나요?</summary>
</details>

<details>
<summary>라우트 기반 코드 분할(Code Splitting)의 필요성과 이를 구현하기 위한 방식에 대해 설명해 주세요.
</summary>
</details>

# 기타 -> 위치 변경 필요?

<details>
<summary>TDD란 무엇인가요?</summary>

TDD(Test-Driven Development)는 테스트 주도 개발 방법론으로, 
개발자가 코드를 작성하기 전에 먼저 테스트 케이스를 작성하고 이를 통과시키는 것을 중심으로 개발을 진행하는 방법입니다. 

TDD는 코드 품질을 향상시키고 버그를 미리 발견하여 개선하는 데 도움이 됩니다. 
또한, 코드 변경 시 이전에 작성된 테스트 케이스를 수행하여 기존 코드의 영향을 미치는 부분을 파악하고, 안정적인 코드 개발에 도움을 줍니다.
</details>
