## 자바스크립트

### ⭐ 자바스크립트는 무슨 언어인가요?

자바스크립트는 웹 브라우저에서 동작하는 인터프리터 기반의 스크립트 언어로,
동적 타입을 가지며 이벤트 기반, 비동기 프로그래밍을 지원하는 언어입니다.
현재는 브라우저뿐 아니라 Node.js 환경에서도 서버 사이드에서 사용됩니다.

### ⭐ 변수 선언, 초기화, 할당의 차이

- 선언: 변수를 식별자 이름으로 등록
- 초기화: 메모리에 공간을 만들고 기본값을 할당
- 할당: 변수에 실제 값을 대입

```js
let a; // 선언
a = 10; // 할당
let b = 5; // 선언 + 초기화 + 할당
```

### ⭐ 생성자(Constructor)

객체를 생성하기 위한 함수로, new 키워드를 통해 호출되며 동일한 구조의 객체를 반복 생성할 떄 사용합니다.

### ⭐ this

this는 함수가 호출되는 방식에 따라 결정되는 참조값입니다.

- 전역: window
- 객체 메서드: 해당 객체
- 생성자 함수: 새로 생성된 인스턴ㅅ느
- 화살표 함수: 상위 스코프의 this

### ⭐ 콜백 함수

콜백 함수는 다른 함수의 인자로 전달되어 특정 시점에 실행되는 함수입니다.
비동기 처리(네트워크 요청, 이벤트, 타이머 등)에 자주 사용됩니다.

문제점으로 콜백 지옥이 발생할 수 있으며,
이를 해결하기 위해 Promise, async/await가 도입되었습니다.

### ⭐ Arrow Function

ES6에서 도입된 함수 표현식으로,
자신만의 this를 가지지 않고 상위 스코프의 this를 사용합니다.

→ this 바인딩으로 인한 오류를 줄여
콜백 함수나 이벤트 핸들러에서 유용합니다.

### ⭐ Promise

Promise는 비동기 작업의 상태를 객체로 표현한 것입니다.

- pending
- fulfilled
- rejected

비동기 결과를 .then(), .catch()로 처리할 수 있습니다.

### ⭐ Promise, Callback 비교

- Callback
  - 중첩이 깊어질수록 가독성 저하
  - 에러 처리 복잡
- Promise
  - 체이닝 가능
  - 에러 처리 일관적
  - 가독성 향상

### ⭐ Async/Await 설명

Promise 기반 비동기 처리를 동기 코드처럼 작성할 수 있는 문법입니다.

- async 함수는 항상 Promise 반환
- await은 Promise가 resolve될 때까지 대기

### ⭐ Promise와 Async, Await의 차이

차이는 문법과 가독성입니다.

- Promise: .then(), .catch()
- Async/Await: try-catch 사용 가능 → 에러 처리 직관적

### ⭐ var, let, const 차이

- var
  - 함수 스코프
  - 재선언 가능
  - undefined로 호이스팅
- let
  - 블록 스코프
  - 재할당 가능
  - TDZ 존재
- const
  - 블록 스코프
  - 재할당 불가
  - 객체 내부 변경 가능

기본적으로 const → let 순서로 사용

### ⭐ 이벤트 버블링과 캡처링

- 캡처링: 상위 → 하위
- 버블링: 하위 → 상위 (기본 동작)

이벤트 캡처링은 이벤트가 최상위 요소에서 시작해 실제 이벤트가 발생한 요소까지 내려오는 전파 방식입니다. 캡처링은 이벤트가 하위 요소에 도달하기 전에 미리 제어해야 하는 경우에 사용됩니다.
예를 들어, 특정 영역 전체의 클릭을 선처리하거나 하위 요소의 이벤트 동작을 조건적으로 막아야 할 때 활용할 수 있습니다.

이벤트 버블링은 하위 요소에서 발생한 이벤트가 상위 요소로 전파되는 현상입니다.
자식 요소에서 발생한 이벤트를 부모에서 한 번에 처리할 수 있기 때문에,
이벤트 위임과 같은 패턴에 활용되어 성능과 유지보수 측면에서 이점이 있습니다.
필요할 경우 stopPropagation을 통해 전파를 제어할 수 있습니다.

### ⭐ 이벤트 위임과 동작 방식

부모 요소에 이벤트를 등록해
자식 요소의 이벤트를 처리하는 방식입니다.

이벤트 버블링을 활용하며,
동적으로 생성된 요소에도 대응 가능하고 성능에 유리합니다.

### ⭐ 호이스팅과 발생 이유

JS 실행 전 실행 컨텍스트 생성 과정에서
선언 정보를 미리 메모리에 등록하기 때문에 발생합니다.

- var: 선언만 호이스팅
- let/const: TDZ로 접근 불가

### ⭐ 스코프(Scope)

변수에 접근할 수 있는 유효 범위입니다.

- 전역 스코프
- 함수 스코프
- 블록 스코프

### ⭐ 스코프 체인

현재 스코프에서 변수를 찾지 못하면
상위 스코프로 탐색을 이어가는 구조입니다.

### ⭐ 클로저(Closure)

함수와 해당 함수가 선언된 렉시컬 환경의 조합입니다.
외부 변수를 기억해 상태를 유지할 수 있으며,
캡슐화와 정보 은닉에 사용됩니다.

### ⭐ 자바스크립트가 동적 언어인 이유

- 변수 타입이 런타임에 결정
- 타입 선언 없이 사용 가능

### ⭐ 깊은 복사 vs 얕은 복사

- 얕은 복사: 참조값 복사
- 깊은 복사: 실제 값 복사

### ⭐ 동기와 비동기

- 동기: 작업 순서 보장, 블로킹 발생 가능
- 비동기: 병렬 처리, UI 반응성 향상

### ⭐ ES6 주요 기능

- let, const
- arrow function
- Promise
- async/await
- destructuring
- spread operator
- class, module

### ⭐ undefined / null / undeclared

- undefined: 값이 할당되지 않음
- null: 의도적 빈 값
- undeclared: 선언되지 않음 (ReferenceError)

### ⭐ 이벤트 루프 설명

콜 스택이 비면
태스크 큐 → 마이크로태스크 큐 순으로 실행

### ⭐ 태스크 큐 / 마이크로태스크 큐

- 태스크 큐: setTimeout, setInterval
- 마이크로태스크 큐: Promise.then, MutationObserver

### ⭐ map / forEach / reduce

- forEach: 단순 반복
- map: 새로운 배열 반환
- reduce: 누적 계산

### ⭐ JS 메모리 관리

- 힙: 객체, 참조 타입
- 스택: 실행 컨텍스트, 원시 타입
- 가비지 컬렉션으로 자동 관리

### ⭐ 클래스

객체 생성을 위한 템플릿
prototype 기반 문법을 클래스 문법으로 표현한 것

### ⭐ 엄격 모드(strict mode)

- 문법 오류를 에러로 처리
- 암묵적 전역 변수 방지
- 안전한 코드 작성 유도

### ⭐ 콜 스택과 힙

- 콜 스택: 함수 실행 순서 관리
- 힙: 객체 저장 공간

### ⭐ 제너레이터

yield를 사용해 실행을 중단·재개할 수 있는 함수
이터러블 객체를 생성합니다.

### ⭐ == 와 === 차이

- ==: 타입 변환 후 비교
- ===: 타입 + 값 비교 (권장)
