# 리액트 라이브러리 면접 질문

## 1. 상태 관리 (Zustand)

<details>
<summary>상태관리 라이브러리는 왜 사용하나요?</summary>

1. Prop Drilling: 리액트의 단방향 데이터 흐름으로 인해 발생하는 문제를 해결합니다.
2. 불필요한 리렌더링 방지: 전역상태를 효율적으로 관리합니다.
3. 유지보수성: 복잡한 상태 업데이트 로직과 UI 컴포넌트를 분리하여 유지보수성을 높이고 데이터의 일관성을 보장합니다.

</details>
<details>
<summary>Zustand란 무엇인가요?</summary>

Zustand는 Flux 패턴을 따르는 가볍고 직관적인 상태 관리 라이브러리입니다. 기존 Redux의 복잡한 구조(보일러 플레이트)를 걷어내고 하나의 스토어에 상태와 액션을 함께 정의하는 단순한 방식을 채택하고 있습니다.

특히 Context API와 달리 전역적인 Provider 지옥을 만들지 않으며, 컴포넌트가 필요한 상태만 선택적으로 구독할 수 있게 하여 리렌더링 성능을 최적화하기에 매우 용이하다는 장점이 있습니다.

</details>
<details>
<summary>Flux 패턴에 대해서 아시나요?</summary>
  
Flux 패턴은 데이터가 Action -> Dispatcher -> Store -> View라는 단방향 흐름으로만 움직이게 하는 아키텍처입니다.

기존 MVC 패턴에서 데이터가 양방향으로 흘러 발생하던 복잡성과 예측 불가능한 버그를 해결하기 위해 등장했습니다.

Zustand나 Redux 같은 현대적 상태 관리 라이브러리들은 이 Flux 패턴을 기반으로 하여, 상태 변경 과정을 투명하게 만들고 코드의 흐름을 예측 가능하게 관리할 수 있도록 돕습니다.

</details>

<details>
<summary>MVVM패턴과 Flux패턴의 차이점에 대해서 설명해보세요.</summary>

1. 데이터 흐름 관점

- MVVM → 양방향 데이터 흐름 (Two-way Binding)
  View의 변경이 ViewModel에 바로 반영되고, ViewModel의 변경도 View에 자동 반영됩니다.
- Flux → 단방향 데이터 흐름 (One-way Flow)
  Action → Dispatcher → Store → View로 항상 한 방향으로만 데이터가 흐릅니다.

2. 구조 관점

- MVVM는 ViewModel이 View의 상태와 Model을 중간에서 조율하는 형태이며, ViewModel ↔ View 간 양방향 바인딩이 핵심 구조입니다.
- Flux는 Action 생성 → Dispatcher → Store → View로 데이터가 전달되는 체계적인 구조이며 Store는 상태와 비즈니스 로직을 보유하는 단일 책임 구조입니다.

3. 유지보수 & 테스트 관점

- MVVM - 양방향 데이터 바인딩으로 인해 상태 변경 흐름이 숨겨지고 추적이 어려워,
  테스트가 복잡해질 수 있습니다.
- Flux - 모든 상태 변화가 Action을 통해 진행되는 명확한 단방향 흐름
  → 상태 추적과 테스트가 쉬움.

4. 적용 프레임워크 관점

- MVVM → Angular, Vue 같은 양방향 바인딩 기반 프레임워크
- Flux → React 생태계에서 Redux 등으로 발전

</details>

<details>
<summary>Flux 패턴의 핵심 요소에 대해서 설명해주실 수 있나요?</summary>

1. Action: 무엇이 일어날지 정의하는 '객체'입니다. (예: "아이템 추가", "이름 변경")
2. Dispatcher: 모든 액션을 받아서 Store로 전달하는 중앙 허브입니다.
3. Store: 애플리케이션의 상태와 상태를 변경하는 로직이 담긴 곳입니다.
4. View: Store에서 데이터를 가져와 화면에 보여주고, 사용자 입력이 들어오면 다시 Action을 발생시킵니다.

</details>
<details>
<summary>Redux나 Context API와 비교했을 때 Zustand가 갖는 차별화된 장점은 무엇인가요?</summary>

Zustand의 가장 큰 장점은 단순함과 성능입니다.

1. 단순한 구조: Redux와 달리 복잡한 보일러플레이트 없이 하나의 함수로 상태와 액션을 정의할 수 있어 생산성이 높습니다.
2. 성능 최적화: Context API에서 발생하는 불필요한 전체 리렌더링 문제를 Selector 기능을 통해 해결하여 최적화된 성능을 제공합니다.
3. 단일 스토어: Provider 없이 단일 스토어로 상태를 관리할 수 있어 컴포넌트 구조를 유연하게 유지할 수 있습니다.

</details>

<details>
<summary>특정 컴포넌트의 불필요한 리렌더링을 방지하기 위한 Selector의 역할에 대해 설명해 주세요.</summary>
</details>

<details>
<summary>스토어의 상태를 업데이트할 때 불변성을 유지해야 하는 이유와 내부적으로 어떻게 처리되는지 설명해 주세요.</summary>
</details>

## 2. React Query (TanStack Query)

<details>
<summary>React Query가 스스로를 '상태 관리 라이브러리'라고 부르는 이유는 무엇인가요?</summary>
</details>

<details>
<summary>staleTime과 gcTime의 차이점과 각각의 설정이 성능에 미치는 영향은 무엇인가요?</summary>
</details>

<details>
<summary>invalidateQueries의 역할은 무엇이며, 주로 어떤 상황에 사용하나요?</summary>
</details>

<details>
<summary>Query의 상태(Loading, Error, Success)와 데이터의 상태(Fetching, Stale, Fresh, Inactive)의 차이를 설명해 주세요.</summary>
</details>

## 3. React Hook Form / Zod

<details>
<summary>React Hook Form이 비제어(Uncontrolled) 방식을 기반으로 성능을 최적화하는 원리는 무엇인가요?</summary>
</details>

<details>
<summary>왜 React Hook Form과 Zod를 함께 사용하나요? 유효성 검사 스키마를 분리했을 때의 이점을 설명해 주세요.</summary>
</details>

<details>
<summary>Zod의 `z.infer`를 활용하여 스키마로부터 타입을 추출하고 이를 활용하는 방식의 장점은 무엇인가요?</summary>
</details>

<details>
<summary>폼 데이터를 서버로 전송하기 전, Zod 스키마를 통해 런타임에서 데이터를 검증하는 프로세스에 대해 설명해 주세요.</summary>
</details>

## 4. 라우터 (React Router / Tanstack Router)

<details>
<summary>라우터는 왜 사용하나요?</summary>
</details>

<details>
<summary>React Router와 TanStack Router의 가장 차이점은 무엇인가요?</summary>
</details>

<details>
<summary>React Router v6.4+에서 도입된 loader와 action의 역할은 무엇이며, UX 측면에서 어떤 이점이 있나요?</summary>
</details>

<details>
<summary>라우트 기반 코드 분할(Code Splitting)의 필요성과 이를 구현하기 위한 방식에 대해 설명해 주세요.
</summary>
</details>

## 5. 기타 -> 위치 변경 필요?

<details>
<summary>TDD란 무엇인가요?</summary>

TDD(Test-Driven Development)는 테스트 주도 개발 방법론으로,
개발자가 코드를 작성하기 전에 먼저 테스트 케이스를 작성하고 이를 통과시키는 것을 중심으로 개발을 진행하는 방법입니다.

TDD는 코드 품질을 향상시키고 버그를 미리 발견하여 개선하는 데 도움이 됩니다.
또한, 코드 변경 시 이전에 작성된 테스트 케이스를 수행하여 기존 코드의 영향을 미치는 부분을 파악하고, 안정적인 코드 개발에 도움을 줍니다.

</details>
