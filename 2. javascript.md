## 자바스크립트

### ⭐ 자바스크립트는 무슨 언어인가요?

자바스크립트는 웹 브라우저에서 동작하는 인터프리터 기반의 스크립트 언어로,
동적 타입을 가지며 이벤트 기반, 비동기 프로그래밍을 지원하는 언어입니다.
현재는 브라우저뿐 아니라 Node.js 환경에서도 서버 사이드에서 사용됩니다.

### ⭐ 실행 컨텍스트와 호이스팅

JS 실행 전 실행 컨텍스트가 생성되며,
이 과정에서 선언 정보가 미리 메모리에 등록됩니다.

- var: 선언만 호이스팅
- let/const: 선언은 호이스팅되지만 TDZ로 접근 불가

→ 호이스팅은 실행 컨텍스트 생성 단계에서 발생합니다.

### ⭐ 변수 선언, 초기화, 할당의 차이

- 선언: 변수를 식별자 이름으로 등록
- 초기화: 메모리에 공간을 만들고 기본값(undefined) 할당
- 할당: 변수에 실제 값을 대입

```js
let a; // 선언 + 초기화
a = 10; // 할당
let b = 5; // 선언 + 초기화 + 할당
```

### ⭐ var, let, const 차이

- var
  - 함수 스코프
  - 재선언 가능
  - undefined로 호이스팅
- let
  - 블록 스코프
  - 재할당 가능
  - TDZ 존재
- const
  - 블록 스코프
  - 재할당 불가
  - 객체 내부 변경 가능

→ 기본적으로 const → let 순서로 사용

### ⭐ 스코프(Scope)

변수에 접근할 수 있는 유효 범위입니다.

- 전역 스코프
- 함수 스코프
- 블록 스코프

### ⭐ 스코프 체인

현재 스코프에서 변수를 찾지 못하면
상위 스코프로 탐색을 이어가는 구조입니다.

### ⭐ 클로저(Closure)

함수와 해당 함수가 선언된 렉시컬 환경의 조합입니다.
외부 변수를 기억해 상태를 유지할 수 있으며,
캡슐화와 정보 은닉에 사용됩니다.

### ⭐ this

this는 함수가 호출되는 방식에 따라 결정되는 참조값입니다.

- 전역: window
- 객체 메서드: 해당 객체
- 생성자 함수: 새로 생성된 인스턴스
- 화살표 함수: 상위 스코프의 this

### ⭐ 생성자(Constructor)

객체를 생성하기 위한 함수로, new 키워드를 통해 호출되며
동일한 구조의 객체를 반복 생성할 때 사용합니다.

### ⭐ 프로토타입 체인(Prototype Chain)

객체에서 프로퍼티를 찾을 때
자기 자신 → 프로토타입 → 상위 프로토타입 순으로 탐색합니다.

- 이 구조가 상속을 구현하는 방식

→ 프로토타입 기반 언어의 핵심 개념

### ⭐ 원시 타입 vs 참조 타입 (값 저장 방식)

- 원시 타입: 값 자체 저장(불변), 복사 시 값 복사
- 참조 타입: 힙에 저장, 변수는 참조를 가짐

→ 얕은/깊은 복사, 불변성 논의의 기반

### ⭐ 불변성과 상태 변경

- 원시 값: 변경이 아닌 새 값 생성
- 객체: 같은 주소의 내부 값 변경

→ React에서 state 직접 수정 시 변경 감지 문제 발생

### ⭐ 깊은 복사 vs 얕은 복사

- 얕은 복사: 참조값 복사
- 깊은 복사: 실제 값 복사

### ⭐ 깊은 복사 방법과 한계

- JSON 방식: 간단하지만 Date, 함수, undefined, 순환 참조 불가
- structuredClone: 비교적 안전(환경 확인 필요)
- 라이브러리: lodash cloneDeep, immer

→ 데이터 형태에 따라 선택

### ⭐ 동기와 비동기

- 동기: 작업 순서 보장, 블로킹 발생 가능
- 비동기: 병렬 처리, UI 반응성 향상

### ⭐ 콜백 함수

다른 함수의 인자로 전달되어 특정 시점에 실행되는 함수입니다.
비동기 처리에 자주 사용됩니다.

- 문제점: 콜백 지옥
- 해결: Promise, async/await

### ⭐ Promise

비동기 작업의 상태를 객체로 표현합니다.

- pending
- fulfilled
- rejected

.then(), .catch()로 처리

### ⭐ Promise, Callback 비교

- Callback
- 중첩 증가 → 가독성 저하
- 에러 처리 복잡
- Promise
- 체이닝 가능
- 에러 처리 일관적

### ⭐ Async/Await 설명

Promise 기반 비동기 처리를
동기 코드처럼 작성하는 문법입니다.

- async 함수는 항상 Promise 반환
- await은 resolve까지 대기

### ⭐ Promise와 Async/Await의 차이

- Promise: .then(), .catch()
- Async/Await: try-catch → 에러 처리 직관적

### ⭐ async/await 에러 처리는 왜 try-catch인가요?

에러가 Promise reject로 전달되기 때문에
동기 코드처럼 try-catch로 처리합니다.

### ⭐ try/catch가 비동기에서 안 먹는 경우

setTimeout 콜백 내부 에러는
외부 try/catch로 잡히지 않습니다.

- 다른 실행 컨텍스트에서 실행되기 때문

→ Promise/async-await로 에러 전달 필요

### ⭐ 이벤트 루프 설명

콜 스택이 비면
마이크로태스크 큐 → 태스크 큐 순으로 실행

### ⭐ 태스크 큐 / 마이크로태스크 큐

- 태스크 큐: setTimeout, setInterval, 이벤트
- 마이크로태스크 큐: Promise.then, async/await

### ⭐ 마이크로태스크가 먼저 실행되는 이유

현재 작업이 끝난 직후 바로 처리되기 때문

→ Promise가 setTimeout(0)보다 먼저 실행

### ⭐ 이벤트 버블링과 캡처링

- 캡처링: 상위 → 하위
- 버블링: 하위 → 상위 (기본)

### ⭐ target vs currentTarget

- target: 실제 이벤트 발생 요소
- currentTarget: 핸들러가 등록된 요소

→ 이벤트 위임 핵심 개념

### ⭐ preventDefault vs stopPropagation

- preventDefault(): 기본 동작 방지
- stopPropagation(): 이벤트 전파 중단

### ⭐ 이벤트 위임과 동작 방식

부모 요소에 이벤트를 등록해
자식 요소의 이벤트를 처리

- 동적 요소 대응
- 성능 및 유지보수 유리

### ⭐ 디바운스 vs 쓰로틀

- debounce: 마지막 호출만 실행
- throttle: 일정 시간 간격 실행

→ 이벤트 최적화 핵심

### ⭐ map / forEach / reduce

- forEach: 단순 반복
- map: 새로운 배열 반환
- reduce: 누적 계산

### ⭐ Map / Set이 Object / Array보다 유리한 경우

- Map: 키 제약 없음, 탐색 유리
- Set: 중복 제거 최적

### ⭐ ES6 주요 기능

- let, const
- arrow function
- Promise
- async/await
- destructuring
- spread operator
- class, module

### ⭐ 모듈 시스템: CommonJS vs ES Module

- CommonJS: require, module.exports
- ES Module: import/export (트리 쉐이킹 유리)

### ⭐ JS 메모리 관리

- 힙: 객체, 참조 타입
- 스택: 실행 컨텍스트, 원시 타입
- 가비지 컬렉션 자동 관리

### ⭐ 콜 스택과 힙

- 콜 스택: 함수 실행 순서 관리
- 힙: 객체 저장 공간

### ⭐ 클래스

객체 생성을 위한 템플릿
prototype 기반 문법을 클래스 문법으로 표현

### ⭐ 제너레이터

yield를 사용해 실행을 중단·재개
이터러블 객체 생성

### ⭐ 엄격 모드(strict mode)

- 문법 오류를 에러로 처리
- 암묵적 전역 변수 방지

### ⭐ undefined / null / undeclared

- undefined: 값 미할당
- null: 의도적 빈 값
- undeclared: 선언되지 않음

### ⭐ == 와 === 차이

- ==: 타입 변환 후 비교
- ===: 타입 + 값 비교 (권장)
