# 리액트 라이브러리 면접 질문

## 1. 상태 관리 (Zustand)

### 개요

<details>
<summary>상태관리 라이브러리는 왜 사용하나요?</summary>

1. Prop Drilling: 리액트의 단방향 데이터 흐름으로 인해 발생하는 문제를 해결합니다.
2. 불필요한 리렌더링 방지: 전역상태를 효율적으로 관리합니다.
3. 유지보수성: 복잡한 상태 업데이트 로직과 UI 컴포넌트를 분리하여 유지보수성을 높이고 데이터의 일관성을 보장합니다.

</details>
<details>
<summary>Zustand란 무엇인가요?</summary>

Zustand는 Flux 패턴을 따르는 가볍고 직관적인 상태 관리 라이브러리입니다. 기존 Redux의 복잡한 구조(보일러 플레이트)를 걷어내고 하나의 스토어에 상태와 액션을 함께 정의하는 단순한 방식을 채택하고 있습니다.

특히 Context API와 달리 전역적인 Provider 지옥을 만들지 않으며, 컴포넌트가 필요한 상태만 선택적으로 구독할 수 있게 하여 리렌더링 성능을 최적화하기에 매우 용이하다는 장점이 있습니다.

</details>

<details>
<summary>Redux나 Context API와 비교했을 때 Zustand가 갖는 차별화된 장점은 무엇인가요?</summary>

Zustand의 가장 큰 장점은 단순함과 성능입니다.

1. 단순한 구조: Redux와 달리 복잡한 보일러플레이트 없이 하나의 함수로 상태와 액션을 정의할 수 있어 생산성이 높습니다.
2. 성능 최적화: Context API에서 발생하는 불필요한 전체 리렌더링 문제를 Selector 기능을 통해 해결하여 최적화된 성능을 제공합니다.
3. 단일 스토어: Provider 없이 단일 스토어로 상태를 관리할 수 있어 컴포넌트 구조를 유연하게 유지할 수 있습니다.

</details>

### 상태관리 패턴

<details>
<summary>Flux 패턴에 대해서 아시나요?</summary>
  
Flux 패턴은 데이터가 Action -> Dispatcher -> Store -> View라는 단방향 흐름으로만 움직이게 하는 아키텍처입니다.

기존 MVC 패턴에서 데이터가 양방향으로 흘러 발생하던 복잡성과 예측 불가능한 버그를 해결하기 위해 등장했습니다.

Zustand나 Redux 같은 현대적 상태 관리 라이브러리들은 이 Flux 패턴을 기반으로 하여, 상태 변경 과정을 투명하게 만들고 코드의 흐름을 예측 가능하게 관리할 수 있도록 돕습니다.

</details>

<details>
<summary>MVVM패턴과 Flux패턴의 차이점에 대해서 설명해보세요.</summary>

1. 데이터 흐름 관점

- MVVM → 양방향 데이터 흐름 (Two-way Binding)
  View의 변경이 ViewModel에 바로 반영되고, ViewModel의 변경도 View에 자동 반영됩니다.
- Flux → 단방향 데이터 흐름 (One-way Flow)
  Action → Dispatcher → Store → View로 항상 한 방향으로만 데이터가 흐릅니다.

2. 구조 관점

- MVVM는 ViewModel이 View의 상태와 Model을 중간에서 조율하는 형태이며, ViewModel ↔ View 간 양방향 바인딩이 핵심 구조입니다.
- Flux는 Action 생성 → Dispatcher → Store → View로 데이터가 전달되는 체계적인 구조이며 Store는 상태와 비즈니스 로직을 보유하는 단일 책임 구조입니다.

3. 유지보수 & 테스트 관점

- MVVM - 양방향 데이터 바인딩으로 인해 상태 변경 흐름이 숨겨지고 추적이 어려워,
  테스트가 복잡해질 수 있습니다.
- Flux - 모든 상태 변화가 Action을 통해 진행되는 명확한 단방향 흐름
  → 상태 추적과 테스트가 쉬움.

4. 적용 프레임워크 관점

- MVVM → Angular, Vue 같은 양방향 바인딩 기반 프레임워크
- Flux → React 생태계에서 Redux 등으로 발전

</details>

<details>
<summary>Flux 패턴의 핵심 요소에 대해서 설명해주실 수 있나요?</summary>

1. Action: 무엇이 일어날지 정의하는 '객체'입니다. (예: "아이템 추가", "이름 변경")
2. Dispatcher: 모든 액션을 받아서 Store로 전달하는 중앙 허브입니다.
3. Store: 애플리케이션의 상태와 상태를 변경하는 로직이 담긴 곳입니다.
4. View: Store에서 데이터를 가져와 화면에 보여주고, 사용자 입력이 들어오면 다시 Action을 발생시킵니다.

</details>

### Zutand 활용

<details>
<summary>특정 컴포넌트의 불필요한 리렌더링을 방지하기 위한 Selector의 역할에 대해 설명해 주세요.</summary>

Selector는 스토어에서 필요한 특정 상태만 선택해 구독하는 기능입니다.
컴포넌트는 선택한 값이 변경될 때만 리렌더링되기 때문에, 전체 스토어가 변경되어도 불필요한 렌더링이 발생하지 않습니다.

즉, **부분 구독(partial subscription)**을 통해 성능을 최적화하는 기능이라고 설명할 수 있습니다.

</details>

<details>
<summary>스토어의 상태를 업데이트할 때 불변성을 유지해야 하는 이유와 내부적으로 어떻게 처리되는지 설명해 주세요.</summary>

Zustand는 상태 변경 시 **얕은 비교(shallow compare)**를 통해 변경 여부를 판단합니다.
그렇기 때문에 상태를 직접 변이하면 이전 상태와 참조값이 동일해져 리렌더링이 트리거되지 않을 수 있습니다.

불변성을 유지하면 새로운 객체 참조를 만들기 때문에 변경 감지가 확실하게 이루어지고, 상태 관리가 예측 가능해집니다.

내부적으로는:

- 새로운 상태와 기존 상태를 얕게 비교하고
- 선택한 selector가 반환하는 값이 달라졌을 때만
- 해당 컴포넌트를 리렌더링합니다.

</details>

## 2. React Query (TanStack Query)

### 개요

<details>
<summary>⭐️ 서버 상태와 클라이언트 상태의 차이는 무엇인가요?</summary>

서버 상태는 서버에서 관리되며 네트워크 요청을 통해 가져와야 하는 데이터로, 변경 시 동기화와 캐싱 문제가 발생합니다. 반면 클라이언트 상태는 UI 상태나 사용자 입력처럼 애플리케이션 내부에서 관리되며 즉시 변경되고 예측이 가능합니다.

</details>

<details>
<summary>React Query에 대해 설명해주세요.</summary>

React Query는 서버 상태를 효율적으로 관리하기 위한 라이브러리입니다.
기존의 useEffect + fetch 방식에서 발생하던 중복 요청, 로딩·에러 상태 관리, 캐싱 처리의 복잡함을 줄이기 위해 등장했으며, 서버 데이터의 캐싱과 동기화를 자동으로 처리해줍니다.

</details>

<details>
<summary>React Query가 스스로를 '상태 관리 라이브러리'라고 부르는 이유는 무엇인가요?</summary>
React Query는 서버 데이터를 요청하는 라이브러리가 아니라, 서버 상태(server state)를 캐싱하고 동기화하며 생명주기를 관리하는 상태 관리 라이브러리이기 때문입니다.

- 서버 상태의 캐싱
- stale / fresh 관리
- 백그라운드 refetch
- 실패 재시도
- GC와 같은 메모리 정책

→ 이 모든 것이 “상태의 생명주기 관리”에 해당하므로 상태 관리 라이브러리라고 부릅니다.

</details>

### staleTime과 gcTime

<details>
<summary>staleTime과 gcTime의 차이점과 각각의 설정이 성능에 미치는 영향은 무엇인가요?</summary>

staleTime은 데이터가 신선(fresh)하다고 간주되는 기간입니다.
staleTime 동안에는 재요청(Refetch)을 하지 않습니다.
불필요한 네트워크 요청 감소의 장점이ㅣ 있습니다.

gcTime은 쿼리가 더 이상 사용되지 않을 때(=inactive) 캐시가 메모리에서 제거되기까지의 시간입니다.

- gcTime 길면: 캐시 유지 ↑, 메모리 사용 ↑
- gcTime 짧으면: 캐시 삭제 ↑, 네트워크 요청 ↑

</details>

<details>
<summary>stale time과 gc time의 시간을 정하는 전략은 무엇인가요?</summary>

먼저 staleTime은 서버로부터 받은 데이터가 '신선함'을 유지하는 시간으로, 이 시간 동안은 추가적인 네트워크 요청 없이 캐시된 데이터를 사용하여 사용자 경험을 개선합니다. 반면 gcTime은 데이터가 사용되지 않을 때 메모리에 유지되는 시간입니다. 즉, 컴포넌트가 언마운트되어 해당 데이터를 사용하는 곳이 아무도 없을 때부터 카운트됩니다. 효율적인 메모리 관리를 위해 사용됩니다.

시간을 정하는 전략으로는 데이터의 변경 빈도를 최우선으로 고려합니다. 예를 들어, 거의 변하지 않는 '공지사항' 같은 데이터는 staleTime을 길게 설정합니다. 하지만 실시간성이 중요한 '주식 시세' 등은 staleTime을 0으로 설정해 항상 최신 데이터를 보장하도록 합니다.

또한, 사용자가 페이지를 나갔다 돌아왔을 때 로딩 스피너 대신 이전 데이터를 즉시 보여주기 위해 gcTime을 항상 staleTime보다 넉넉하게 설정하여 캐시를 최대한 활용하는 방향으로 UI를 변경할 수도 있습니다.

</details>

### 상태

<details>
<summary>invalidateQueries의 역할은 무엇이며, 주로 어떤 상황에 사용하나요?</summary>

invalidateQueries는 특정 쿼리 캐시를 오래된 데이터(stale) 상태로 표시하여 다음 렌더링 시 자동으로 refetch를 트리거합니다.

- 데이터를 생성/수정/삭제한 후 최신 데이터로 리스트를 갱신해야 할 때
- Optimistic Update 이후 서버 데이터와 동기화가 필요할 때 사용합니다.

</details>

<details>
<summary>Query의 상태(Loading, Error, Success)와 데이터의 상태(Fetching, Stale, Fresh, Inactive)의 차이를 설명해 주세요.</summary>

- Query의 상태는 React Query가 네트워크 요청을 어떤 단계에서 처리 중인지 나타내는 상태입니다. 컴포넌트 렌더링 과정에서 개발자가 직접 확인하는 값으로, 요청 중이면 loading, 실패하면 error, 응답이 정상적으로 도착하면 success 상태가 됩니다.

- 반면 데이터의 상태는 요청으로 받아온 데이터가 캐시 안에서 어떤 생명주기를 가지고 있는지 나타내는 내부적 상태입니다. 요청이 발생하는 동안에는 fetching 상태가 되고, 응답이 도착한 직후에는 staleTime 동안 fresh 상태를 유지합니다. staleTime이 지나면 자동으로 stale 상태가 되어 다시 가져올 대상이 되며, 컴포넌트에서 더 이상 해당 데이터를 사용하지 않으면 inactive 상태가 되어 gcTime 이후 캐시에서 삭제됩니다.

즉 Query의 상태는 **요청의 흐름**을 나타내고, 데이터의 상태는 **캐시 안에서 데이터가 얼마나 유효한지**를 표현하는 서로 다른 계층의 상태입니다.

</details>

### 쿼리 키

<details>
<summary>고유한 쿼리 키 값을 가져야 하는 이유는 무엇인가요?</summary>

리액트 쿼리에서 쿼리 키는 **캐시 저장소의 고유 식별자** 역할을 합니다.

1. 쿼리 키가 고유해야 전역적인 캐시 저장소에서 데이터를 정확히 찾아오거나 저장할 수 있습니다.
2. 키의 변화를 감지해 자동으로 데이터를 **리프레시**할 수 있습니다. (useEffect의 의존성 배열과 유사한 역할)
3. 특정 데이터를 **무효화(Invalidate)할 때** 정확한 대상을 타겟팅하기 위해 고유한 키 관리는 필수적입니다

</details>

<details>
<summary>고유한 키 관리를 위해서 어떤 전략을 사용하셨나요?</summary>

Query Key Factory 패턴을 사용했습니다.

1. 문자열 하드코딩을 방지해 오타나 키 중복으로 인한 캐싱 버그를 원천 차단할 수 있습니다.
2. 특정 데이터를 수정했을 때 해당 도메인의 관련 쿼리들만 **정교하게 무효화(Invalidation)**할 수 있어 효율적인 데이터 동기화가 가능했습니다

</details>

<details>
<summary>쿼리 키에 포함되는 변수가 객체일 때 순서가 바뀌면 리액트 쿼리는 어떻게 인식하나요?</summary>

리액트 쿼리는 객체 내부의 키 순서가 달라도 내용물이 같다면 "같은 키"로 인식합니다.

`['posts', { id: 1, type: 'admin' }] === ['posts', { type: 'admin', id: 1 }]`

리액트 쿼리는 내부적으로 쿼리 키를 저장할 때 '결정적 해시(Deterministic Hash)' 과정을 거칩니다.

</details>

<details>
<summary>결정적 해시에 대해 설명해주세요</summary>

리액트 쿼리 내부의 hashQueryKey라는 함수는 **키를 문자열로 직렬화(Serialize)할 때,** 객체의 키를 **알파벳순으로 정렬한 뒤** 변환합니다.

1. 사용자가 입력한 객체를 받습니다
2. 객체의 프로퍼티(Key)들을 알파벳 순으로 정렬합니다
3. 정렬된 상태로 문자열화(Stringify)합니다

따라서 작성 순서가 달라도 최종적인 '주소'는 동일하게 생성됩니다.

단, 배열 내 요소의 순서는 엄격하게 따집니다. ['a', 'b']와 ['b', 'a']는 서로 다른 키로 취급됩니다.

</details>

<details>
<summary>쿼리 키 내부 객체에 함수나 클래스 인스턴스가 들어가면 어떻게 되나요?</summary>

리액트 쿼리의 직렬화 과정은 JSON 기반이기 때문에 함수나 심볼(Symbol)처럼 직렬화할 수 없는 값은 무시되거나 에러가 발생할 수 있습니다. 따라서 쿼리 키에는 항상 **순수하게 직렬화 가능한 데이터(직합체, 원시값, 일반 객체)**만 포함시키는 것이 안전합니다.

</details>

### useQuery와 useMutation

<details>
<summary>useQuery와 useMutation의 차이점은 무엇인가요?</summary>

가장 큰 차이점은 조회한 데이터의 전역 캐시 저장소 저장 유무입니다. 이를 기준으로 동작 방식과 상태 관리가 달라집니다.

1. useQuery

- 주요 용도: 서버에서 데이터를 받아와 화면에 보여줄 때 사용합니다. (GET 요청)
- 캐싱 및 상태: 받아온 데이터를 캐시에 저장하고 키(Query Key)를 통해 관리합니다. 데이터 유무에 따라 isLoading(데이터 없음)과 isFetching(데이터 갱신 중) 상태가 구분됩니다.
- 자동화: 별도의 설정이 없으면 컴포넌트 마운트 시, 혹은 윈도우 포커스 시 자동으로 데이터를 불러옵니다 (Auto Refetching).
- 재시도 정책: 요청 실패 시 기본적으로 3번 재시도합니다.

2. useMutation

- 주요 용도: 서버의 데이터를 생성(Create), 수정(Update), 삭제(Delete)할 때 사용합니다. (POST, PUT, DELETE 요청)
- 캐싱 및 상태: 일회성 요청이므로 결과를 캐시에 저장하지 않습니다. 캐시 데이터 개념이 없으므로, 데이터 유무에 따른 isLoading 구분보다는 변이(Mutation)가 진행 중인지를 나타내는 상태(isFetching)가 주가 됩니다. (관련된 캐시 데이터가 없으므로 리페칭 개념도 없습니다.)
- 수동 제어: 자동으로 실행되지 않으며, 반환된 객체의 mutate 함수를 호출해야만 실행됩니다. (예: 버튼 클릭 핸들러 내부)
- 재시도 정책: 기본적으로 재시도(Retry)를 하지 않습니다. (설정으로 변경 가능)

</details>

<details>
<summary>useMutation은 데이터를 조회할 때도 사용할 수 있나요?</summary>

1. 보안상 캐싱이 되면 안 되는 경우 (일회성 조회)

- useQuery는 데이터를 가져오면 설정된 staleTime 동안 메모리에 데이터를 저장(캐싱)해 둡니다. 하지만 비밀번호 확인, 인증번호 요청 등의 특수한 상황에선 이런 기능이 적절하지 않을 수 있습니다.
- useMutation을 사용하면 응답 데이터가 React Query의 전역 캐시에 남지 않으므로 더 깔끔하게 처리할 수 있습니다.

2. 특정 조건(이벤트)에서만 실행해야 할 때

- useQuery도 enabled: false 옵션을 쓰면 수동 실행(refetch)이 가능하지만, 구조상 처음부터 '이벤트가 발생했을 때만 동작'하도록 설계된 useMutation이 더 직관적일 때가 많습니다.
- 예시: "검색" 버튼을 눌렀을 때만 API를 쏘고 싶거나, 특정 설문 문항을 다 채우고 "결과 보기"를 눌렀을 때만 데이터를 가져오는 경우입니다.

3. API 방식이 POST인 조회의 경우

- 어떤 API들은 데이터를 단순히 조회만 하는데도 보안상의 이유나 전달해야 할 파라미터가 너무 많아서 POST 메서드를 사용합니다.
- 공식적으로 useQuery도 POST를 쓸 수 있지만, 관습적으로 POST 요청은 useMutation과 더 잘 어울린다고 판단하여 사용하는 개발자들이 많습니다.

</details>

## 3. React Hook Form / Zod

<details>
<summary>React Hook Form이 비제어(Uncontrolled) 방식을 기반으로 성능을 최적화하는 원리는 무엇인가요?</summary>

React Hook Form은 input 값을 React의 state로 관리하지 않고, 브라우저의 DOM이 가진 기본 값 저장 방식을 그대로 활용합니다. 이 때문에 입력이 발생할 때마다 컴포넌트 전체가 리렌더링되지 않고, 오직 필요한 검증 단계에서만 React가 개입합니다.

또한 각 필드를 ref로 추적하기 때문에 업데이트 비용이 매우 낮아지고, 대규모 폼에서도 렌더링 성능이 안정적입니다.

이러한 구조 덕분에 React Hook Form은 React 폼 라이브러리 중에서도 뛰어난 성능을 제공합니다.

</details>

<details>
<summary>왜 React Hook Form과 Zod를 함께 사용하나요? 유효성 검사 스키마를 분리했을 때의 이점을 설명해 주세요.</summary>

React Hook Form은 폼 상태와 이벤트 처리를 담당하고, Zod는 입력값의 유효성을 스키마 기반으로 검증합니다.

이 둘을 분리하면 검증 로직이 UI와 섞이지 않아 유지보수가 쉬워지고, 검증 기준을 하나의 스키마로 통합할 수 있어 재사용성이 높아집니다.

또한 Zod는 런타임에 실제 값을 검증할 수 있기 때문에 타입스크립트의 컴파일 타임 검증이 놓치는 오류까지 잡을 수 있습니다.

</details>

<details>
<summary>Zod의 z.infer를 활용하여 스키마로부터 타입을 추출하고 이를 활용하는 방식의 장점은 무엇인가요?</summary>

z.infer를 사용하면 스키마 내용을 기반으로 타입을 자동 생성할 수 있습니다. 이를 통해 타입 정의를 중복으로 작성할 필요가 없고, 스키마가 변경되면 타입도 자동으로 업데이트되기 때문에 타입 불일치로 인한 버그를 줄일 수 있습니다.

</details>

<details>
<summary>폼 데이터를 서버로 전송하기 전, Zod 스키마를 통해 런타임에서 데이터를 검증하는 프로세스에 대해 설명해 주세요.</summary>

폼 제출 시 React Hook Form이 수집한 데이터를 Zod 스키마에 전달하면 Zod는 즉시 런타임에서 데이터를 검사합니다.

- 검증이 실패하면 어떤 필드가 잘못되었는지 명확한 에러 정보를 반환하고,
- 성공하면 스키마에 맞게 정제된 안전한 데이터가 반환됩니다.

이 정제된 데이터만 서버에 전송하기 때문에 클라이언트와 서버 모두에서 안정적인 데이터 처리가 가능해집니다.

</details>

## 4. 라우터 (React Router / Tanstack Router)

<details>
<summary>라우터는 왜 사용하나요?</summary>

SPA 환경에서는 페이지 이동 시 브라우저가 전체 HTML을 다시 로드하지 않기 때문에 화면 전환을 애플리케이션 내부에서 직접 제어해야 합니다.

라우터는 URL과 UI를 매핑해 사용자가 주소를 이동해도 각각에 대응하는 화면을 자연스럽게 전환해주는 역할을 합니다. 또한 뒤로 가기, 앞으로 가기, 동적 세그먼트, 보호된 라우트처럼 실제 웹 페이지가 제공하는 내비게이션 경험을 SPA에서도 동일하게 구현할 수 있도록 도와줍니다.

</details>

<details>
<summary>React Router와 TanStack Router의 가장 차이점은 무엇인가요?</summary>

- React Router는 오래된 생태계를 기반으로 발전해온 라우터로, 선언적 라우팅과 loader, action 같은 데이터 로딩 기능을 제공합니다.
- 반면 TanStack Router는 타입 안전성을 핵심 가치로 설계된 최신 라우터로, 라우트 선언부터 파라미터, loader, navigate까지 모든 흐름이 타입으로 강하게 보장됩니다. 특히 TanStack Query와 자연스럽게 통합되기 때문에 데이터 중심 개발을 할 때 더 강력한 개발 경험을 제공합니다.

</details>

<details>
<summary>React Router v6.4+에서 도입된 loader와 action의 역할은 무엇이며, UX 측면에서 어떤 이점이 있나요?</summary>

- loader는 라우트가 렌더링되기 전에 필요한 데이터를 먼저 가져오는 함수입니다. 이 방식은 화면이 데이터를 기다리며 비는 시간을 없애고, **데이터가 준비된 상태의 완성된 화면**을 바로 보여줄 수 있어 UX가 크게 개선됩니다.

- action은 폼 제출이나 리소스 변경 같은 mutation 작업을 라우트 단위에서 처리하도록 돕는 함수입니다. UI 컴포넌트에서 이 로직을 분리하기 때문에 흐름이 명확하고 관리가 쉬워집니다.

</details>

<details>
<summary>라우트 기반 코드 분할(Code Splitting)의 필요성과 이를 구현하기 위한 방식에 대해 설명해 주세요.
</summary>

SPA는 자바스크립트 번들이 커질수록 초기 로딩 속도가 느려지는 문제가 있습니다.

라우트 기반 코드 분할은 페이지별로 자바스크립트 코드를 분리하여 사용자가 실제로 방문한 페이지의 코드만 로드하도록 만드는 기술입니다. 이렇게 하면 초기 로딩 성능이 크게 개선되며, 사용자는 필요한 화면을 더 빠르게 확인할 수 있습니다.

구현 방식은 React의 lazy와 Suspense를 사용해 라우트 컴포넌트를 동적으로 import하는 방식이 일반적입니다.

</details>
