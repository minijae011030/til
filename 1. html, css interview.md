# HTML, CSS 면접 질문 리스트

## 1. HTML

<details>
<summary>⭐️ HTML이란 무엇인가요?</summary>

HTML은 웹 페이지의 구조와 의미를 정의하는 마크업 언어입니다. 텍스트, 이미지, 링크 같은 콘텐츠가 어떤 역할을 가지는지 브라우저와 검색엔진에 전달합니다.

</details>

<details>
<summary>⭐️ 시맨틱 마크업이란 무엇이고, 왜 중요한가요?</summary>

시맨틱 마크업은 태그가 가진 의미에 맞게 HTML 요소를 사용하는 것을 말합니다. 단순히 div로 구조를 나누는 것이 아니라 header, nav, section 같은 태그를 사용하면 문서의 구조와 의도가 명확해집니다. 이를 통해 검색엔진이 콘텐츠를 더 잘 이해할 수 있고, 스크린 리더를 사용하는 사용자에게도 접근성이 향상됩니다.

</details>

<details>
<summary>⭐️ 시맨틱 태그를 사용하면 어떤 장점이 있나요?</summary>

시맨틱 태그를 사용하면 검색엔진 최적화에 유리해지고, 웹 접근성이 향상됩니다. 또한 코드만 보아도 구조를 파악하기 쉬워 유지보수 측면에서도 장점이 있습니다.

</details>

<details>
<summary>⭐️ div 대신 section, article을 써야 하는 이유는 무엇인가요?</summary>

div는 의미 없는 컨테이너이기 때문에 문서 구조를 설명하지 못합니다. 반면 section이나 article은 해당 콘텐츠가 어떤 성격을 가지는지 명확히 표현할 수 있어 문서의 의미를 더 잘 전달할 수 있습니다.

</details>

<details>
<summary>meta 태그는 어떤 역할을 하나요?</summary>

meta 태그는 문서 자체에 대한 정보를 정의하는 태그로, 문자 인코딩, 뷰포트 설정, 검색엔진에 제공할 설명 같은 메타데이터를 브라우저와 검색엔진에 전달하는 역할을 합니다.

</details>

<details>
<summary>⭐️ viewport meta 태그는 왜 필요한가요?</summary>

viewport meta 태그는 모바일 환경에서 레이아웃의 기준이 되는 화면 크기를 설정하기 위해 필요합니다. 이 태그가 없으면 모바일에서도 데스크톱 기준으로 화면이 렌더링되어 반응형 레이아웃이 제대로 동작하지 않습니다.

</details>

<details>
<summary>⭐️ HTML 파싱 도중 JavaScript가 실행되면 왜 렌더링이 멈추나요?</summary>

브라우저는 JavaScript가 DOM을 변경할 수 있기 때문에, HTML 파싱 도중 script 태그를 만나면 파싱을 멈추고 JavaScript를 먼저 실행합니다. 이 과정에서 화면 렌더링이 지연되는데, 이를 렌더링 블로킹이라고 합니다.

</details>

<details>
<summary>⭐️ script 태그에서 async와 defer의 차이는 무엇인가요?</summary>

async는 스크립트를 다운로드한 즉시 실행하기 때문에 실행 순서가 보장되지 않습니다. 반면 defer는 HTML 파싱이 끝난 후 스크립트를 실행하며, 여러 스크립트가 있을 경우 선언된 순서대로 실행됩니다.

</details>

<details>
<summary>async와 defer 중 어떤 것을 더 많이 사용하고, 이유는 무엇인가요?</summary>

실무에서는 주로 defer를 사용합니다. DOM이 완전히 준비된 이후 실행이 보장되고, 스크립트 실행 순서를 예측할 수 있어 안정적인 동작이 가능하기 때문입니다.

</details>

## 2. CSS

<details>
<summary>⭐️ CSS의 역할은 무엇인가요?</summary>

CSS는 HTML로 정의된 구조에 스타일과 레이아웃을 적용하는 역할을 합니다. 구조와 표현을 분리함으로써 유지보수성과 재사용성을 높입니다.

</details>

<details>

<summary>⭐️ block, inline, inline-block의 차이는 무엇인가요?</summary>

block 요소는 한 줄 전체를 차지하며 자동으로 줄바꿈이 발생하고, width와 height 같은 크기 지정이 가능합니다. 대표적으로 div가 있습니다.

inline 요소는 콘텐츠 크기만큼만 차지하고 줄바꿈이 발생하지 않으며, width와 height를 직접 지정할 수 없습니다. 대표적으로 span이 있습니다.

inline-block 요소는 inline 요소처럼 한 줄에 나란히 배치되지만, block 요소처럼 width와 height, margin, padding을 모두 지정할 수 있는 요소입니다.
대표적으로 img, button 같은 요소가 있으며, 가로로 배치하면서 크기 조절이 필요한 경우에 사용됩니다.

</details>

<details>

<summary>display: none과 visibility: hidden의 차이는 무엇인가요?</summary>

display: none은 요소를 렌더 트리에서 완전히 제거하기 때문에 레이아웃에서 사라지고, 해당 요소와 관련된 리플로우가 발생합니다.
그래서 다시 display 값을 변경하면 레이아웃 계산부터 다시 해야 해 비용이 더 큽니다.

반면 visibility: hidden은 요소가 렌더 트리에 남아 있어 레이아웃 공간은 그대로 유지되고, 화면에만 보이지 않게 처리됩니다.
이 경우 레이아웃 계산은 발생하지 않고 리페인트만 발생합니다.

</details>

<details>

<summary>⭐️ position 속성들의 차이를 설명해주세요.</summary>

static은 기본 흐름에 따라 배치

relative는 자신의 원래 위치를 기준으로 이동

absolute는 가장 가까운 위치 지정 부모를 기준으로 배치

fixed는 뷰포트 기준으로 고정

sticky는 스크롤 위치에 따라 relative와 fixed처럼 동작

</details>

<details>

<summary>⭐️ absolute 요소의 기준은 어떻게 결정되나요?</summary>

absolute 요소는 가장 가까운 position 속성이 지정된 부모 요소를 기준으로 위치가 결정되며, 그런 부모가 없을 경우 뷰포트를 기준으로 배치됩니다.

</details>

<details>

<summary>fixed와 sticky의 차이는 무엇인가요?</summary>

fixed는 항상 뷰포트를 기준으로 고정되는 반면, sticky는 특정 스크롤 위치에 도달하기 전까지는 일반 흐름을 따르다가 이후 고정됩니다.

</details>

<details>

<summary>⭐️ margin과 padding의 차이는 무엇인가요?</summary>

margin은 요소 바깥의 여백을 조절하고, padding은 요소 내부 콘텐츠와 테두리 사이의 여백을 조절합니다.

</details>

<details>

<summary>⭐️ CSS 선택자 우선순위는 어떻게 결정되나요?</summary>

!important가 가장 우선이며, 

그 다음으로 인라인 스타일, 

ID 선택자, 

클래스 선택자, 

태그 선택자 순으로 적용됩니다. 

동일한 우선순위일 경우 나중에 선언된 스타일이 적용됩니다.

</details>

<details>

<summary>z-index는 언제 동작하지 않나요?</summary>

z-index는 position이 지정되지 않았거나, 서로 다른 stacking context에 속한 요소 간에는 기대한 대로 동작하지 않을 수 있습니다.

</details>

<details>

<summary>⭐️ stacking context란 무엇인가요?</summary>

stacking context는 z-index가 독립적으로 계산되는 레이어 공간을 의미합니다. 새로운 stacking context가 생성되면 그 내부 요소들은 외부 요소와 직접적인 z-index 비교가 되지 않습니다.

</details>

<details>

<summary>CSS 애니메이션과 JS 애니메이션의 차이는 무엇인가요?</summary>

CSS 애니메이션은 선언적으로 작성할 수 있어 간단하고 성능이 좋으며, JavaScript 애니메이션은 복잡한 조건이나 동적인 제어가 필요한 경우에 유리합니다.

</details>

<details>

<summary>⭐️ 성능 관점에서 CSS 애니메이션이 유리한 이유는 무엇인가요?</summary>

transform과 opacity 기반의 CSS 애니메이션은 리플로우 없이 GPU 가속으로 처리되기 때문에 성능 면에서 유리합니다.

</details>

## 3. 반응형 웹

<details>
<summary>⭐️ 반응형 웹이란 무엇인가요?</summary>

반응형 웹은 다양한 화면 크기와 해상도에 따라 레이아웃과 스타일이 유연하게 변하도록 설계된 웹 디자인 방식입니다.

</details>

<details>
<summary>⭐️ px, em, rem의 차이는 무엇인가요?</summary>

px은 고정 단위이고, em은 부모 요소의 폰트 크기를 기준으로 하며, rem은 루트 요소의 폰트 크기를 기준으로 합니다.

</details>

<details>
<summary>⭐️ rem이 반응형에서 선호되는 이유는 무엇인가요?</summary>

rem은 기준이 html 요소 하나로 고정되어 있어 전체 스케일을 일관되게 조절할 수 있기 때문에 반응형 구현에 유리합니다.

</details>

<details>
<summary>vw, vh 단위는 어떤 경우에 사용하나요?</summary>
vw와 vh는 화면 크기에 비례하는 단위로, 풀스크린 레이아웃이나 화면 비율을 유지해야 하는 UI에 사용됩니다.

</details>

<details>
<summary>⭐️ flex와 grid 중 반응형 레이아웃에 더 적합한 것은 무엇인가요?</summary>

flex는 1차원 레이아웃에 적합하고, grid는 행과 열을 동시에 다루는 2차원 레이아웃에 적합해 복잡한 반응형 구조에서는 grid가 더 유리합니다.

</details>

<details>
<summary>⭐️ 크로스 브라우징이란 무엇인가요?</summary>

크로스 브라우징은 브라우저마다 다른 렌더링 차이를 고려해 모든 주요 브라우저에서 동일한 사용자 경험을 제공하는 것을 의미합니다.

</details>

<details>
<summary>크로스 브라우징을 위해 어떤 방법을 사용하나요?</summary>

CSS Reset이나 Normalize를 적용하고, 필요에 따라 Polyfill을 사용하며, 다양한 브라우저에서 테스트를 진행합니다.

</details>

## 4. Tailwind CSS

<details>
<summary>⭐️ Tailwind CSS란 무엇인가요?</summary>

Tailwind CSS는 미리 정의된 유틸리티 클래스를 조합해 스타일을 구성하는 유틸리티 기반 CSS 프레임워크입니다.

</details>

<details>
<summary>⭐️ Tailwind CSS의 장점과 단점은 무엇인가요?</summary>

빠른 개발과 스타일 일관성이 장점이며, 클래스가 길어질 수 있고 초기에 가독성이 떨어질 수 있다는 단점이 있습니다.

</details>

<details>
<summary>Tailwind CSS를 사용하면 유지보수가 쉬워지는 이유는 무엇인가요?</summary>

컴포넌트 단위로 스타일이 명확히 분리되고, 전역 CSS 관리가 줄어들기 때문에 유지보수가 쉬워집니다.

</details>

<details>
<summary>클래스가 길어지는 문제는 어떻게 관리하나요?</summary>

컴포넌트 분리, 공통 UI 컴포넌트화, clsx 같은 유틸을 사용해 관리합니다.

</details>

<details>
<summary>⭐️ Tailwind CSS에서 반응형은 어떻게 구현하나요?</summary>

sm, md, lg 같은 반응형 프리픽스를 사용해 뷰포트 크기별 스타일을 적용합니다.

</details>

<details>
<summary>sm, md, lg 같은 프리픽스는 내부적으로 무엇을 의미하나요?</summary>

미디어 쿼리 기반의 최소 너비 기준 브레이크포인트를 의미합니다.

</details>

<details>
<summary>Tailwind CSS는 언제 쓰는 게 적합하고, 언제 부적합한가요?</summary>

빠른 UI 개발과 디자인 시스템이 필요한 프로젝트에 적합하며, 매우 세밀한 커스텀 스타일이 필요한 경우에는 부적합할 수 있습니다.

</details>
