## 리액트

## 1. React 기본 개념

### ⭐ React란 무엇인가

사용자 인터페이스(UI)를 만들기 위한 자바스크립트 라이브러리입니다.
컴포넌트 단위로 UI를 구성하며, 상태 변화에 따라 UI를 다시 렌더링하는 방식으로 동작합니다.

### ⭐ React의 특징과 장단점

특징

- 컴포넌트 기반
- 선언형 UI
- Virtual DOM 사용

장점

- UI 재사용성
- 유지보수 용이
- 대규모 애플리케이션에 적합

단점

- 초기 학습 비용
- 상태 관리 복잡성 증가 가능

### ⭐ JSX란 무엇인가

JavaScript 안에서 HTML과 유사한 문법을 사용할 수 있게 해주는 문법입니다.
실제로는 Babel을 통해 React.createElement로 변환되어 실행됩니다.

### ⭐ 엘리먼트와 컴포넌트의 차이

- 엘리먼트
  - 화면에 그려질 UI의 최소 단위
  - 불변 객체
- 컴포넌트
  - 엘리먼트를 반환하는 함수 또는 클래스

### ⭐ Fiber

React의 렌더링 엔진입니다.
렌더링 작업을 작은 단위로 쪼개고, 우선순위를 두어 중단·재개 가능한 비동기 렌더링을 가능하게 합니다.

### ⭐ Virtual DOM이란

실제 DOM을 직접 조작하지 않고,
메모리 상에 가상 DOM 트리를 만들어 변경 사항을 비교하기 위한 구조입니다.

### ⭐ Virtual DOM 작동 원리

- state 변경
- 새로운 Virtual DOM 생성
- 이전 Virtual DOM과 비교(diffing)
- 변경된 부분만 실제 DOM에 반영

→ 불필요한 DOM 조작 최소화

## 3. 컴포넌트

### ⭐ 리액트에서 컴포넌트 생성 방법

함수 또는 클래스로 컴포넌트를 정의하고 JSX를 반환합니다.
현재는 함수형 컴포넌트 사용이 권장됩니다.

### ⭐ 함수형 컴포넌트 vs 클래스형 컴포넌트

- 함수형
  - Hooks 사용
  - 코드 간결
- 클래스형
  - this 사용
  - 라이프사이클 메소드 사용

### ⭐ 함수형 컴포넌트의 장점

- 코드가 간결함
- this 바인딩 문제 없음
- Hooks로 로직 재사용 가능

## 4. Hooks

### ⭐ React Hooks란

함수형 컴포넌트에서 state와 생명주기 기능을 사용할 수 있게 해주는 API입니다.
use로 시작하며, 호출 규칙이 존재합니다.

### ⭐ useState

컴포넌트의 상태를 관리하기 위한 Hook입니다.
상태 변경 시 컴포넌트가 리렌더링됩니다.

### ⭐ useEffect

렌더링 이후 실행되는 부수 효과 처리용 Hook입니다.
데이터 패칭, 이벤트 등록, 타이머 등에 사용됩니다.

### ⭐ useRef

- DOM 요소 직접 접근
- 값 변경 시 리렌더링 ❌
- 이전 값 저장 용도로도 사용

### ⭐ useEffect와 라이프사이클 대응

- [] : componentDidMount
- [deps] : componentDidUpdate
- return : componentWillUnmount

### ⭐ useEffect vs useLayoutEffect

- useEffect
  - 비동기
  - 화면 페인트 이후 실행
- useLayoutEffect
  - 동기
  - DOM 변경 직후 실행
    → DOM 크기 측정 시 사용

## 5. State & Props

### ⭐ State란

컴포넌트 내부에서 관리되는 데이터입니다.
값이 변경되면 컴포넌트가 다시 렌더링됩니다.

### ⭐ Props란

부모 컴포넌트가 자식 컴포넌트에 전달하는 데이터입니다.
읽기 전용이며 자식에서 직접 변경할 수 없습니다.

### ⭐ Props와 State의 차이

- Props
  - 외부에서 전달
  - 불변
- State
  - 내부에서 관리
  - 변경 가능

### ⭐ State를 직접 수정하지 않는 이유

React는 참조 변경 여부로 상태 변화를 감지합니다.
직접 수정하면 변경을 감지하지 못해 렌더링이 일어나지 않을 수 있습니다.

### ⭐ React는 상태 변화를 어떻게 감지하는가

이전 state와 새로운 state의 참조값 비교를 통해 감지합니다.
그래서 불변성을 유지해야 합니다.

### ⭐ State 불변성 유지 방법

- spread 연산자
- 배열 메서드(map, filter)
- 객체 복사 후 수정

### ⭐ setState는 동기/비동기?

비동기적으로 동작

여러 상태 변경을 **배치 처리(batch)**하여
불필요한 렌더링을 줄이고 성능을 최적화하기 위함

## 6. 데이터 흐름

### ⭐ 단방향 데이터 흐름

데이터는 부모 → 자식 방향으로만 전달됩니다.
상태 추적이 쉽고 예측 가능한 구조를 만듭니다.

### ⭐ 자식 → 부모 데이터 전달 가능 여부

직접 전달은 불가능하며,
부모에서 함수를 props로 내려 호출하는 방식으로 전달합니다.

### ⭐ Props Drilling이란

여러 단계의 컴포넌트를 거쳐
불필요하게 props를 전달하는 문제입니다.

### ⭐ Props Drilling 해결 방법

- Context API
- 전역 상태 관리 라이브러리

## 7. 이벤트 & Form

### ⭐ HTML vs React 이벤트 차이

React는 Synthetic Event를 사용합니다.
브라우저 간 이벤트 차이를 추상화합니다.

### ⭐ Form 이벤트 제어 방식

입력 값을 state로 관리하며
onChange 이벤트로 상태를 갱신합니다.

### ⭐ 제어 컴포넌트 vs 비제어 컴포넌트

- 제어 컴포넌트
  - state로 값 관리
- 비제어 컴포넌트
  - ref로 DOM 접근

### ⭐ useRef의 실제 사용 사례

- input focus 제어
- 이전 값 저장
- setTimeout, interval id 저장

## 8. 렌더링 최적화 & 성능

### ⭐ Key props를 사용하는 이유

리스트 렌더링 시 각 요소를 고유하게 식별하기 위해 사용합니다.
React는 key를 기준으로 이전 Fiber 트리와 새로운 Fiber 트리를 비교해
어떤 요소를 재사용하고, 어떤 요소를 새로 생성할지 판단합니다.

key가 없거나 index를 사용할 경우,
Fiber가 요소의 변경을 정확히 추적하지 못해
불필요한 재렌더링이나 상태 꼬임이 발생할 수 있습니다.

### ⭐ 메모이제이션이란

이미 계산된 결과를 저장해
불필요한 연산이나 렌더링을 방지하는 기법입니다.

### ⭐ useMemo

값을 메모이제이션합니다.
연산 비용이 큰 계산 결과 캐싱에 사용됩니다.

### ⭐ useCallback

함수를 메모이제이션합니다.
불필요한 함수 재생성을 방지합니다.

### ⭐ React.memo

컴포넌트를 메모이제이션합니다.
props가 변경되지 않으면 리렌더링을 방지합니다.

### ⭐ useMemo vs React.memo

- useMemo
  - 값 캐싱
- React.memo
  - 컴포넌트 캐싱

## 9. 전역 처리 / 고급 개념

### ⭐ Context API

props 없이
전역 데이터를 컴포넌트 트리 전체에 공유할 수 있는 기능입니다.

### ⭐ Portal

컴포넌트를 DOM 트리 외부에 렌더링할 수 있는 기능입니다.
모달, 툴팁 구현에 사용됩니다.

### ⭐ Error Boundary

하위 컴포넌트에서 발생한 에러를
잡아서 UI가 전체적으로 깨지는 것을 방지합니다.

## 10. 데이터 패칭

### ⭐ React Query란

서버 상태를 관리하기 위한 라이브러리입니다.
데이터 패칭, 캐싱, 로딩·에러 상태를 자동으로 관리합니다.

### ⭐ 등장 배경

- 서버 상태와 클라이언트 상태 분리
- 반복되는 비동기 로직 문제 해결

### ⭐ React Query의 장점

- 자동 캐싱
- 재요청 관리
- 로딩/에러 상태 관리 간소화

## 11. React 18 주요 변경

### ⭐ React 18 주요 변경

- automatic batching
- concurrent rendering 개념 도입
- useTransition, useDeferredValue
