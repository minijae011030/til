# TypeScript 면접 질문 리스트

## 1. TypeScript 개요

<details>
<summary>⭐️ TypeScript는 무엇이며 JavaScript와 어떤 관계인가요?</summary>

TypeScript는 JavaScript에 정적 타입 시스템을 추가한 상위 집합 언어입니다.
JavaScript 문법을 그대로 사용하면서, 컴파일 단계에서 타입 검사를 통해 오류를 사전에 발견할 수 있도록 도와줍니다.

✅ 정적 타입

</details>

<details>
<summary>⭐️ TypeScript를 사용하는 이유는 무엇인가요?</summary>

1. 안정성: 컴파일 타임에 타입 오류를 잡을 수 있습니다.
2. 개발 생산성: 코드 자동 완성, 리팩토링, 가독성 측면에서 개발 생산성이 향상됩니다.
3. 유지보수: 규모가 커질수록 타입스크립트를 사용하면 유리합니다.

✅ 컴파일 타임

</details>

<details>
<summary>⭐️ 런타임 에러와 컴파일 타임 에러의 차이는 무엇인가요?</summary>

- 컴파일 타임 에러는 코드를 실행하기 전에 발생하는 오류로, TypeScript의 타입 오류가 이에 해당합니다.
- 반면 런타임 에러는 코드 실행 중에 발생하며, JavaScript에서 주로 발생합니다.

</details>

<details>
<summary>⭐️ TypeScript는 왜 컴파일 언어라고 하나요?</summary>

TypeScript는 브라우저에서 직접 실행되지 않기 때문에, JavaScript로 변환하는 컴파일 과정이 필요합니다. 이 과정에서 타입 검사가 수행되기 때문에 컴파일 언어라고 부릅니다.

TypeScript의 타입 정보는 컴파일 후 모두 제거되고, 결과물인 JavaScript 코드에는 타입 정보가 남지 않습니다. 타입은 오직 개발 단계에서만 사용됩니다.

</details>
<details>
<summary>동적 타입과 정적 타입 언어의 차이점은 무엇인가요?</summary>

- 자바스크립트는 동적 타입 언어입니다. 변수를 선언할 때 타입을 지정하지 않고, 코드가 실행될때(런타임)에 할당되는 값에 따라 타입이 정해집니다.
- 반면에 타입스크립트는 정적 타입 언어입니다. 코드를 작성하거나 컴파일타임 시점에서 타입을 결정하고, 타입 오류를 잡아줍니다.

</details>
<details>
<summary>컴파일과 트랜스파일의 차이점에 대해 아시나요?</summary>

- 컴파일은 한 언어의 소스코드를 다른 언어로 바꾸는 과정을 의미합니다. 주로 고수준에서 저수준 언어로 바꾸는 과정입니다. (C++ -> 기계어)
- 트랜스파일은 고수준 언어를 비슷한 수준의 다른 고수준 언어로 바꾸는 특수한 형태의 컴파일입니다. (TS -> JS, ES6 -> ES5)

즉, 타입스크립트의 컴파일 과정은 엄밀히 말하면 트랜스파일이라고 할 수 있습니다.

</details>
<details>
<summary>tsconfig.json에 대해 알고있나요?</summary>

타입스크립트 프로젝트의 루트 디렉토리에 위치하며, 타입스크립트 컴파일러가 자바스크립트로 코드를 변환 할 때 어떤 규칙을 따를지 결정하는 설정 파일입니다.

사용하는 이유는 다음과 같습니다.

1. 일관성: 여러 개발자가 협업할 때 모두가 동일한 규칙을 사용하여 코드를 작성할 수 있습니다.
2. 호환성: 프로젝트가 오래된 브라우저를 지원해야 한다면 설정에 target을 ES5로 설정하여 호환성을 지원할 수 있습니다.
3. 최적화: 필요한 파일만 컴파일 하도록 설정하여 빌드 속도를 높일 수 있습니다.

strict 모드에서는 타입이 any가 되는 것을 방지하거나 null과 undefined 값을 엄격하게 다루도록 여러 규칙을 설정할 수 있습니다.

✅ 루트 디렉토리, 규칙, 일관성, 호환성, 최적화, strict 모드

</details>

## 2. type vs interface

<details>
<summary>⭐️ type과 interface의 차이는 무엇인가요?</summary>

둘 다 객체 타입을 정의할 수 있다는 공통점이 있습니다.

차이점은

- interface: 확장과 선언병합이 가능하여 객체 구조를 정의하고 확장이 필요할 때 적합합니다.
- type: 유니온, 인터섹션 등 다양한 타입 표현이 가능하므로 복잡한 타입 조합이 필요한 경우에 적합합니다.

</details>

<details>
<summary>interface의 선언 병합이란 무엇인가요?</summary>

같은 이름의 interface를 여러 번 선언하면 TypeScript가 이를 자동으로 병합하는 기능입니다. 주로 라이브러리 타입 확장에 사용됩니다.

</details>

<details>
<summary>⭐️ enum과 union literal의 차이는 무엇인가요?</summary>

- enum은 컴파일 후에도 JavaScript 코드로 남지만,
- union literal 타입은 타입 수준에서만 존재하고 런타임 코드가 생성되지 않습니다.

enum은 런타임 코드를 생성하기 때문에 번들 크기가 증가할 수 있기 때문에 union literal을 더 선호합니다.

</details>

## 3. 타입 추론 & Narrowing

<details>
<summary>⭐️ 타입 추론(Type Inference)이란 무엇인가요?</summary>

TypeScript가 변수나 함수의 값을 기반으로 자동으로 타입을 추론하는 기능입니다. 명시적으로 타입을 작성하지 않아도 타입 안정성을 유지할 수 있습니다.

공개 API, 함수 반환 타입, 복잡한 객체 구조 등에서는 의도를 명확히 하기 위해 타입을 명시하는 것이 좋습니다.

</details>

<details>
<summary>⭐️ Union Type이란 무엇인가요?</summary>

Union Type은 하나의 값이 여러 타입 중 하나가 될 수 있음을 표현하는 타입입니다. 이를 통해 함수나 변수에서 다양한 입력을 허용하면서도 타입 안정성을 유지할 수 있습니다.

```ts
function printId(id: string | number) {
  console.log(id);
}
```

</details>

<details>
<summary>⭐️ Narrowing이란 무엇인가요?</summary>

Narrowing은 Union Type처럼 여러 타입이 가능한 값에 대해 조건문을 사용해 실제 타입을 하나로 좁혀, TypeScript가 해당 범위 안에서는 더 구체적인 타입으로 인식하도록 하는 과정입니다.

```ts
function printLength(x: string | string[]) {
  if (typeof x === "string") {
    console.log(x.length); // string으로 좁혀짐
  } else {
    console.log(x.length); // string[]으로 좁혀짐
  }
}
```

</details>

<details>
<summary>⭐️ never 타입은 무엇이며 언제 사용하나요?</summary>

never는 절대 발생할 수 없는 값의 타입을 의미합니다. 주로 switch 문에서 모든 경우를 처리했는지 확인하는 exhaustive check에 사용됩니다.

```ts
type Shape = "circle" | "square";

function handleShape(shape: Shape) {
  switch (shape) {
    case "circle":
      return 1;
    case "square":
      return 2;
    default:
      const _exhaustive: never = shape; // 모든 경우가 처리되었는지 체크
      return _exhaustive;
  }
}
```

</details>

<details>
<summary>exhaustive check는 왜 필요한가요?</summary>

모든 경우를 처리하지 않았을 때 컴파일 에러를 발생시켜 로직 누락을 방지하기 위해 사용합니다.

✅ 모든 경우, 컴파일 에러, 로직 누락 방지

</details>

## 4. 제네릭 & 유틸리티 타입

<details>
<summary>⭐️ 제네릭(Generic)이란 무엇인가요?</summary>

타입을 매개변수처럼 전달하여, 다양한 타입에 대해 재사용 가능한 코드를 작성할 수 있게 해주는 기능입니다.

타입 안정성을 유지하면서 중복 코드를 줄이고, 유연한 함수나 컴포넌트를 만들 수 있기 때문에 사용합니다.

제네릭이 없으면 any를 사용하게 되어 타입 안정성이 떨어지고, 의도하지 않은 타입 오류를 컴파일 단계에서 잡을 수 없습니다.

✅ 매개변수, 재사용성

</details>

<details>
<summary>⭐️ Partial과 Required는 언제 사용하나요?</summary>

- Partial은 객체 타입의 모든 속성을 선택적으로 만들어, 일부 값만 가진 객체를 허용해야 할 때 사용합니다.
- 반대로 Required는 선택 속성으로 정의된 타입을 모두 필수로 바꾸고 싶을 때 사용하며, 객체가 반드시 모든 값을 가져야 하는 시점을 명확히 하고 싶을 때 사용합니다.

</details>

<details>
<summary>⭐️ Pick과 Omit의 차이는 무엇인가요?</summary>

- Pick은 기존 타입에서 필요한 속성만 선택해 새로운 타입을 만들 때 사용합니다.
- 반면 Omit은 기존 타입에서 특정 속성만 제외하고 나머지를 모두 사용하는 방식입니다.

두 타입 모두 기존 타입을 재사용하면서 중복 정의를 줄이고, 의도를 명확히 하기 위해 사용됩니다.

</details>

<details>
<summary>⭐️ Readonly는 언제 유용한가요?</summary>

객체가 변경되면 안 되는 경우에 사용하며, 불변성을 보장하고 의도치 않은 수정 방지에 도움이 됩니다.

</details>

## 5. 객체 & 클래스 타입

<details>
<summary>⭐️ readonly는 무엇이며 왜 사용하나요?</summary>

readonly는 해당 속성을 읽기 전용으로 만들어 변경을 막는 키워드입니다. 객체의 불변성을 보장하기 위해 사용합니다.

</details>

<details>
<summary>⭐️ readonly와 const의 차이는 무엇인가요?</summary>

const는 변수 재할당을 막고, readonly는 객체의 속성 변경을 막습니다.

- const는 변수 바인딩을 고정하지만 객체의 내부 속성은 자유롭게 변경할 수 있습니다.
- readonly는 객체의 특정 프로퍼티 값은 변경할 수 없도록 만들지만 변수 자체의 재할당은 가능합니다.

✅ 재할당, 프로퍼티 변경

</details>

<details>
<summary>⭐️ readonly(키워드)와 Readonly(유틸리티 타입)의 차이는 무엇인가요?
</summary>

- readonly는 특정 프로퍼티 앞에 붙여 그 프로퍼티만 읽기 전용으로 만드는 키워드이고,

  ```ts
  type User = {
    readonly name: string;
    age: number;
  };

  const u: User = { name: "min", age: 24 };
  u.name = "lee"; // ❌ 오류 — name은 readonly
  u.age = 25; // ⭕ 변경 가능
  ```

- Readonly는 타입 전체의 모든 프로퍼티를 자동으로 readonly로 바꿔주는 유틸리티 타입입니다.

  ```ts
  type A = {
    info: { x: number }
  }

  const a: Readonly<A> = { info: { x: 1 } };
  a.info = ...   // ❌ info 자체는 변경 불가
  a.info.x = 2;  // ⭕ 내부 값 변경은 가능
  ```

둘 다 얕은(shallow) 불변만 제공하며, 중첩 객체까지는 readonly로 만들지 않습니다.

</details>
<details>
<summary>Optional Property(?)는 언제 사용하나요?</summary>

객체 생성 시 있어도 되고 없어도 되는 속성을 표현할 때 사용합니다.

</details>

<details>
<summary>⭐️ public / private / protected의 차이는 무엇인가요?</summary>

- public은 클래스 외부를 포함해 어디에서든 접근할 수 있는 접근 제어자로, 기본값이기도 합니다.
- private는 해당 클래스 내부에서만 접근이 가능하며, 내부 구현을 숨기는 데 사용됩니다.
- protected는 클래스 내부에서는 물론, 해당 클래스를 상속받은 자식 클래스에서도 접근할 수 있어 상속 구조에서 공통 로직을 공유할 때 주로 사용됩니다.

</details>

<details>
<summary>protected는 private과 어떤 점이 다른가요?</summary>

protected는 상속 관계에서 접근이 가능하지만, private는 클래스 내부에서만 접근 가능합니다.

</details>

## 6. extends vs implements

<details>
<summary>⭐️ extends와 implements의 차이는 무엇인가요?</summary>

- extends는 기존 타입이나 클래스의 기능/구조를 물려받아 확장하는 개념이고,
- implements는 클래스가 특정 인터페이스의 형태를 반드시 만족하도록 강제하는 개념입니다.

</details>

<details>
<summary>클래스에서 extends는 무엇을 의미하나요?</summary>

클래스에서 extends는 부모 클래스의 필드와 메서드를 상속받아 자식 클래스에서 그대로 사용하거나 오버라이드해서 동작을 확장하는 것을 의미합니다.

```ts
class Animal {
  speak() {
    console.log("sound");
  }
}

class Dog extends Animal {
  speak() {
    console.log("bark");
  }
}

const d = new Dog();
d.speak(); // "bark"
```

</details>

<details>
<summary>interface에서 extends는 어떤 의미인가요?</summary>

interface에서 extends는 다른 인터페이스의 프로퍼티/메서드 시그니처를 그대로 가져와 합쳐서 더 큰 형태의 타입을 만드는 것입니다.

```ts
interface Animal {
  name: string;
}

interface Dog extends Animal {
  bark: () => void;
}

const d: Dog = {
  name: "Mango",
  bark() {
    console.log("bark");
  },
};
```

</details>

<details>
<summary>⭐️ implements는 무엇을 강제하나요?</summary>

implements는 클래스가 해당 인터페이스에 정의된 프로퍼티와 메서드를 빠짐없이 구현하도록 컴파일 단계에서 강제합니다. 실제 로직 구현은 개발자가 클래스 내부에서 직접 작성해야 합니다.

</details>

<details>
<summary>⭐️ 상속(extends)과 구현(implements)의 목적 차이는 무엇인가요?</summary>

- 상속은 이미 존재하는 기능을 재사용하면서 일부를 변경하거나 추가해 확장하는 목적이 크고,
- 구현은 이 클래스는 이런 형태의 API를 반드시 제공한다라는 계약을 지키게 해서 설계를 일관되게 만드는 목적이 큽니다.

</details>

## 7. 타입 안전성

<details>
<summary>⭐️ 타입 단언(Type Assertion)이란 무엇인가요?</summary>

개발자가 TypeScript에게 이 값의 타입을 내가 확실히 안다고 알려주는 방법입니다.
타입 단언을 남용하면 타입 검사를 우회하게 되어, 런타임 에러가 발생할 가능성이 높아집니다.

</details>

<details>
<summary>⭐️ any와 unknown의 차이는 무엇인가요?</summary>

any는 모든 타입을 허용하지만, unknown은 사용 전에 타입 검사를 강제합니다. unknown은 바로 사용할 수 없기 때문에 타입 체크를 통해 안전성을 확보할 수 있습니다.

</details>

<details>
<summary>unknown 값을 사용하려면 왜 타입 체크가 필요한가요?</summary>

컴파일러가 타입을 보장하지 않기 때문에, 명시적인 narrowing 없이는 사용할 수 없도록 설계되어 있습니다.

</details>
