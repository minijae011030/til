# JavaScript 면접 질문 리스트

## 1. 자바스크립트 개요

<details>
<summary>⭐️ 자바스크립트는 어떤 언어인가요?</summary>

자바스크립트는 웹 브라우저에서 동작하는 인터프리터 기반의 프로그래밍 언어로, 웹 페이지에 동적인 동작과 사용자 상호작용을 구현하기 위해 사용됩니다. 현재는 브라우저뿐만 아니라 서버(Node.js)와 다양한 환경에서도 사용되고 있습니다.

✅ 웹, 인터프리터, 동적인 동작, 사용자와 상호작용, 서버

</details>

<details>
<summary>⭐️ 자바스크립트가 동적 타입 언어라는 말은 무슨 뜻인가요?</summary>

자바스크립트는 변수에 타입을 미리 선언하지 않고, 런타임에 값이 할당될 때 타입이 결정되는 언어입니다. 이로 인해 유연한 코드 작성이 가능하지만, 타입 관련 오류가 런타임에 발생할 수 있다는 단점도 있습니다.

✅ 변수, 런타임, 유연성, 타입 오류

</details>

<details>
<summary>⭐️ 자바스크립트가 싱글 스레드인데 비동기가 가능한 이유는 무엇인가요?</summary>

자바스크립트는 싱글 스레드로 동작하지만, 이벤트 루프와 브라우저 또는 런타임 환경이 제공하는 Web API를 통해 비동기 처리가 가능합니다. 시간이 오래 걸리는 작업은 별도의 영역에서 처리하고, 완료된 작업만 다시 메인 스레드로 전달하는 방식으로 동작합니다.

✅ 이벤트 루프, 브라우저, 런타임 환경, Web API

</details>
<details>
<summary>인터프리터 언어란 무엇인가요?</summary>
  
프로그램이 실행되는 시점에 코드를 한 줄씩(또는 블록 단위)로 읽어서 바로 실행하는 언어를 말합니다.

컴파일 언어(C, Java)는 소스코드 전체를 미리 번역하여 실행하는 반면, 인터프리터 언어(JS, Python)는 한 줄씩 번역하여 실행합니다 (번역과 통역)

✅ 실행, 한 줄씩, 번역

</details>

<details>
<summary>인터프리터 언어의 특징은 무엇인가요?</summary>
  
1. **빌드 과정이 없습니다**: 코드를 수정하고 저장하면 브라우저에서 결과가 바로 반영됩니다. 컴파일 과정이 없어서 개발 사이클이 매우 빠릅니다.
2. **실행 속도와 시작 속도**: 컴파일 언어보다는 실행 속도가 느릴 수 있지만, 빌드 시간 없이 즉시 실행되므로 초기 시작 속도는 빠릅니다
3. **플랫폼 독립성**: 소스 코드 그대로 전달되기 때문에 인터프리터만 있으면 어디서든 똑같이 작동합니다

✅ 빌드, 컴파일, 빠름, 실행 속도, 시작 속도, 플랫폼 독립성, 소스 코드, 인터프리터

</details>

<details>
<summary>JIT 컴파일러에 대해서 아시나요?</summary>
  
V8 엔진(Chrome, Node.js) 같은 현대적인 자바스크립트 엔진은 Just-In-Time 컴파일 방식을 사용합니다. 기본적으로 인터프리터처럼 한 줄씩 실행하지만, 자주 반복되는 코드(Hot spot)는 실행 중에 즉석에서 기계어로 컴파일하여 성능을 최적화합니다.

✅ V8, 인터프리터, Hot spot, 컴파일

</details>
<details>
<summary>V8 엔진은 무엇인가요?</summary>
  
구글이 개발한 오픈 소스 자바스크립트 엔진입니다. V8이 등장한 이후로 자바스크립트의 실행 속도가 비약적으로 상승했으며, 서버 환경에서도 쓸 수 있게 됐습니다. 인터프리터와 컴파일 방식을 혼합하여 작동합니다.

작동 원리는 다음과 같습니다.

1. 인터프리터: 빠른 실행 속도를 확보하기 위해 **인터프리터 방식으로 바로 실행**합니다.
2. 프로파일링: 코드가 실행되는 동안 엔진은 **어떤 코드가 주로 쓰이는지 확인**합니다.
3. 터보팬 컴파일러: **자주 쓰인다고 판단되는 코드는 기계어로 컴파일하여 저장**합니다.
4. 실행: 다음에도 같은 코드가 호출되면 **컴파일러로 번역해둔 기계어를 즉시 실행**합니다.

✅ 구글, 오픈 소스, 서버 환경, 실행속도, 인터프리터 컴파일 혼합 방식, 프로파일링, 터보팬 컴파일러

</details>

## 2. 실행 컨텍스트 & 변수 동작 원리

<details>
<summary>⭐️ 실행 컨텍스트(Execution Context)란 무엇인가요?</summary>

실행 컨텍스트는 **자바스크립트 코드가 실행되기 위한 환경 정보를 담고 있는 객체**입니다. 변수, 함수 선언, 스코프 체인, this 값 등이 실행 컨텍스트에 저장됩니다.

✅ 환경 정보, 객체, 변수/함수 선언/스코프 체인/this 값

</details>

<details>
<summary>실행 컨텍스트가 생성되는 시점에 어떤 일이 일어나나요?</summary>

실행 컨텍스트가 생성되면 변수와 함수 선언이 메모리에 등록되고, 스코프 체인이 결정되며, this 값이 바인딩됩니다. 이 과정에서 호이스팅이 발생합니다.

</details>

<details>
<summary>⭐️ 호이스팅(Hoisting)이란 무엇인가요?</summary>

호이스팅은 변수와 함수 선언이 코드 실행 전에 실행 컨텍스트 상단으로 끌어올려진 것처럼 동작하는 현상을 말합니다. 실제로 코드가 이동하는 것은 아니며, 메모리에 미리 등록되는 개념입니다.

✅ 변수/함수 선언, 실행 전, 실행 컨텍스트 상단, 끌어올려진 것, 코드 위치, 메모리

</details>

<details>
<summary>⭐️ var, let, const의 호이스팅 차이를 설명해보세요.</summary>

var는 선언과 초기화가 함께 이루어져 undefined로 접근이 가능하지만, let과 const는 선언만 호이스팅되고 초기화는 되지 않아 TDZ에 의해 접근 시 에러가 발생합니다.

✅ 선언, 초기화, undefined, 접근, TDZ

</details>

<details>
<summary>⭐️ TDZ(Temporal Dead Zone)란 무엇인가요?</summary>

TDZ는 let과 const로 선언된 변수가 선언 시점부터 초기화되기 전까지 접근할 수 없는 구간을 의미합니다. 이 구간에서 변수를 참조하면 ReferenceError가 발생합니다.

TDZ는 변수를 선언 전에 사용하는 실수를 방지하고, 코드의 예측 가능성과 안정성을 높이기 위해 도입되었습니다.

✅ let/const, 변수, 선언 시점~초기화, Reference Error

</details>

<details>
<summary>⭐️ 선언, 초기화, 할당의 차이를 설명해보세요.</summary>

선언은 변수를 메모리에 등록하는 단계이고, 초기화는 변수에 기본 값을 할당하는 단계이며, 할당은 실제 값을 변수에 대입하는 단계입니다.

✅ 메모리, 기본 값, 실제 값

</details>

<details>
<summary>⭐️ const에서 객체 내부 변경이 가능한 이유는 무엇인가요?</summary>

const는 변수 자체의 재할당을 막을 뿐, 객체가 참조하는 메모리 주소는 고정되어 있기 때문에 객체 내부의 속성 변경은 가능합니다.

✅ 변수 재할당, 참조, 메모리 주소, 내부 속성 변경

</details>

## 3. 스코프 & 클로저

<details>
<summary>⭐️ 스코프(Scope)란 무엇인가요?</summary>

스코프는 변수에 접근할 수 있는 유효 범위를 의미하며, 자바스크립트에서는 전역 스코프와 지역 스코프가 존재합니다.

전역 스코프를 남용하면 변수 충돌 가능성이 높아지고, 코드 의존성이 증가하여 유지보수가 어려워집니다.

✅ 변수 접근, 유효 범위, 전역 스코프, 지역 스코프 존재, 지역 스코프는 함수 스코프, 블록 스코프로 나뉨, 변수 충돌 가능성, 코드 의존성, 유지보수

</details>

<details>
<summary>⭐️ 렉시컬 스코프(Lexical Scope)란 무엇인가요?</summary>

렉시컬 스코프는 함수가 선언된 위치에 따라 상위 스코프가 결정되는 방식입니다. 함수 호출 위치와는 관계없이 정의된 위치 기준으로 스코프가 결정됩니다.

✅ 함수 선언 위치, 상위 스코프, 함수 호출 위치

</details>

<details>
<summary>var, let, const의 스코프 차이를 설명해보세요.</summary>

var는 함수 스코프를 가지며, let과 const는 블록 스코프를 가집니다.

이로 인해 let과 const가 더 예측 가능하고 안전한 변수 선언 방식으로 권장됩니다.

✅ 함수 스코프, 블록 스코프, 예측 가능성

</details>

<details>
<summary>각 스코프에 대해 설명해주세요</summary>

- **전역 스코프**는 어디에서든 접근 가능한 최상위 스코프입니다. 파일 전체 또는 전역 객체(window, node)에 속하며, 남용 시 변수 충돌과 의존성 증가로 유지보수가 어려워집니다.

- **지역 스코프**는 전역 스코프가 아닌 모든 내부 스코프를 통칭하는 개념이며, 함수 스코프와 블록 스코프를 포함하는 상위 개념입니다.

- **함수 스코프**는 함수 단위로 유효 범위가 결정되는 스코프로, var로 선언한 변수는 함수 내부에서만 유효하고 함수 밖에서는 접근할 수 없습니다. 반면 if문이나 for문 같은 블록 안에서는 스코프가 생성되지 않습니다.

- **블록 스코프**는 중괄호 {}로 감싸진 블록 단위로 유효 범위가 결정되는 스코프로, let과 const로 선언한 변수는 해당 블록 내부에서만 접근할 수 있습니다. 이를 통해 의도치 않은 변수 재선언이나 접근을 방지할 수 있어 코드의 안정성이 높아집니다.

✅ 최상위, 전역 객체, var/let/const, 중괄호

</details>

<details>
<summary>스코프 체인(Scope Chain)이란 무엇인가요?</summary>

스코프 체인은 현재 스코프에서 변수를 찾지 못했을 때 상위 스코프로 순차적으로 탐색하는 구조를 의미합니다.

✅ 상위 스코프, 순차

</details>

<details>
<summary>⭐️ 클로저(Closure)란 무엇인가요?</summary>

클로저는 함수가 자신이 선언된 환경의 변수에 접근할 수 있는 특성을 말합니다. 함수가 종료된 이후에도 외부 스코프의 변수를 기억하고 사용할 수 있습니다.

자바스크립트는 렉시컬 스코프를 기반으로 하기 때문에, 함수가 생성될 당시의 스코프 정보를 유지하고 있어 클로저가 동작할 수 있습니다.

✅ 선언된 환경, 변수 접근, 함수 종료, 외부 스코프, 렉시컬 스코프, 함수 선언

</details>

<details>
<summary>⭐️ 클로저는 어떤 상황에서 유용하고, 단점은 무엇인가요?</summary>

클로저는 상태를 은닉하거나 데이터 보호가 필요할 때 유용하지만, 불필요하게 사용하면 메모리 누수의 원인이 될 수 있습니다.

✅ 상태 은닉, 데이터 보호, 메모리 누수

</details>

## 4. this & 객체 생성

<details>
<summary>⭐️ this는 무엇이며 언제 결정되나요?</summary>

this는 함수가 호출되는 방식에 따라 동적으로 결정되는 객체 참조입니다. 함수 정의 시점이 아니라 호출 시점에 결정됩니다.

</details>

<details>
<summary>⭐️ 일반 함수 / 메서드 / 생성자 호출에서 this는 각각 무엇을 가리키나요?</summary>

- 일반 함수에서는 전역 객체를,
- 메서드 호출에서는 해당 객체를,
- 생성자 함수에서는 새로 생성된 인스턴스를 가리킵니다.

</details>

<details>
<summary>⭐️ 화살표 함수에서 this가 다른 이유는 무엇인가요?</summary>

일반 함수의 this는 호출 방식에 따라 동적으로 결정되지만,  
화살표 함수는 자신만의 this를 생성하지 않고 선언 당시의 상위 스코프 this를 그대로 사용합니다. -> 화살표 함수는 렉시컬 스코프

이 때문에 화살표 함수의 this는 call, apply, bind로 명시적으로 변경할 수 없으며,  
콜백이나 비동기 로직에서 this가 의도치 않게 바뀌는 문제를 방지할 수 있습니다.

</details>

<details>
<summary>생성자 함수(Constructor)란 무엇인가요?</summary>

생성자 함수는 new 키워드를 통해 객체를 생성하기 위한 함수로, 객체 초기화 로직을 담당합니다.

</details>

<details>
<summary>new 키워드로 호출될 때 내부적으로 어떤 과정이 일어나나요?</summary>

빈 객체가 생성되고, this가 해당 객체를 가리키며, 프로토타입이 연결된 후 생성자 함수가 실행되고 객체가 반환됩니다.

</details>

<details>
<summary>화살표 함수는 왜 생성자(new)로 사용할 수 없나요?</summary>

화살표 함수는 this와 prototype을 가지지 않기 때문에 생성자 함수로 사용할 수 없습니다.

</details>

<details>
<summary>⭐️ 프로토타입 체인(Prototype Chain)이란 무엇인가요?</summary>

프로토타입 체인은 객체가 자신의 속성을 찾지 못했을 때 상위 프로토타입으로 탐색을 이어가는 구조를 말합니다.

</details>

<details>
<summary>⭐️ 스코프 체인과 프로토타입 체인의 차이는 무엇인가요?</summary>

스코프 체인은 **변수를 찾기 위한 탐색 구조**로, 현재 실행 컨텍스트에서 변수를 찾지 못하면 순차적으 상위 스코프로 올라가며 검색합니다. 이는 함수가 선언된 위치를 기준으로 결정되는 렉시컬 스코프에 따라 형성됩니다.

반면 프로토타입 체인은 **객체의 프로퍼티나 메서드를 찾기 위한 탐색 구조**로, 객체에 해당 프로퍼티가 없으면 `[[Prototype]]`을 따라 상위 객체로 올라가며 검색합니다.

즉, 스코프 체인은 _변수 접근_, 프로토타입 체인은 *객체 속성 접근*을 위한 메커니즘이라는 점이 핵심적인 차이입니다.

✅ 스코프 체인: 변수, 탐색구조, 실행 컨텍스트, 순차적, 상위 스코프

✅ 프로토타입 체인: 객체, `[[Prototype]]`

</details>

<details>
<summary>자바스크립트에서 상속은 어떤 방식으로 구현되나요?</summary>

자바스크립트는 프로토타입 기반 상속을 사용하며, 객체 간 프로토타입 연결을 통해 상속을 구현합니다.

</details>

<details>
<summary>명시적 바인딩 방법에 대해 아시나요?</summary>

명시적 바인딩은 this를 자바스크립트 엔진이 자동으로 결정하도록 두지 않고,
개발자가 직접 this 값을 지정하는 방식입니다.

대표적으로 call, apply, bind 메서드를 사용합니다.

- call과 apply는 this를 지정한 뒤 함수를 즉시 실행하며,
  call은 인자를 개별로 전달하고 apply는 인자를 배열 형태로 전달합니다.
- 반면 bind는 this가 고정된 새로운 함수를 반환하며,
  즉시 실행되지 않고 나중에 호출할 수 있다는 차이가 있습니다.

따라서 call과 apply는 일회성 실행에,
bind는 콜백이나 이벤트 핸들러처럼 this를 계속 유지해야 하는 경우에 주로 사용됩니다.

```ts
const person = { name: "민재" };

function sayHello(age) {
  console.log(`안녕하세요, ${this.name} (${age})`);
}

// call: 인자를 개별로 전달
sayHello.call(person, 24);

// apply: 인자를 배열로 전달
sayHello.apply(person, [24]);

// bind: this가 고정된 새 함수 반환
const boundHello = sayHello.bind(person);
boundHello(24);
```

> 위의 코드에서 this.name이 출력되는 이유는 sayHello라는 함수가 person 객체에 바인딩된 상태로 실행되기 때문입니다.

</details>

## 5. 타입 & 값 저장 방식

<details>
<summary>⭐️ 원시 타입(Primitive)과 참조 타입(Reference)의 차이를 설명해보세요.</summary>

원시 타입은 값 자체가 저장되고 복사되며, 참조 타입은 객체가 저장된 메모리 주소를 참조합니다.

원시 타입에는 number, string, boolean, null, undefined, symbol, bigint가 있고,

참조 타입에는 object가 있으며 배열, 함수, 객체 등이 여기에 포함됩니다.

✅ 메모리, 복사, 객체

</details>

<details>
<summary>원시 타입은 왜 불변(immutable)이라고 하나요?</summary>

원시 타입은 값을 변경할 수 없고, 새로운 값을 할당하면 기존 값이 변경되는 것이 아니라 새로운 값이 생성되기 때문입니다.

즉, 기존의 변수가 할당된 메모리를 사용하는 게 아니라 새로운 메모리를 사용하게 됩니다.

</details>

<details>
<summary>⭐️ 참조 타입은 값이 어디에 저장되며 변수는 무엇을 들고 있나요?</summary>

객체는 힙 메모리에 저장되고, 변수는 해당 객체의 메모리 주소를 참조합니다.

✅ 힙, 참조

</details>

<details>
<summary>얕은 복사(Shallow Copy)와 깊은 복사(Deep Copy)의 차이는 무엇인가요?</summary>

얕은 복사는 참조를 복사하고, 깊은 복사는 실제 객체 구조를 완전히 복사합니다.

즉, 얕은 복사나 깊은 복사나 메모리를 새로 할당하는 것은 마찬가지이지만 얕은 복사는 원본의 내부 객체의 주소값만 복사하는 반면 깊은 복사는 내부 객체까지 모두 새로운 메모리에 할당합니다.

얕은 복사는 주로 `const copy = { ...original }` 와 같이 스프레드 연산자를 사용하며, 깊은 복사는 Lodash 라이브러리나 깊은 복사를 수행하는 재귀 함수를 이용합니다.

</details>

<details>
<summary>⭐️ 얕은 복사에서 문제가 생기는 이유는 무엇인가요?</summary>

여러 변수가 같은 객체를 참조하게 되어 한쪽 변경이 다른 쪽에 영향을 주기 때문입니다.

</details>

<details>
<summary>⭐️ React에서 불변성이 중요한 이유는 무엇인가요?</summary>

React는 상태 변경 여부를 참조 비교로 판단하기 때문에, 불변성을 지켜야 변경 감지가 정확하게 이루어집니다.

</details>

## 6. 비동기 처리 & 이벤트 루프

<details>
<summary>⭐️ 동기(Synchronous)와 비동기(Asynchronous)의 차이는 무엇인가요?</summary>

동기는 작업이 순차적으로 실행되고, 비동기는 이전 작업 완료 여부와 상관없이 다음 작업이 실행됩니다.

</details>

<details>
<summary>⭐️ Promise란 무엇인가요?</summary>

Promise는 비동기 작업의 성공 또는 실패 결과를 나타내는 객체입니다.

</details>

<details>
<summary>Promise와 콜백의 차이는 무엇인가요?</summary>

Promise는 체이닝이 가능해 가독성이 좋고 에러 처리가 명확하지만, 콜백은 중첩이 깊어질 수 있습니다.

</details>

<details>
<summary>⭐️ async/await의 동작 원리는 무엇인가요?</summary>

async/await는 Promise를 기반으로 하며, 비동기 코드를 동기 코드처럼 작성할 수 있게 해줍니다.

async 함수 내부의 반환값은 자동으로 Promise로 감싸지기 때문에 항상 Promise를 반환합니다.

</details>

<details>
<summary>setTimeout 내부 에러가 바깥 try/catch로 잡히지 않는 이유는 무엇인가요?</summary>

setTimeout은 비동기적으로 실행되어 실행 컨텍스트가 분리되기 때문에 외부 try/catch에서 에러를 잡을 수 없습니다.

- async/await은 Promise.then을 감싼 문법으로, await 이후 코드는 마이크로태스크 큐에서 실행되지만 같은 실행 흐름(call stack context) 안으로 복귀하기 때문에 try/catch로 에러를 잡을 수 있습니다.
- 반면 setTimeout은 매크로태스크로 완전히 새로운 콜스택에서 실행되기 때문에 try/catch로 잡히지 않습니다.

</details>

<details>
<summary>⭐️ 이벤트 루프(Event Loop)란 무엇인가요?</summary>

자바스크립트는 싱글 스레드 기반 언어이기 때문에, 비동기적으로 동작하는 것처럼 보이도록 이벤트 루프를 사용합니다.

이벤트 루프는 Call Stack이 비어 있을 때 Microtask Queue와 Task Queue를 확인하여,
대기 중인 작업을 순서에 맞게 Call Stack으로 다시 실행시키는 역할을 합니다.

</details>

<details>
<summary>⭐️ Call Stack / Task Queue / Microtask Queue의 역할은 무엇인가요?</summary>

Call Stack은 실행 중인 함수가 쌓이는 공간이고, Task Queue는 일반 비동기 작업이 대기하며, Microtask Queue는 Promise 같은 우선순위 높은 작업이 대기합니다.

</details>

<details>
<summary>⭐️ Promise.then이 setTimeout(0)보다 먼저 실행되는 이유는 무엇인가요?</summary>

Microtask Queue가 Task Queue보다 우선적으로 처리되기 때문입니다.

</details>
<details>
<summary>비동기 함수와 동기 함수가 실행되는 동작 원리를 설명해주세요</summary>

1. Call Stack에 동기 함수가 LIFO 방식으로 쌓이며 실행됩니다
2. 비동기 함수는 브라우저가 제공하는 Web API에 의해 태스크 큐로 이동합니다
3. 태스크 큐에서도 Microtask queue와 Macrotask queue가 나뉘며, Microtask queue엔 우선순위가 높은 비동기 함수가 들어갑니다 (예: Promise의 then, catch, finally, await 이후 코드)
4. Call Stack이 완전히 비워지면 이벤트 루프가 이를 감지하여 Microtask queue에 있는 비동기 작업 부터 Call Stack으로 옮겨 비동기 함수를 실행합니다

</details>

## 7. 이벤트 & 이벤트 최적화

<details>
<summary>⭐️ 이벤트 버블링과 캡처링의 차이는 무엇인가요?</summary>

- 이벤트 캡처링은 이벤트가 최상위 요소에서 시작해 실제 이벤트가 발생한 요소까지 내려오는 단계이고,
- 이벤트 버블링은 이벤트가 발생한 요소에서 시작해 상위 요소로 전파되는 단계입니다.

일반적으로 브라우저는 버블링 단계에서 이벤트를 처리하며, 캡처링은 필요할 때 명시적으로 사용합니다.

</details>

<details>
<summary>⭐️ 이벤트 위임이란 무엇인가요?</summary>

이벤트 위임은 상위 요소에 이벤트를 등록해 하위 요소의 이벤트를 처리하는 방식입니다.

이벤트가 버블링을 통해 상위 요소로 전달되기 때문에 이벤트 위임이 가능합니다.

</details>

<details>
<summary>target과 currentTarget의 차이는 무엇인가요?</summary>

target은 실제 이벤트가 발생한 요소이고, currentTarget은 이벤트 리스너가 등록된 요소입니다.

예를 들어 부모 요소에 클릭 이벤트를 걸어두고 그 안에 있는 버튼을 클릭하면,
target은 실제로 클릭한 버튼이고,
currentTarget은 이벤트가 등록된 부모 요소가 됩니다.

</details>

<details>
<summary>preventDefault와 stopPropagation의 차이는 무엇인가요?</summary>

preventDefault는 기본 동작을 막고, stopPropagation은 이벤트 전파를 막습니다.

예를 들어 a 태그를 클릭했을 때 페이지 이동을 막고 싶으면 preventDefault를 사용하고,
버튼을 클릭했을 때 부모 요소의 클릭 이벤트까지 실행되지 않게 하고 싶으면 stopPropagation을 사용합니다.

</details>

<details>
<summary>⭐️ 디바운스와 쓰로틀의 차이는 무엇인가요?</summary>

디바운스는 이벤트가 멈춘 후 한 번만 실행되고, 쓰로틀은 일정 시간마다 실행됩니다.

예를 들어 검색창에 입력할 때,

- 사용자가 입력을 멈춘 후에 한 번만 요청을 보내고 싶다면 디바운스를 사용하고,
- 스크롤 이벤트처럼 계속 발생하는 상황에서 일정 간격으로만 처리하고 싶다면 쓰로틀을 사용합니다.

</details>

## 8. 자료구조 & 배열 메서드

<details>
<summary>⭐️ map은 무엇인가요?</summary>

map은 배열의 각 요소를 변환해서 새로운 배열을 만드는 메서드입니다.
기존 배열의 길이는 유지되고, 각 요소를 가공한 결과가 새 배열로 반환됩니다.

예를 들어 숫자 배열을 받아서 각 값에 2를 곱한 새로운 배열을 만들 때 사용합니다.

</details>

<details>
<summary>⭐️ filter는 무엇인가요?</summary>

filter는 조건을 만족하는 요소만 걸러서 새로운 배열을 만드는 메서드입니다.
조건에 맞지 않는 요소는 제거되고, 원본 배열은 변경되지 않습니다.

예를 들어 사용자 목록에서 활성화된 사용자만 추려낼 때 사용합니다.

</details>

<details>
<summary>⭐️ find는 무엇인가요?</summary>

find는 조건을 만족하는 첫 번째 요소 하나만 반환하는 메서드입니다.
조건을 만족하는 요소를 찾으면 즉시 탐색을 중단하며, 배열이 아니라 값 자체를 반환합니다.

예를 들어 특정 id를 가진 사용자 한 명을 찾을 때 사용합니다.

</details>

<details>
<summary>⭐️ reduce는 언제 사용하나요?</summary>

reduce는 배열을 하나의 값으로 누적해서 계산할 때 사용하는 메서드입니다.
합계, 평균, 객체 변환 등 다양한 집계 로직을 한 번에 처리할 수 있습니다.

예를 들어 숫자 배열의 총합을 구하거나, 배열을 객체 형태로 변환할 때 사용합니다.

</details>

<details>
<summary>⭐️ map / filter / find의 차이는 무엇인가요?</summary>

map은 배열을 변환하고, filter는 조건에 맞는 요소를 반환하며, find는 조건에 맞는 첫 요소를 반환합니다.

</details>

<details>
<summary>Map이 Object보다 유리한 점은 무엇인가요?</summary>

Map은 키 타입에 제한이 없고, 순서를 보장하며 성능이 안정적입니다.

</details>

<details>
<summary>Set이 Array보다 유리한 점은 무엇인가요?</summary>

Set은 중복을 자동으로 제거할 수 있어 고유 값 관리에 유리합니다.

</details>

## 9. 기타

<details>
<summary>strict mode는 왜 사용하나요?</summary>

- 엄격한 문법을 적용해 잠재적인 오류를 사전에 방지하기 위해 사용합니다.
- 선언되지 않은 변수 사용을 금지하고, 조용히 실패하던 동작을 에러로 바꿔 버그를 빠르게 발견할 수 있게 해줍니다.
- 또한 엔진 최적화에도 도움이 됩니다.

</details>

<details>
<summary>⭐️ ==(Equal Operator, 동등 연산자)와 ===(Strict Equal Operator, 일치 연산자)의 차이는 무엇인가요?</summary>

- ==는 비교 전에 타입 변환을 수행한 뒤 값을 비교하고,
- ===는 타입과 값이 모두 같은지를 비교합니다.

암묵적 타입 변환으로 인한 예기치 않은 결과를 막기 위해,
일반적으로는 === 사용이 권장됩니다.

</details>

<details>
<summary>⭐️ undefined와 null의 차이는 무엇인가요?</summary>

- undefined는 값이 할당되지 않은 상태를 의미하며,
  변수를 선언만 하고 값을 넣지 않았을 때 자바스크립트가 자동으로 부여합니다.

- null은 개발자가 의도적으로 값이 없음을 명시할 때 사용하는 값입니다.

- 메모리 관점에서 보면 undefined는 아직 값이 할당되지 않은 상태이고,
  null은 비어 있음을 의미하는 값이 실제로 할당된 상태입니다.

- 타입에서도 차이가 있는데, undefined의 타입은 undefined이고
  null의 타입은 자바스크립트의 오래된 설계로 인해 object로 반환됩니다.

즉, undefined는 시스템이 부여하는 기본 상태이고,
null은 개발자가 명확히 의도를 표현하기 위해 사용하는 값입니다.

</details>

<details>
<summary>⭐️ 자동 박싱(auto-boxing)이란 무엇인가요?</summary>

자동 박싱은 원시 타입이 객체처럼 동작할 수 있도록 일시적으로 객체로 감싸지는 현상입니다.

예를 들어 문자열은 원시 타입이지만, string.length나 string.toUpperCase() 같은 프로퍼티와 메서드를 사용할 수 있습니다.

이는 자바스크립트 엔진이 필요한 순간에 임시 객체로 변환했다가 다시 원시 값으로 되돌리기 때문입니다.

</details>
