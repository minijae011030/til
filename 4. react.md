# React

## 1. React 기본 개념

### ⭐ React란 무엇인가

사용자 인터페이스(UI)를 만들기 위한 자바스크립트 라이브러리입니다.
컴포넌트 단위로 UI를 구성하며, 상태 변화에 따라 UI를 다시 렌더링하는 방식으로 동작합니다.

### ⭐ React의 특징과 장단점

특징

- 컴포넌트 기반
- 선언형 UI
- Virtual DOM 사용

장점

- UI 재사용성
- 유지보수 용이
- 대규모 애플리케이션에 적합

단점

- 초기 학습 비용
- 상태 관리 복잡성 증가 가능

### ⭐ JSX란 무엇인가

JavaScript 안에서 HTML과 유사한 문법을 사용할 수 있게 해주는 문법입니다.
실제로는 Babel을 통해 React.createElement로 변환되어 실행됩니다.

### ⭐ 엘리먼트와 컴포넌트의 차이

- 엘리먼트
  - 화면에 그려질 UI의 최소 단위
  - 불변 객체
- 컴포넌트
  - 엘리먼트를 반환하는 함수 또는 클래스

### ⭐ Fiber

React의 렌더링 엔진입니다.
렌더링 작업을 작은 단위로 쪼개고, 우선순위를 두어 중단·재개 가능한 비동기 렌더링을 가능하게 합니다.

Fiber의 핵심 목적

- 렌더링 작업을 쪼개서 처리
- 우선순위 기반 스케줄링
- 사용자 인터랙션(입력, 스크롤 등) 우선 처리
- 긴 렌더링으로 인한 UI 멈춤 방지

→ React가 부드럽게(Smooth) 동작하도록 만드는 내부 엔진

### ⭐ Virtual DOM이란

실제 DOM을 직접 조작하지 않고,
메모리 상에 가상 DOM 트리를 만들어 변경 사항을 비교하기 위한 구조입니다.

### ⭐ Virtual DOM 작동 원리

- state 변경
- 새로운 Virtual DOM 생성
- 이전 Virtual DOM과 비교(diffing)
- 변경된 부분만 실제 DOM에 반영

→ 불필요한 DOM 조작 최소화

### ⭐ diffing 알고리즘의 핵심 가정

전체 트리 비교는 비효율적이라 React는 휴리스틱 기반으로 최적화함.

- 타입이 다르면 다른 트리로 간주 (서브트리 통째로 교체)
- key로 동일 요소를 식별해 변경/이동/삭제를 추적

### ⭐ 재렌더링이 발생하는 조건

React 컴포넌트는 다음 경우 재렌더링 됩니다.

#### 1. state 변경 (useState, useReducer)

- setState 호출 시
- 이전 값과 참조 또는 값이 다르면 재렌더링

#### 2.props 변경

- 부모 컴포넌트가 리렌더링되며 자식에게 전달되는 props가 변경된 경우

⚠️ props drilling 시
- 중간 컴포넌트는 props를 사용하지 않아도 
- 전달만 하면 재렌더링 발생 가능

#### 3. 부모 컴포넌트 재렌더링

- 	부모가 재렌더링되면
- 기본적으로 자식도 함께 재렌더링

→ React.memo로 방지 가능

#### 4. Context 값 변경

- useContext로 구독 중인 값이 변경되면
- 해당 Context를 사용하는 모든 컴포넌트 재렌더링

### ⭐ 재렌더링 ≠ 실제 DOM 변경

#### 중요 포인트 ⭐

- 재렌더링
  - 함수 컴포넌트 재실행
  - Virtual DOM 재생성
- 실제 DOM 변경
  - diff 결과 변경된 부분만 반영

→ 재렌더링 자체는 비싼 작업이 아님

→ DOM 조작이 비쌈

### ⭐ Batch Update(배치 업데이트)

여러 state 업데이트를 모아서 한 번에 렌더링/커밋하는 최적화

→ 렌더링 횟수 감소, DOM 반영 최소화

### ⭐ 라이브러리 vs 프레임워크

- 라이브러리: 필요한 기능을 내가 선택해서 호출
- 프레임워크: 구조/흐름을 제공하고 프레임워크가 흐름을 제어

→ 제어 흐름이 프레임워크에 있는 걸 제어의 역전(IoC) 라고 함

## 2. 컴포넌트

### ⭐ 리액트에서 컴포넌트 생성 방법

함수 또는 클래스로 컴포넌트를 정의하고 JSX를 반환합니다.
현재는 함수형 컴포넌트 사용이 권장됩니다.

### ⭐ 함수형 컴포넌트 vs 클래스형 컴포넌트

- 함수형
  - Hooks 사용
  - 코드 간결
- 클래스형
  - this 사용
  - 라이프사이클 메소드 사용

### ⭐ 함수형 컴포넌트의 장점

- 코드가 간결함
- this 바인딩 문제 없음
- Hooks로 로직 재사용 가능

## 3. Hooks

### ⭐ React Hooks란

함수형 컴포넌트에서 state와 생명주기 기능을 사용할 수 있게 해주는 API입니다.
use로 시작하며, 호출 규칙이 존재합니다.

### ⭐ useState

컴포넌트의 상태를 관리하기 위한 Hook입니다.
상태 변경 시 컴포넌트가 리렌더링됩니다.

### ⭐ useEffect

외부시스템과 컴포넌트를 동기화하는 React Hook 입니다.

렌더링 이후 실행되는 부수 효과 처리용 Hook입니다.
데이터 패칭, 이벤트 등록, 타이머 등에 사용됩니다.

### ⭐ useRef

- DOM 요소 직접 접근
- 값 변경 시 리렌더링 ❌
- 이전 값 저장 용도로도 사용

### ⭐ useEffect와 라이프사이클 대응

- [] : componentDidMount
- [deps] : componentDidUpdate
- return : componentWillUnmount

### ⭐ useEffect vs useLayoutEffect

- useEffect
  - 비동기
  - 화면 페인트 이후 실행
- useLayoutEffect
  - 동기
  - DOM 변경 직후 실행
    → DOM 크기 측정 시 사용

### ⭐ useContext

Context에 저장된 값을 함수 컴포넌트에서 꺼내 쓰는 Hook

→ props drilling을 줄이는 목적

### ⭐ Context API를 상태관리처럼 쓰면 생길 수 있는 문제

Provider 값이 바뀌면 Provider 하위가 전부 리렌더링될 수 있음
→ “공유”엔 좋지만, “상태관리 최적화” 목적이면 한계가 있음

## 4. State & Props

### ⭐ State란

컴포넌트 내부에서 관리되는 데이터입니다.
값이 변경되면 컴포넌트가 다시 렌더링됩니다.

### ⭐ Props란

부모 컴포넌트가 자식 컴포넌트에 전달하는 데이터입니다.
읽기 전용이며 자식에서 직접 변경할 수 없습니다.

### ⭐ Props와 State의 차이

- Props
  - 외부에서 전달
  - 불변
- State
  - 내부에서 관리
  - 변경 가능

### ⭐ State를 직접 수정하지 않는 이유

React는 참조 변경 여부로 상태 변화를 감지합니다.
직접 수정하면 변경을 감지하지 못해 렌더링이 일어나지 않을 수 있습니다.

### ⭐ React는 상태 변화를 어떻게 감지하는가

이전 state와 새로운 state의 참조값 비교를 통해 감지합니다.
그래서 불변성을 유지해야 합니다.

### ⭐ State 불변성 유지 방법

- spread 연산자
- 배열 메서드(map, filter)
- 객체 복사 후 수정

### ⭐ setState는 동기/비동기?

비동기적으로 동작

여러 상태 변경을 **배치 처리(batch)** 하여
불필요한 렌더링을 줄이고 성능을 최적화하기 위함

## 5. 데이터 흐름

### ⭐ 단방향 데이터 흐름

데이터는 부모 → 자식 방향으로만 전달됩니다.
상태 추적이 쉽고 예측 가능한 구조를 만듭니다.

### ⭐ 자식 → 부모 데이터 전달 가능 여부

직접 전달은 불가능하며,
부모에서 함수를 props로 내려 호출하는 방식으로 전달합니다.

### ⭐ Props Drilling이란

여러 단계의 컴포넌트를 거쳐
불필요하게 props를 전달하는 문제입니다.

### ⭐ Props Drilling 해결 방법

- Context API
- 전역 상태 관리 라이브러리

## 6. 이벤트 & Form

### ⭐ HTML vs React 이벤트 차이

React는 Synthetic Event를 사용합니다.
브라우저 간 이벤트 차이를 추상화합니다.

### ⭐ Form 이벤트 제어 방식

입력 값을 state로 관리하며
onChange 이벤트로 상태를 갱신합니다.

### ⭐ 제어 컴포넌트 vs 비제어 컴포넌트

- 제어 컴포넌트
  - state로 값 관리
- 비제어 컴포넌트
  - ref로 DOM 접근

### ⭐ useRef의 실제 사용 사례

- input focus 제어
- 이전 값 저장
- setTimeout, interval id 저장

### ⭐ Synthetic Event

React는 브라우저 이벤트 차이를 추상화한 Synthetic Event를 사용함
→ 동일한 방식으로 이벤트 처리 가능

### ⭐ target vs currentTarget

- target: 실제 이벤트가 발생한 요소
- currentTarget: 이벤트 핸들러가 달린 요소

→ 이벤트 위임에서 분기 기준은 보통 target

### ⭐ preventDefault vs stopPropagation

- preventDefault(): 브라우저 기본 동작 방지
- stopPropagation(): 이벤트 전파(버블링/캡처링) 중단

## 7. 렌더링 최적화 & 성능

### ⭐ Key props를 사용하는 이유

리스트 렌더링 시 각 요소를 고유하게 식별하기 위해 사용합니다.
React는 key를 기준으로 이전 Fiber 트리와 새로운 Fiber 트리를 비교해
어떤 요소를 재사용하고, 어떤 요소를 새로 생성할지 판단합니다.

key가 없거나 index를 사용할 경우,
Fiber가 요소의 변경을 정확히 추적하지 못해
불필요한 재렌더링이나 상태 꼬임이 발생할 수 있습니다.

### ⭐ 메모이제이션이란

이미 계산된 결과를 저장해
불필요한 연산이나 렌더링을 방지하는 기법입니다.

### ⭐ useMemo

값을 메모이제이션합니다.
연산 비용이 큰 계산 결과 캐싱에 사용됩니다.

### ⭐ useCallback

함수를 메모이제이션합니다.
불필요한 함수 재생성을 방지합니다.

### ⭐ React.memo

컴포넌트를 메모이제이션합니다.
props가 변경되지 않으면 리렌더링을 방지합니다.

### ⭐ useMemo vs React.memo

- useMemo
  - 값 캐싱
- React.memo
  - 컴포넌트 캐싱

### ⭐ React.lazy / Suspense

- React.lazy: 컴포넌트를 동적 import로 지연 로딩
- Suspense: 지연 로딩 중 보여줄 fallback UI 제공

→ 초기 번들 크기 줄이고, 필요한 시점에 로드 (코드 스플리팅)

## 8. 전역 처리 / 고급 개념

### ⭐ Context API

props 없이
전역 데이터를 컴포넌트 트리 전체에 공유할 수 있는 기능입니다.

### ⭐ Portal

컴포넌트를 DOM 트리 외부에 렌더링할 수 있는 기능입니다.
모달, 툴팁 구현에 사용됩니다.

### ⭐ Error Boundary

하위 컴포넌트에서 발생한 에러를
잡아서 UI가 전체적으로 깨지는 것을 방지합니다.

### ⭐ forwardRef

ref는 일반 props로 전달되지 않기 때문에, 하위 컴포넌트에 ref를 넘기려면 forwardRef가 필요

→ input focus 같은 “부모가 자식 DOM을 제어”하는 케이스에서 자주 등장

### ⭐ Callback ref

ref 객체 대신 “함수”를 ref로 넘기는 방식
렌더 후 node를 받아서 원하는 로직을 수행할 수 있음

## 9. 데이터 패칭

### ⭐ React Query란

서버 상태를 관리하기 위한 라이브러리입니다.
데이터 패칭, 캐싱, 로딩·에러 상태를 자동으로 관리합니다.

### ⭐ 등장 배경

- 서버 상태와 클라이언트 상태 분리
- 반복되는 비동기 로직 문제 해결

### ⭐ React Query의 장점

- 자동 캐싱
- 재요청 관리
- 로딩/에러 상태 관리 간소화

## 10. React 18 주요 변경

### ⭐ React 18 주요 변경

- automatic batching
- concurrent rendering 개념 도입
- useTransition, useDeferredValue
