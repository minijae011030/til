# 프론트엔드 전반 면접 질문 리스트

## 1. 브라우저 & 렌더링

<details>
<summary>⭐️ 브라우저 렌더링 과정 전체를 설명해보세요.</summary>

브라우저는 **HTML을 파싱해 DOM 트리**를 만들고, CSS를 파싱해 **CSSOM 트리**를 생성합니다.

JavaScript는 DOM 생성 과정 중간에 개입합니다.
브라우저가 HTML을 파싱하다가 script 태그를 만나면 DOM 파싱을 멈추고 JS를 실행합니다.

JS는 DOM을 수정할 수 있기 때문에, 브라우저는 JS 실행이 끝나기 전까지 DOM 생성 작업을 중단합니다.
이후 JavaScript가 마무리되면 DOM 파싱을 다시 이어서 진행합니다.

이 두 트리를 결합해 **Render Tree**를 만든 뒤, **Layout** 단계에서 각 요소의 **위치와 크기**를 계산합니다.

마지막으로 **Paint** 단계에서 **실제 픽셀**을 그리고, **Composite** 단계에서 레이어를 합쳐 화면에 표시합니다.

✅ DOM 트리, CSSOM 트리, Render Tree, 레이아웃, 위치와 크기 계산, 페인트, 실제 픽셀 그림, composite

</details>

<details>
<summary>⭐️ 브라우저 주소창에 URL을 입력했을 때 일어나는 과정을 설명해보세요.</summary>

URL 입력 후 **DNS 조회**로 **IP 주소**를 얻고, **TCP 연결**을 맺은 뒤 **HTTP 요청을 전송**합니다.
서버로부터 **HTML을 응답**받으면 브라우저는 이를 파싱하고 **렌더링** 과정을 수행해 화면을 그립니다.

![dns](https://github.com/minijae011030/til/blob/main/image/dns.png?raw=true)

</details>

<details>
<summary>DOM과 CSSOM은 각각 무엇이며 언제 생성되나요?</summary>

- DOM은 HTML을 파싱해 생성된 **문서 구조 트리**이고,
- CSSOM은 CSS를 파싱해 생성된 **스타일 정보 트리**입니다.

HTML과 CSS를 다운로드한 뒤 파싱 과정에서 각각 생성됩니다.

</details>

<details>
<summary>Render Tree는 무엇이며 어떤 요소들로 구성되나요?</summary>

Render Tree는 **화면에 실제로 표시될 요소**들만 모아 만든 트리입니다.
`display: none` 같은 요소는 포함되지 않으며, DOM 요소와 그에 적용된 스타일 정보(CSSOM 트리)가 결합됩니다.

</details>

<details>
<summary>Layout 단계에서는 어떤 작업이 수행되나요?</summary>

각 요소의 정확한 **위치와 크기를 계산**하는 단계입니다.
**뷰포트** 기준으로 **박스 모델**과 **레이아웃 흐름**을 바탕으로 계산합니다.

✅ 위치와 크기 계산, 뷰포트, 박스 모델, 레이아웃 흐름

</details>

<details>
<summary>Paint와 Composite 단계의 차이는 무엇인가요?</summary>

Paint는 색상, 그림자, 텍스트 등 **실제 픽셀을 그리는** 단계이고,
Composite는 여러 **레이어**를 GPU에서 합성해 **최종 화면**을 만드는 단계입니다.

✅ 색상/그림자/텍스트, 실제 픽셀을 그리는, 여러 레이어, 합성, 최종 화면

</details>
<details>
<summary>리액트와 브라우저의 전체 렌더링 싸이클은 어떻게 이루어져있나요?</summary>

1. Render Phase (렌더 단계)

   - 이 단계는 **무엇을 그려야 할지 결정하는 단계**입니다. **컴포넌트를 호출**하여 이전 **Virtual DOM**과 새로운 Virtual DOM을 **비교**합니다.
   - Trigger: **상태(State)** 나 프롭스(Props)가 변경되면 리액트는 렌더링을 시작합니다.
   - Virtual DOM 생성: 리액트는 **컴포넌트 트리를 순회**하며 새로운 **Virtual DOM**을 만듭니다.
   - **Reconciliation (재조정)**: 리액트의 Diffing 알고리즘을 통해 이전 트리와 새 트리를 **비교**합니다. 여기서 바뀐 부분(변경 사항)만 찾아내어 **'이펙트 리스트'** 에 기록합니다.
   - 특징: 이 단계는 **비동기적**으로 동작할 수 있으며(fiber), 사용자에게 직접 보이거나 DOM에 반영되지 않는 **순수한 계산** 과정입니다.

2. Commit Phase (커밋 단계)

   - **재조정 단계**에서 찾아낸 변경 사항을 **실제 DOM**에 적용하는 단계입니다.
   - DOM 업데이트: appendChild(), removeChild() 같은 **DOM 조작 API**를 사용하여 **리액트가 계산한 차이점**을 실제 DOM에 집어넣습니다.
   - 특징: 이 단계는 **동기적으로** 실행됩니다. **화면의 일관성**을 위해 중간에 멈추지 않고 한 번에 업데이트를 완료합니다.

3. Browser Rendering (Layout & Paint)

   - 리액트가 DOM 업데이트를 마치면, 브라우저가 화면에 그림을 그립니다.
   - Layout (Reflow): 브라우저가 각 요소의 정확한 크기와 위치를 계산합니다. (예: width, height, position 변경 시 발생)
   - Paint: 계산된 값을 바탕으로 픽셀을 채우는 과정입니다. 색상, 이미지, 텍스트 등을 실제로 그립니다.
   - Composite (Layer): 웹페이지의 요소들을 여러 개의 **레이어**(Layer)로 나누어 관리하다가, 마지막에 하나로 합칩니다. CSS의 transform이나 opacity 같은 속성을 사용하면 레이아웃이나 페인트를 건너뛰고 바로 합성 단계로 넘어가서 성능이 좋아집니다.

참고: [[React] 리액트의 렌더링 사이클(useLayoutEffect, useEffect)](https://sung-98.tistory.com/129)

![rendering](https://raw.githubusercontent.com/minijae011030/til/7884e90194fde68008d3a285ad448c2f62c83e0c/image/rendering.png)

</details>
<details>
<summary>이펙트 리스트에 대해 아시나요?</summary>

이펙트 리스트는 Render 단계에서 **재조정(Reconciliation)** 과정을 거치며 생성된 **Linked List** 입니다. **업데이트가 필요한 Fiber 노드들의 연결**로 이루어져 있습니다. 이를 통해 리액트는 Commit 단계에서 **전체 트리를 탐색하지 않고도** 변경 사항이 있는 노드에만 즉시 접근하여 효율적으로 DOM을 업데이트할 수 있습니다.

</details>
<details>
<summary>사이드 이펙트 태그에 대해서 아시나요?</summary>

사이드 이펙트 태그란 리액트가 재조정 과정에서 각 Fiber 노드가 실제 DOM에 **어떤 변화를 일으켜야 하는지 기록**해두는 **식별자**입니다.

Placement(삽입), Update(수정), Deletion(삭제), Passive 등의 상태를 **비트마스크** 형태로 저장하며,
Render 단계에서 이 태그가 붙은 노드들만 모아서 **이펙트 리스트**를 만듭니다. 이후 Commit 단계에서 리액트는 이 태그를 보고 실제 어떤 DOM 조작을 할지 결정합니다.

</details>
<details>
<summary>주요 사이드 이펙트 태그는 무엇인가요?</summary>

리액트 내부 코드(react-reconciler 패키지)를 보면 다양한 태그가 정의되어 있습니다. 가장 대표적인 것들은 다음과 같습니다.

1. Placement (배치): **새로운 요소**가 DOM에 삽입되어야 할 때 (새 컴포넌트 등장)
2. Update (업데이트): 이미 존재하는 DOM 요소의 **속성(Props)이나 상태(State)가 변경**되어 수정이 필요할 때.
3. Deletion (삭제): 컴포넌트가 **언마운트**되어 실제 DOM에서 제거되어야 할 때.
4. Passive (수동적): useEffect와 같이 **DOM 조작 이후**에 실행되어야 할 작업이 있을 때

</details>
<details>
<summary>리액트에서 왜 이펙트 리스트를 배열이 아닌 Linked List 구조로 관리하나요?</summary>

리액트가 "이펙트 리스트"를 만들 때 **연결 리스트**라는 자료 구조를 사용합니다.

연결 리스트의 각 노드는 두 가지 정보를 가집니다.

- Data: 실제 내용 (리액트에서는 **Fiber** 객체)
- Next Pointer: 다음 노드가 어디에 있는지 가리키는 주소값

JavaScript의 배열은 엔진 차원에서 최적화되어 크기 조절이 유연해 보이지만, 실제 메모리 구조상으로는 **연속된 공간**을 확보해야 하는 제약이 있습니다.
반면 연결 리스트는 메모리 상에 흩어진 노드들을 **포인터로 연결**하기 때문에, **삽입과 삭제가 빈번한 환경**에서 메모리 재할당 없이 훨씬 **유연**하게 크기를 늘릴 수 있습니다.

리액트는 이러한 특성을 이용해 컴포넌트 업데이트 순서를 관리하고, 렌더링 작업을 중단하거나 재개하는 데 활용합니다.

</details>

## 2. Reflow & Repaint

<details>
<summary>⭐️ 리플로우(Reflow)와 리페인트(Repaint)의 차이는 무엇인가요?</summary>

- 리플로우는 요소의 크기나 위치가 바뀌어 레이아웃을 다시 계산하는 과정이고,
- 리페인트는 레이아웃은 그대로 두고 색상 같은 **시각적 요소만 다시 그리는 과정**입니다.

레이아웃이 바뀌면 화면을 다시 그려야 하므로 리플로우가 발생하면 리페인트도 항상 발생합니다.

background-color, visibility 같은 시각적 속성 변경 시 리페인트만 발생합니다.

</details>

<details>
<summary>⭐️ 리플로우가 리페인트보다 비용이 큰 이유는 무엇인가요?</summary>

리플로우는 변경된 요소뿐 아니라 그에 영향을 받는 하위 요소와 **주변 요소**까지 다시 계산해야 합니다.
**레이아웃 계산**은 DOM 트리 전반에 영향을 줄 수 있기 때문에, 단순히 색상(시각적 요소)만 바꾸는 리페인트보다 훨씬 비용이 큽니다.

</details>

<details>
<summary>⭐️ 애니메이션 구현 시 transform, opacity가 권장되는 이유는 무엇인가요?</summary>

레이아웃과 페인트를 건너뛰고 **Composite 단계에서만** 처리되어 성능 부담이 적기 때문입니다.

</details>

## 3. Virtual DOM & Real DOM

<details>
<summary>⭐️ Real DOM 조작이 비싼 이유는 무엇인가요?</summary>

DOM을 직접 수정하면 **리플로우나 리페인트**가 발생할 수 있고, 이 과정은 브라우저 렌더링 파이프라인 전체에 영향을 줍니다.

</details>

<details>
<summary>⭐️ Virtual DOM은 어떤 방식으로 성능을 개선하나요?</summary>

Virtual DOM은 변경 전후 상태를 **메모리 상**에서 비교한 뒤, 실제 DOM에는 꼭 필요한 변경만 적용합니다.
이를 통해 불필요한 DOM 조작을 줄여 렌더링 비용을 최소화합니다.

</details>

<details>
<summary>Virtual DOM은 실제 DOM을 완전히 대체하나요?</summary>

아니요. Virtual DOM은 실제 DOM을 대체하지 않고, **변경 사항을 계산**하기 위한 중간 단계 역할을 합니다.
최종 렌더링은 항상 실제 DOM에서 이루어집니다.

</details>

<details>
<summary>⭐️ Virtual DOM 비교는 언제 발생하나요?</summary>

state나 props가 변경되어 컴포넌트가 재렌더링될 때 Virtual DOM 트리가 새로 생성되고, 이전 트리와 비교하는 diff 과정이 발생합니다.

</details>

## 4. CSR / SSR / SSG / SPA / MPA

<details>
<summary>⭐️ CSR(Client Side Rendering)에 대해 설명해주세요.</summary>

CSR은 서버로부터 최소한의 **HTML과 JavaScript 파일**을 내려받은 뒤,
브라우저에서 JavaScript를 실행해 화면을 렌더링하는 방식입니다.

- **초기 로딩** 시에는 JS를 내려받고 실행해야 하기 때문에 화면이 보이기까지 시간이 걸릴 수 있지만,
- 이후 **페이지 전환**은 서버 요청 없이 클라이언트에서 처리되어 전환이 빠르고 사용자 경험이 좋습니다.

</details>

<details>
<summary>⭐️ SSR(Server Side Rendering)에 대해 설명해주세요.</summary>

SSR은 요청이 들어올 때마다 서버에서 **완성된 HTML을 생성**해
클라이언트로 전달하는 렌더링 방식입니다.

- 브라우저는 HTML을 **바로 렌더링**할 수 있기 때문에 **초기 화면이 빠르게** 보이고, 검색 엔진이 콘텐츠를 즉시 **크롤링**할 수 있어 **SEO**에 유리합니다.
- 다만 요청마다 서버에서 렌더링을 수행하므로 **서버 부하**가 증가할 수 있습니다.

</details>

<details>
<summary>⭐️ SSG(Static Site Generation)에 대해 설명해주세요.</summary>

SSG는 페이지를 요청할 때마다 서버에서 렌더링하는 SSR과 달리, **빌드 시점에 모든 HTML을 미리 생성**해두는 방식입니다.

- 이렇게 생성된 **정적 HTML 파일**은 **CDN**을 통해 거의 즉시 제공되기 때문에 **응답 속도가 가장 빠르며 서버 부하가 없다**는 큰 장점이 있습니다.
- 다만 콘텐츠가 자주 바뀌는 페이지에는 적합하지 않고, 변경사항을 반영하려면 다시 빌드를 해야 하는 제약이 있습니다.

Next.js에서는 revalidate 같은 기능을 이용해 SSG와 동적 데이터를 섞는 하이브리드 패턴을 만들 수 있습니다.

</details>

<details>
<summary>⭐️ SPA(Single Page Application)에 대해 설명해주세요.</summary>

SPA는 **하나의 HTML 문서**를 기반으로 JavaScript가 화면을 **동적**으로 변경해주는 방식의 애플리케이션 구조입니다.

사용자가 페이지를 이동하거나 인터랙션을 수행할 때마다 새로운 HTML을 요청하는 것이 아니라, **클라이언트 라우팅**을 통해 **필요한 컴포넌트만 교체**하면서 화면을 구성합니다.

전체 페이지 **새로고침이 발생하지 않기** 때문에 전환이 빠르고 앱과 유사한 매끄러운 UX를 제공할 수 있습니다.

</details>

<details>
<summary>⭐️ MPA(Multi Page Application)에 대해 설명해주세요.</summary>

MPA는 **페이지 이동마다 서버에서 새로운 HTML을 받아오는 전통적인 웹 방식**입니다.

각 페이지가 완전히 분리되어 있어 **SEO**에 강하고 **보안**적으로도 안정적하지만, 이동할 때마다 전체 새로고침이 발생해 전환 속도가 느린 단점이 있습니다.

</details>

<details>
<summary>⭐️ CSR과 SSR의 차이를 설명해보세요.</summary>

CSR은 브라우저에서 JavaScript를 실행해 화면을 렌더링하는 방식이고,
SSR은 서버에서 HTML을 미리 생성해 전달하는 방식입니다.

- CSR은 초기 로딩은 느릴 수 있지만 이후 페이지 전환이 빠르고 인터랙션에 유리한 반면, **초기 HTML**에 콘텐츠가 없어 SEO에 불리할 수 있습니다.

- 반면 SSR은 초기 HTML에 콘텐츠가 포함되어 있어 검색 엔진이 바로 크롤링할 수 있어 SEO에 유리하고 초기 화면도 빠르게 보이지만, 요청마다 서버 렌더링이 필요해 서버 부담이 커질 수 있습니다.

</details>

<details>
<summary>⭐️ SSG와 SSR의 차이는 무엇인가요?</summary>

SSR은 요청 시점마다 서버가 렌더링을 수행하는 방식인 반면,
SSG는 빌드할 때 모든 HTML을 미리 만들어 두는 방식입니다.

변화가 거의 없는 정적 콘텐츠라면 SSG가 성능과 비용 측면에서 가장 유리하고, 사용자마다 다른 데이터가 필요하거나 요청 시점에 콘텐츠가 결정되는 페이지라면 SSR이 적합합니다.

</details>

<details>
<summary>SPA와 MPA의 차이는 무엇인가요?</summary>

SPA는 하나의 HTML을 기반으로 자바스크립트가 화면을 교체하면서 동작하는 방식이고, MPA는 페이지마다 각각 고유한 HTML 파일을 서버로부터 받아오는 전통적인 구조입니다.

- SPA는 페이지 전환이 매우 빠르고 사용자 경험이 앱에 가깝지만, 초기 로딩이 무거울 수 있고 SEO가 약하다는 단점이 있습니다.
- 반면 MPA는 페이지 이동 시 전체 새로고침이 발생해 전환 속도가 느린 대신, 각 페이지가 완전한 HTML로 제공되기 때문에 SEO가 강하고 페이지를 완전히 격리할 수 있어 보안 측면에서도 유리합니다.

</details>

<details>
<summary>SPA 환경에서 a 태그를 사용하면 어떤 문제가 발생하나요?</summary>

a 태그 클릭 시 브라우저는 **새로운 HTTP 요청**을 보내고, 기존 페이지를 완전히 종료한 뒤 **새로운 페이지를 로드**합니다.
따라서 SPA 환경에서 a 태그 사용 시 SPA의 **빠른 전환과 상태 유지** 장점이 사라집니다.

</details>

## 5. 대량 데이터 & 무한 스크롤

<details>
<summary>⭐️ 데이터 10,000개를 한 번에 렌더링하면 어떤 문제가 발생하나요?</summary>

한 번에 많은 데이터를 렌더링하면 **DOM 노드 수가 급격히 증가**해 렌더링 시간이 길어지고,
**브라우저 메모리 사용량**이 커지면서 스크롤이나 사용자 인터랙션이 느려질 수 있습니다.

특히 초기 렌더링 비용이 커져 화면이 늦게 보이거나 프레임 드랍이 발생할 수 있습니다.

</details>

<details>
<summary>무한 스크롤 구현 시 성능 이슈는 무엇인가요?</summary>

스크롤이 내려갈수록 DOM 요소가 계속 쌓이면서 메모리 사용량이 증가하고,
스크롤 이벤트가 과도하게 발생해 성능 저하가 생길 수 있습니다.

또한 데이터 로딩 시점 제어가 어려워 네트워크 요청이 중복되거나
사용자가 현재 위치를 파악하기 어렵다는 UX 문제도 발생할 수 있습니다.

</details>

<details>
<summary>⭐️ 가상 스크롤(Virtual Scrolling)이란 무엇인가요?</summary>

가상 스크롤은 화면에 실제로 보이는 영역에 해당하는 데이터만 렌더링하고,
보이지 않는 영역의 요소는 DOM에서 제거하는 렌더링 최적화 기법입니다.

이를 통해 DOM 노드 수를 일정하게 유지해
대량 데이터에서도 안정적인 스크롤 성능을 확보할 수 있습니다.

</details>

<details>
<summary>페이지네이션과 무한 스크롤의 차이는 무엇인가요?</summary>

- 페이지네이션은 데이터를 페이지 단위로 나누어 명확한 탐색과 위치 파악이 쉽고,
- 무한 스크롤은 자연스러운 탐색 경험을 제공하지만 전체 데이터 구조를 파악하기 어렵습니다.

페이지네이션은 관리와 성능 제어가 비교적 쉽고,
무한 스크롤은 사용자 몰입도는 높지만 성능 최적화가 필수적입니다.

</details>

## 6. 크로스 브라우징

<details>
<summary>⭐️ 크로스 브라우징이란 무엇인가요?</summary>

크로스 브라우징은 서로 다른 브라우저 환경에서도
웹 페이지가 동일한 기능과 UI로 동작하도록 보장하는 것을 의미합니다.

사용자가 어떤 브라우저를 사용하더라도
레이아웃이 깨지거나 기능이 다르게 동작하지 않도록 대응하는 것이 목적입니다.

</details>

<details>
<summary>브라우저마다 렌더링 결과가 다른 이유는 무엇인가요?</summary>

브라우저마다 사용하는 렌더링 엔진이 다르고,
HTML, CSS, JavaScript 표준을 해석하는 방식과 기본 스타일이 조금씩 다르기 때문입니다.

또한 최신 CSS 기능이나 API 지원 여부가 브라우저별로 다르기 때문에
같은 코드라도 결과가 달라질 수 있습니다.

</details>

<details>
<summary>CSS Reset은 왜 필요한가요?</summary>

**브라우저마다** 기본으로 적용되는 CSS 스타일이 다르기 때문에,
이 차이를 초기화해 동일한 기준에서 스타일링하기 위해 사용합니다.

CSS Reset을 적용하면 **예측 가능한 스타일링**이 가능해지고,
브라우저 간 레이아웃 차이를 줄일 수 있습니다.

</details>

<details>
<summary>Webpack, Babel, Polyfill에 대해 설명해 주세요.</summary>

- **Webpack**은 여러 JavaScript, CSS, 이미지 파일을 **하나의 번들**로 묶어
  브라우저가 효율적으로 로드할 수 있게 해주는 번들러입니다.

- **Babel**은 최신 JavaScript 문법을
  구형 브라우저에서도 동작할 수 있도록 변환해주는 **트랜스파일러**입니다.

- **Polyfill**은 브라우저에 존재하지 않는 최신 기능을
  코드로 구현해 제공함으로써, 기능 자체를 사용할 수 있게 해줍니다.

이 세 가지는 함께 사용되어
개발 편의성과 브라우저 호환성을 동시에 해결합니다.

</details>

## 7. 개발 환경 & 도구

<details>
<summary>⭐️ ESLint와 Prettier의 역할 차이는 무엇인가요?</summary>

- **ESLint**는 **코드의 문법 오류나 잠재적인 버그, 잘못된 패턴**을 찾아내는 도구입니다. 변수 미사용, 잘못된 비교(얕은 비교/깊은 비교), 위험한 코드 작성 여부 등 **코드 품질과 안정성**에 초점을 둡니다.

- **Prettier**는 **코드 스타일**을 자동으로 정리해주는 **포매터**로, 들여쓰기, 줄바꿈, 따옴표 같은 형식적인 부분을 일관되게 맞추는 역할을 합니다.

</details>

<details>
<summary>dependencies와 devDependencies의 차이는 무엇인가요?</summary>

- dependencies는 애플리케이션이 실제로 실행될 때 필요한 라이브러리들을 의미합니다. **React, axios 같은 런타임 의존성**이 여기에 포함됩니다.

- devDependencies는 개발 과정에서만 필요한 도구들로,
  **빌드, 테스트, 린트, 포맷팅** 등에 사용되는 라이브러리들이 포함됩니다.

**배포 환경에서는 devDependencies가 설치되지 않기 때문에**
두 의존성을 구분해 관리하는 것이 중요합니다.

</details>

<details>
<summary>⭐️ 라이브러리와 프레임워크의 차이는 무엇인가요?</summary>

- 라이브러리는 개발자가 필요할 때 호출해서 사용하는 도구로, 애플리케이션의 흐름을 개발자가 직접 제어합니다.

- 반면 프레임워크는 애플리케이션의 전체 구조와 흐름을 제공하고, 개발자는 그 규칙 안에서 코드를 작성하게 됩니다.

</details>

<details>
<summary>제어의 역전(IoC)이란 무엇인가요?</summary>

제어의 역전은 프로그램의 흐름 제어권이 개발자 코드가 아니라
**프레임워크나 외부 시스템**에 의해 관리되는 개념입니다.

개발자는 **특정 시점에 실행될 로직만 정의**하고,
언제 어떻게 호출될지는 프레임워크가 결정합니다.

이를 통해 코드의 결합도가 낮아지고,
확장성과 테스트 용이성이 높아집니다.

</details>

## 8. 성능 최적화

<details>
<summary>⭐️ 웹 성능 최적화를 왜 해야 하나요?</summary>

웹 성능은 **사용자 경험**에 직접적인 영향을 주기 때문에 중요합니다.  
로딩이 느리면 **이탈률**이 높아지고, 서비스 **신뢰도와 전환율**도 함께 떨어집니다.  
또한 성능은 **SEO**에도 영향을 주기 때문에 비즈니스 측면에서도 최적화가 필요합니다.

</details>

<details>
<summary>⭐️ 성능 최적화 방법에는 어떤 것들이 있나요?</summary>

성능 최적화에는 크게 세 가지 방법이 있습니다.

- 첫 번째는 **렌더링 최적화**입니다.
  - 불필요한 재렌더링을 줄이는 것이 핵심으로,
  - React에서는 **메모이제이션**을 사용하거나 **상태를 분리**해 렌더링 범위를 최소화합니다.
  - 또한 **가상 스크롤**을 통해 DOM 개수를 줄이는 것도 여기에 포함됩니다.
- 두 번째는 **네트워크 및 데이터 최적화**입니다.
  - **API 캐싱**을 통해 동일한 요청을 반복하지 않도록 하고,
  - **네트워크 지연과 불필요한 로딩**을 줄입니다.
  - React Query 같은 라이브러리는 서버 상태 캐싱과 동기화를 자동으로 처리해 체감 성능을 크게 개선합니다.
- 세 번째는 **리소스 최적화**입니다.
  - **이미지 용량**을 줄이거나 (webp)
  - **lazy loading**을 적용해 초기 로딩 부담을 낮추고,
  - 코드 스플리팅을 통해 필요한 코드만 다운로드하도록 합니다.
  - 이는 초기 렌더링 속도에 직접적인 영향을 줍니다.

</details>

<details>
<summary>코드 스플리팅은 무엇이며 왜 필요한가요?</summary>

코드 스플리팅은 애플리케이션 코드를 여러 번들로 나누어 필요한 시점에만 로드하는 기법입니다.  
초기 로딩 시 모든 코드를 한 번에 내려받지 않아도 되기 때문에 초기 로딩 속도를 크게 개선할 수 있습니다.  
주로 라우트 단위나 특정 기능 단위로 적용합니다.

</details>

<details>
<summary>Lazy Loading은 어떤 문제를 해결하나요?</summary>

Lazy Loading은 당장 필요하지 않은 리소스를 나중에 불러오는 방식입니다.  
초기 화면에 필요한 리소스만 먼저 로드해 초기 로딩 속도를 줄이고, 네트워크와 메모리 사용을 최적화합니다.  
이미지, 컴포넌트, 페이지 단위로 자주 사용됩니다.

</details>

## 9. SEO

<details>
<summary>⭐️ SEO란 무엇인가요?</summary>

SEO는 검색 엔진에서 웹 페이지가 더 잘 노출되도록 구조와 콘텐츠를 최적화하는 작업입니다.  
검색 엔진이 페이지 내용을 잘 이해하고 크롤링할 수 있도록 만드는 것이 핵심 목적입니다.

</details>

<details>
<summary>⭐️ CSR 환경에서 SEO 문제가 발생하는 이유는 무엇인가요?</summary>

CSR에서는 초기 HTML에 콘텐츠가 거의 없고, JavaScript 실행 후에 화면이 구성됩니다.  
이로 인해 검색 엔진 크롤러가 실제 콘텐츠를 제대로 인식하지 못하는 문제가 발생할 수 있습니다.

</details>

<details>
<summary>CSR 환경에서 SEO를 개선하는 방법에는 어떤 것들이 있나요?</summary>

SSR이나 SSG를 도입해 초기 HTML에 콘텐츠를 포함시키는 방법이 대표적입니다.  
또한 메타 태그 관리, 프리렌더링, 검색 엔진 친화적인 라우팅 구조를 사용하는 것도 도움이 됩니다.

</details>

<details>
<summary>⭐️ SSR과 SSG의 차이는 무엇인가요?</summary>

SSR은 요청이 들어올 때마다 서버에서 HTML을 생성하는 방식이고,  
SSG는 빌드 시점에 미리 HTML을 생성해 두는 방식입니다.  
SSR은 데이터가 자주 바뀌는 페이지에, SSG는 정적인 콘텐츠에 적합합니다.

</details>

## 10. 보안

<details>
<summary>⭐️ CORS란 무엇인가요?</summary>
CORS는 Cross Origin Resource Sharing(교차 출처 리소스 공유)의 약자로 다른 출처의 리소스 요청을 제한하는 브라우저 보안 정책입니다. 서버가 허용한 출처에 대해서만 요청을 허용함으로써 악의적인 접근을 방지합니다.

브라우저가 서버로 요청을 보냈지만, 서버 응답에 허용된 출처 정보가 없을 때 발생합니다.

보통 서버에서 Allow-Origin 헤더로 허용 범위를 지정해 해결합니다.

프론트에서는 CORS를 직접 해결할 수 없고, 개발 환경에서는 proxy를 사용해 서버와 동일한 Origin처럼 요청하는 방식으로 우회합니다.

</details>

<details>
<summary>쿠키와 웹스토리지의 차이는 무엇인가요?</summary>
쿠키와 웹스토리지는 모두 브라우저 저장소이지만 목적과 동작 방식이 다릅니다.

- **쿠키**는 브라우저에 저장되지만 요청마다 서버에 자동으로 전송된다는 점이 가장 큰 특징입니다. 그래서 세션 ID처럼 서버가 사용자를 식별해야 하는 값 전달에 자주 활용됩니다.

- 반면 **웹스토리지**는 브라우저 내부에서만 사용되는 저장소로, 서버로 자동 전송되지 않습니다. 용량이 더 크고 구조도 단순해 인증보다는 UI 상태나 캐시처럼 클라이언트 전용 데이터 보관에 적합합니다.
</details>

<details>
<summary>로컬 스토리지와 세션 스토리지의 차이는 무엇인가요?</summary>

- **로컬 스토리지**는 브라우저를 종료해도 데이터가 유지되는 영구 저장소에 가깝습니다. 그래서 다크모드 설정처럼 지속적으로 유지해야 하는 값 저장에 적합합니다.

- 반면 **세션 스토리지**는 탭 단위로 유지되는 임시 저장소라, 탭을 닫으면 데이터가 삭제됩니다. 페이지 이동 중 임시 입력값처럼 짧은 생명주기를 가진 데이터 보관에 주로 사용합니다.

</details>

<details>
<summary>⭐️ XSS 공격이란 무엇인가요?</summary>

XSS(Cross Site Scripting)는 악성 스크립트를 웹 페이지에 삽입해 사용자 브라우저에서 실행되게 하는 공격입니다.  
이를 통해 쿠키 탈취나 사용자 정보 유출이 발생할 수 있습니다.

주요 대응 방법으로는 사용자 입력 값에 대한 검증과 이스케이프 처리, innerHTML 사용 지양, 그리고 CSP(Content Security Policy) 설정을 통해 외부 스크립트 실행을 제한하는 방법이 있습니다.

> XSS는 클라이언트(브라우저)에서 발생하는 공격

</details>

<details>
<summary>CSRF 공격이란 무엇인가요?</summary>

CSRF(Cross-Site Request Forgery)는 사용자가 로그인된 상태를 악용해 의도하지 않은 요청을 서버로 보내게 만드는 공격입니다.  
정상 사용자처럼 보이기 때문에 서버가 이를 구분하기 어렵다는 특징이 있습니다.

이를 방지하기 위해 CSRF 토큰을 사용해 요청의 출처를 검증하고, 쿠키에 SameSite 옵션을 설정하거나 중요 요청에 대해 추가 인증을 적용합니다.

> CSRF는 서버에서 발생하는 공격

</details>

## 11. 개발 전반

<details>
<summary>TDD란 무엇인가요?</summary>

TDD(Test-Driven Development)는 테스트 주도 개발 방법론으로,
개발자가 코드를 작성하기 전에 먼저 테스트 케이스를 작성하고 이를 통과시키는 것을 중심으로 개발을 진행하는 방법입니다.

TDD는 코드 품질을 향상시키고 버그를 미리 발견하여 개선하는 데 도움이 됩니다.
또한, 코드 변경 시 이전에 작성된 테스트 케이스를 수행하여 기존 코드의 영향을 미치는 부분을 파악하고, 안정적인 코드 개발에 도움을 줍니다.

</details>

<details>

<summary>TDD의 사이클(절차)이 어떻게 되나요?</summary>

TDD는 Red → Green → Refactor의 세 단계 사이클로 이루어집니다.

- Red: 실패하는 테스트를 먼저 작성한다.
- Green: 테스트를 통과할 만큼의 최소한의 코드를 작성한다.
- Refactor: 테스트를 통과한 상태에서 코드 품질을 개선하고 중복을 제거한다.

이 사이클을 반복하며 기능을 확장해 나가는 방식입니다.

</details>

<details>
<summary>TDD와 단위 테스트(Unit Test)의 차이는 무엇인가요?</summary>

단위 테스트는 테스트를 작성한다는 행위 자체에 초점이 있고,
TDD는 테스트를 먼저 작성하고 개발을 테스트 중심으로 이끌어간다는 개발 프로세스 전체를 아우르는 개념입니다.

</details>
