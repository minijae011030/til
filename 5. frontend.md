# 프론트엔드 전반

## 1. 브라우저 & 렌더링

### ⭐ 브라우저 렌더링 과정

브라우저는 URL을 입력받으면 서버에 요청을 보내 HTML, CSS, JS 파일을 다운로드합니다.
HTML을 파싱해 DOM 트리, CSS를 파싱해 CSSOM 트리를 만들고, 이를 결합해 렌더 트리를 생성합니다.
이후 레이아웃 단계에서 요소의 크기와 위치를 계산하고, 페인팅을 통해 실제 화면에 그립니다.

### ⭐ 주소창에 주소 입력 시 흐름

- URL 입력
- DNS 조회
- 서버 요청
- HTML 응답
- 렌더링 과정 수행

### ⭐ 리플로우와 리페인트

- 리플로우
  - 레이아웃 변경
  - 비용 큼
- 리페인트
  - 색상 등 시각적 변경
  - 리플로우보다 비용 적음

### ⭐ Virtual DOM과 Real DOM 차이

- Real DOM
  - 실제 브라우저 DOM
  - 직접 조작 비용 큼
- Virtual DOM
  - 메모리 상 JS 객체
  - 변경 비교 후 최소 DOM 업데이트

### ⭐ 라이프사이클이란

컴포넌트가 생성 → 마운트 → 업데이트 → 언마운트 되는 전체 흐름입니다.
각 단계에 맞는 작업을 수행하기 위해 필요합니다.

### ⭐ CSR과 SSR의 차이

- CSR (Client Side Rendering)
  - 브라우저에서 JS로 화면 렌더링
  - 초기 로딩 느릴 수 있음
- SSR (Server Side Rendering)
  - 서버에서 HTML 생성 후 전달
  - 초기 로딩 빠르고 SEO 유리

### ⭐ SPA(Single Page Application)

SPA는 하나의 HTML 페이지를 기반으로 동작하는 웹 애플리케이션입니다.
초기 로딩 시 HTML, JS, CSS를 한 번에 받아오고, 이후에는 페이지 새로고침 없이
필요한 데이터만 API(AJAX)로 받아 화면을 갱신합니다.

특징

- 주로 CSR(Client Side Rendering) 방식 사용
- JavaScript가 DOM을 직접 업데이트
- 페이지 이동 시 전체 새로고침 없음

장점

- 빠른 화면 전환
- 인터랙티브한 사용자 경험
- 컴포넌트 기반 개발에 적합

단점

- 초기 로딩 속도가 느릴 수 있음
- CSR 기반일 경우 SEO에 불리할 수 있음

### ⭐ 데이터 10,000개 무한 스크롤 구현 시 고려 사항

- 데이터 페이징
- 가상 스크롤
- DOM 개수 제한
- 메모리 관리

→ 사용자 경험과 성능 최적화가 핵심

### ⭐ 크로스 브라우징

브라우저마다 다른 렌더링 차이를 고려해
모든 주요 브라우저에서 동일한 사용자 경험을 제공하는 것입니다.
CSS Reset, Polyfill 등을 사용합니다.

## 2. 프론트엔드 개발 환경 / 도구

### ⭐ ESLint와 Prettier

- ESLint
  - 코드 품질 검사 도구
  - 잠재적 오류, 안티 패턴 방지
- Prettier
  - 코드 포맷팅 도구
  - 스타일 일관성 유지

→ 보통 ESLint는 코드 규칙, Prettier는 코드 스타일을 담당합니다.

### ⭐ dependencies와 devDependencies 차이

- dependencies
  - 런타임에 필요한 패키지
- devDependencies
  - 개발 과정에서만 필요한 패키지

### ⭐ 라이브러리와 프레임워크 차이

- 라이브러리
  - 개발자가 흐름 제어
- 프레임워크
  - 프레임워크가 흐름 제어

## 3. 성능 최적화

### ⭐ 웹사이트 성능 최적화 방법

웹 성능 최적화는 크게 렌더링, 네트워크, 리소스 관리 관점에서 접근할 수 있습니다.

① 렌더링 최적화

- 불필요한 리렌더링 방지
- 메모이제이션(useMemo, React.memo)
- Virtual DOM 기반 업데이트 최소화

② 네트워크 최적화

- API 요청 최소화
- 캐싱 전략 적용
- 코드 스플리팅

③ 리소스 최적화

- 이미지 최적화(webp)
- JS / CSS 번들 크기 감소
- Lazy Loading

## 4. SEO

### ⭐ SEO란

검색 엔진이 웹 페이지를 잘 인식하도록 구조를 최적화하는 작업입니다.
시맨틱 태그 사용, 메타 태그 관리, SSR 적용 등이 중요합니다.

### ⭐ SEO 최적화 방법

- 시맨틱 태그 사용
- 메타 태그 설정
- SSR 또는 SSG 적용
  - 서버 사이드 렌더링은 서버에서 HTML문서를 만들어서 응답하기 때문에 사용자도, 검색엔진도 완성된 HTML 파일을 응답받음
- CSR 사용 시 사전 렌더링 방식을 적용
  - 검색 엔진이 빈 HTML 파일 대신 내용이 포함된 HTML을 가져갈 수 있도록 빌드타임에 데이터가 포함된 HTML 파일을 생성하는 방식
- 접근성 고려

### ⭐ CSR에서 검색엔진 최적화 이슈가 발생하는 이유

클라이언트 사이드 렌더링으로 작성된 사이트들은 일반적으로 처음 접속하면 body가 비어있는 HTML 파일을 받아오고, 자바스크립트를 통해 동적으로 콘텐츠를 렌더링 합니다.

검색엔진의 봇은 사이트를 돌아다니면서 HTML 문서 정보를 수집하는데, 싱글 페이지 애플리케이션에서는 body가 비어있는 HTML 문서를 수집하게 됩니다.

구글의 봇은 자바스크립트를 실행하여 수집할 수 있지만, 대부분의 봇들은 싱글 페이지 애플리케이션의 비어있는 문서를 수집하기 때문에 검색엔진 최적화가 잘 되지 않습니다.

## 5. 보안

### ⭐ CORS란 무엇이며 해결 경험

CORS는 다른 출처의 리소스 요청을 브라우저가 제한하는 보안 정책입니다.
서버에서 Access-Control-Allow-Origin 헤더를 설정하거나,
프록시 설정 또는 동일 출처로 요청 구조를 변경해 해결했습니다.

### ⭐ 쿠키, 세션, 웹스토리지 차이

- 쿠키
  - 클라이언트 저장
  - 요청 시 자동 전송
  - 용량 작음, 보안 취약
- 세션
  - 서버 저장
  - 세션 ID만 쿠키로 관리
  - 웹스토리지
- 로컬/세션 스토리지
  - 서버 자동 전송 ❌
  - 대용량 저장 가능

### ⭐ 로그인 처리 시 쿠키와 세션 사용 방식

서버는 로그인 성공 시 세션을 생성하고,
클라이언트에는 세션 ID를 쿠키로 저장합니다.
이후 요청마다 세션 ID를 통해 사용자를 식별합니다.

### ⭐ 토큰 기반 인증 방식

서버가 로그인 성공 시 토큰(JWT)을 발급하고,
클라이언트는 이후 요청에 토큰을 포함해 인증합니다.
서버 상태를 저장하지 않아 확장성이 좋습니다.

### ⭐ JWT를 쿠키에 저장했을 때 취약점

- XSS로 토큰 탈취 가능
- CSRF 공격 위험

→ httpOnly, secure, SameSite 옵션으로 보완합니다.

### ⭐ XSS와 CSRF

- XSS
  - 악성 스크립트 주입 공격
- CSRF
  - 인증된 사용자의 요청을 위조

→ 입력값 검증, 토큰 사용으로 방어
