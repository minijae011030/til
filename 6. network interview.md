# 네트워크 면접 질문 리스트

## 1. 웹 통신 개요

<details>
<summary>웹 프로토콜이란 무엇인가요?</summary>

웹 프로토콜은 인터넷에서 **클라이언트와 서버**가 데이터를 주고받기 위해 지켜야 하는 통신 규칙입니다.
대표적으로 HTTP, HTTPS, TCP/IP 등이 있으며, 서로 다른 시스템끼리도 **표준화된 규칙**을 통해 통신이 가능하게 합니다.

✅ 인터넷, 클라이언트-서버, 데이터, 표준화된 규칙, HTTP, HTTPS, TCP/IP, 서로 다른 시스템

</details>

<details>
<summary>⭐️ 클라이언트와 서버는 어떤 방식으로 통신하나요?</summary>

클라이언트와 서버는 **HTTP 요청(Request)** 을 보내고 **HTTP 응답(Response)** 을 받는 방식으로 통신합니다.
클라이언트가 요청을 보내면 서버는 해당 요청을 처리한 뒤 HTML, JSON 같은 데이터를 응답으로 전달합니다.
이 과정은 \***\*Stateless(무상태)\*\*** 하기 때문에, 한 요청이 다른 요청에 영향을 주지 않습니다.

✅ 요청, 응답, 데이터(html, json), 무상태

</details>

<details>
<summary>⭐️ 요청(Request)과 응답(Response)의 구조를 설명해보세요.</summary>

요청과 응답은 모두 헤더(Header) 와 본문(Body) 로 구성됩니다.

- Request
  - Start-line: 메서드(GET/POST 등), URL, HTTP 버전
  - Headers: 인증 정보, 쿠키, 컨텐츠 타입 등 메타데이터
  - Body: POST·PUT 등에서 전송하는 데이터(JSON 등)
- Response
  - Status-line: 상태 코드(200, 404 등)와 메세지
  - Headers: 컨텐츠 타입, 캐시 정책 등
  - Body: 실제 반환 데이터(HTML, JSON 등)

이 구조를 통해 클라이언트와 서버가 필요한 정보를 표준 방식으로 교환할 수 있습니다.

</details>

<details>
<summary>OSI 7계층에 대해 간단히 설명해주세요.</summary>

- 7계층 애플리케이션 — HTTP, WebSocket
- 6계층 표현 — TLS 암호화
- 5계층 세션 — 연결 상태 관리
- 4계층 전송 — TCP/UDP
- 3계층 네트워크 — IP, 라우팅
- 2계층 데이터 링크 — MAC 주소
- 1계층 물리 — 케이블, 전파

✅ HTTP(7계층), TLS(6계층), TCP/UDP(4계층), IP(3계층) 중요

</details>

## 2. HTTP 기본 개념

<details>
<summary>⭐️ HTTP란 무엇인가요?</summary>

HTTP는 웹에서 클라이언트와 서버가 데이터를 주고받기 위해 사용하는 애플리케이션 계층 프로토콜입니다.
HTML, JSON, 이미지 등 다양한 리소스를 요청·응답하는 데 사용되며, 요청(request)과 응답(response) 구조로 동작합니다.

</details>

<details>
<summary>⭐️ HTTP의 무상태성(stateless)이란 무엇인가요?</summary>

HTTP의 무상태성은 각 요청이 서로 독립적으로 처리되고, 서버가 클라이언트의 이전 상태를 저장하지 않는 특징을 의미합니다.
즉, 서버는 이 사용자가 누구인지를 요청만 보고는 알 수 없습니다.

</details>

<details>
<summary>⭐️ HTTP의 무상태성이 가지는 장점과 단점은 무엇인가요?</summary>

- 장점
  - 서버가 상태를 보관하지 않아 구조가 단순해지고 확장성이 높고
  - 요청 간 의존성이 없어 로드밸런싱 처리가 쉽습니다.
  - 또한 서버 자원을 적게 사용합니다.
- 단점
  - 로그인 정보, 장바구니, 최근 페이지 등 사용자 상태를 직접 기억할 수 없고
  - 매 요청마다 필요한 인증을 다시 보내야 합니다.

</details>

<details>
<summary>⭐️ HTTP에서 상태를 유지해야 할 경우 어떻게 해결하나요?</summary>

서버가 상태를 기억하지 못하므로, 클라이언트 측에서 상태를 추가로 저장해 서버에 전달하는 방식으로 해결합니다.

대표적인 방식은 다음과 같습니다.

- 쿠키(Cookie): 브라우저에 저장되는 작은 데이터로, 매 요청마다 자동 전송됩니다.
- 세션(Session): 서버에 저장하는 사용자 상태 정보이며, 쿠키로 세션 ID를 전달합니다.
- JWT: 토큰 기반 인증 방식으로, 클라이언트가 토큰을 저장하고 매 요청마다 전달합니다.

이런 방식들을 사용해 HTTP 위에서도 로그인 유지, 장바구니 등 상태 관리가 가능해집니다.

</details>

## 3. HTTP vs HTTPS

<details>
<summary>⭐️ HTTP와 HTTPS의 차이는 무엇인가요?</summary>

HTTP는 데이터를 평문(plaintext)으로 전송하는 프로토콜이고,
HTTPS는 여기에 **SSL/TLS 암호화** 계층을 추가해 데이터를 암호화하여 전송하는 프로토콜입니다.

즉, 둘의 가장 큰 차이는 암호화 여부이며, HTTPS는 통신 과정 전체가 보호됩니다.

</details>

<details>
<summary>⭐️ HTTPS는 왜 더 안전한가요?</summary>

HTTPS는 **TLS(Transport Layer Security)** 를 사용하여

1. 암호화(Encryption) — 중간에서 데이터를 읽지 못함
2. 무결성(Integrity) — 데이터가 변경되면 감지 가능
3. 인증(Authentication) — 서버가 진짜 서버임을 증명

을 보장하기 때문에 안전합니다.

</details>

<details>
<summary>HTTPS는 어떤 공격을 방지할 수 있나요?</summary>

- 중간자 공격(MITM): 공격자가 요청/응답을 가로채 내용을 읽거나 변조하는 공격을 막을 수 있습니다.
- 도청(패킷 스니핑): 네트워크에서 트래픽을 훔쳐보는 공격을 암호화로 차단합니다.
- 위조·변조 공격: TLS의 무결성 검증을 통해 데이터가 중간에서 바뀌었는지도 확인할 수 있습니다.

</details>

<details>
<summary>HTTP를 HTTPS로 바꾸면 성능에 영향이 있나요?</summary>

초기 연결 단계에서 TLS 핸드셰이크로 인해 **소폭의 비용(지연)** 은 있지만,
현대 브라우저와 HTTP/2, TLS 1.3 환경에서는 영향이 매우 작으며, 오히려

- HTTP/2 사용 가능
- 헤더 압축
- 멀티플렉싱
- 연결 재사용

등으로 실제 환경에서는 HTTPS가 더 빠른 경우도 많습니다.

</details>

## 4. HTTPS 동작 원리

<details>
<summary>⭐️ HTTPS 통신 과정을 간단히 설명해보세요.</summary>

HTTPS는 TLS 프로토콜을 통해 서버와 클라이언트가 안전하게 통신할 수 있도록 암호화 채널을 구축하는 과정으로 동작합니다.

브라우저가 서버의 인증서를 확인해 신뢰할 수 있는지 검증하고,
TLS Handshake를 통해 안전한 세션 키(대칭키)를 생성한 뒤,
이후 모든 데이터는 그 키로 암호화되어 전송됩니다.

</details>

<details>
<summary>TLS Handshake란 무엇인가요?</summary>

TLS Handshake는 클라이언트와 서버가 최초 연결을 맺을 때 암호화에 필요한 정보를 교환하고,
보안 세션을 수립하는 과정을 말합니다.

이 과정에서 서버 인증서 검증, 암호 방식 협상, 키 교환 등이 이루어지며,
최종적으로 안전하게 통신할 수 있는 세션 키가 생성됩니다.

</details>

<details>
<summary>⭐️ 대칭키와 비대칭키는 각각 언제 사용되나요?</summary>

- **비대칭키(공개키·개인키)** 는 TLS Handshake 과정에서 사용되며, 안전하게 대칭키를 교환하기 위한 단계에서 활용됩니다.
- **대칭키**는 Handshake 이후 본격적인 데이터 통신에서 사용되며, 암호화·복호화가 빠르기 때문에 실제 HTTPS 데이터 전송에 사용됩니다.

즉, 비대칭키로 대칭키를 안전하게 교환하고, 실제 데이터는 대칭키로 암호화한다는 구조로 동작합니다.

</details>

<details>
<summary>⭐️ 중간자 공격(Man-in-the-Middle Attack)이란 무엇인가요?</summary>

중간자 공격은 **사용자와 서버 사이에 공격자가 몰래 끼어들어 데이터를 가로채거나 변조하는 공격 방식**을 말합니다.
HTTPS는 인증서 검증과 암호화된 통신을 통해 공격자가 데이터를 읽거나 조작할 수 없게 하여 이러한 공격을 효과적으로 방지합니다.

</details>

## 5. TCP / UDP

<details>
<summary>⭐️ TCP와 UDP의 차이는 무엇인가요?</summary>

- TCP는 연결 기반으로 동작하며 데이터 순서 보장, 재전송, 흐름 제어 등 신뢰성을 보장하는 프로토콜입니다.
- 반면 UDP는 연결 없이 데이터를 전송하는 비신뢰성 프로토콜로, 오버헤드가 적고 전송 속도가 빠릅니다.

</details>

<details>
<summary>⭐️ 웹 통신은 왜 TCP를 사용하나요?</summary>

웹에서 사용하는 HTTP는 요청과 응답의 정확성이 매우 중요하기 때문에, 데이터가 손실 없이 순서대로 전달되도록 보장하는 TCP가 적합하기 때문입니다.

</details>

<details>
<summary>UDP가 사용되는 대표적인 사례에는 무엇이 있나요?</summary>

UDP는 빠른 전송이 중요한 실시간 서비스에 사용됩니다.

예를 들어 스트리밍, 화상 회의, 온라인 게임 등이 있습니다.

</details>

## 6. TCP 신뢰성 보장

<details>
<summary>TCP는 어떻게 신뢰성을 보장하나요?</summary>

TCP는 데이터의 순서를 표시하는 시퀀스 번호, 데이터 수신 여부를 알려주는 ACK(아크), 손실 시 재전송하는 재전송 메커니즘, 그리고 흐름 제어·혼잡 제어 등을 통해 신뢰성을 보장합니다.

</details>

<details>
<summary>TCP에서 재전송은 언제 발생하나요?</summary>

전송한 데이터에 대해 ACK 응답을 일정 시간 동안 받지 못했을 때 재전송이 발생합니다.
또는 패킷이 손상되었거나, 중간에 유실된 경우에도 재전송이 이루어집니다.

</details>

<details>
<summary>흐름 제어와 혼잡 제어의 차이는 무엇인가요?</summary>

- **흐름 제어**는 송신 속도가 너무 빨라 수신 측 버퍼가 감당하지 못하는 상황을 방지하기 위한 제어입니다.
- **혼잡 제어**는 네트워크 전체가 과부하 상태가 되는 것을 막기 위해 네트워크 상태에 맞춰 전송량을 조절하는 방식입니다.

</details>

## 7. TCP 연결 과정

<details>
<summary>⭐️ TCP 3-Way Handshake란 무엇인가요?</summary>

클라이언트와 서버가 연결을 만들기 위해 **SYN(씬) → SYN/ACK → ACK** 순서로 신호를 교환하며 연결을 확립하는 과정입니다.
이 과정을 통해 서로 통신이 가능한 상태임을 확인합니다.

![3-way-handshake](https://github.com/minijae011030/til/blob/main/image/3-way-handshake.png?raw=true)

</details>

<details>
<summary>TCP 4-Way Handshake란 무엇인가요?</summary>

연결을 종료하기 위해 **FIN → ACK → FIN → ACK** 순서로 신호를 주고받는 과정입니다.
양쪽이 각각 종료 요청을 보내고 이를 확인하며 연결을 정상적으로 종료합니다.

![4-way-handshake](https://github.com/minijae011030/til/blob/main/image/4-way-handshake.png?raw=true)

</details>

<details>
<summary>TIME_WAIT 상태는 왜 필요한가요?</summary>

TIME_WAIT은 지연된 패킷이 뒤늦게 도착하는 것을 방지하고, 동일한 포트로 새로운 연결이 시작될 때 충돌하지 않도록 하기 위해 필요합니다.

</details>

## 8. REST API

<details>
<summary>⭐️ REST API란 무엇인가요?</summary>

REST API는 **자원을 URI로 표현하고, HTTP 메서드로 해당 자원을 조작하는 방식의 API 아키텍처 스타일**입니다.
Stateless 특성을 기반으로 단순하고 일관된 인터페이스를 제공합니다.

서버가 클라이언트의 상태를 기억하지 않아야 스케일링이 쉽고, 요청마다 독립적으로 처리할 수 있어 구조가 단순해지기 때문에 stateless 특성을 가집니다.

</details>

<details>
<summary>REST API에서 자원(Resource)이란 무엇인가요?</summary>

서버에서 다루는 모든 데이터 대상을 의미하며, 예를 들어 “/users”, “/products”처럼 URI로 표현되는 엔티티를 말합니다.

</details>

## 9. HTTP 메서드

<details>
<summary>⭐️ GET과 POST의 차이는 무엇인가요?</summary>

- GET은 데이터 조회에 사용되며 URL에 파라미터가 포함됩니다.
- POST는 요청 본문에 데이터를 담아 자원 생성이나 변경에 사용됩니다.

GET 요청은 URL 기반이고 부작용이 없기 때문에 캐싱이 가능하지만,
POST는 기본적으로 캐싱 대상이 아닙니다.

</details>

<details>
<summary>PUT과 PATCH의 차이는 무엇인가요?</summary>

- PUT은 전체 자원 교체,
- PATCH는 변경할 부분만 업데이트하는 방식입니다.

</details>

<details>
<summary>⭐️ 멱등성(Idempotency)이란 무엇인가요?</summary>

여러 번 요청하더라도 결과가 동일하게 유지되는 성질을 의미합니다.

- GET, PUT, DELETE는 멱등적이고,
- POST는 멱등적이지 않습니다.

> DELETE는 여러 번 호출해도 삭제된 상태라는 최종 결과는 동일하기 때문에 멱등적이다.
>
> 단, 응답은 달라질 수 있지만(첫 번째는 200, 두 번째는 404 가능)
> 결과가 동일하면 멱등성을 인정한다.

</details>

## 10. HTTP Status Code

<details>
<summary>⭐️ HTTP 상태 코드는 왜 필요한가요?</summary>

요청 결과가 성공·실패·인증 오류인지 등을 클라이언트에게 명확히 알려 후속 대응을 가능하게 하기 위해 필요합니다.

</details>

<details>
<summary>⭐️ 2xx, 4xx, 5xx 상태 코드의 차이는 무엇인가요?</summary>

- 2xx: 요청 성공
- 4xx: 클라이언트 요청 오류
- 5xx: 서버 내부 오류

</details>

<details>
<summary>⭐️ 400, 401, 403의 차이는 무엇인가요?</summary>

- 400 Bad Request: 요청 형식 자체가 잘못됨
- 401 Unauthorized: 인증이 필요하거나 토큰이 유효하지 않음
- 403 Forbidden: 인증은 되었지만 권한이 없음

</details>

<details>
<summary>500 에러는 언제 발생하나요?</summary>

서버 내부에서 예기치 못한 오류가 발생하거나, 서버 로직이 실패했을 때 발생합니다.
클라이언트가 문제를 해결할 수 없는 서버 측 오류입니다.

</details>

## 11. axios vs fetch

<details>
<summary>axios와 fetch의 차이점에 대해 말씀해주세요.</summary>

- axios는 인터셉터, 기본 설정, 에러 처리 같은 기능이 내장된 고수준 HTTP 클라이언트라 실무에서 바로 사용하기 편합니다.
  특히 응답 status가 200대가 아니면 **자동으로 reject**하고, JSON 데이터도 Content-Type을 보고 **자동으로 파싱**해주기 때문에 에러 흐름과 데이터 처리가 일관적입니다.

- 반면 fetch는 브라우저 내장 API라 가볍지만, 400·500 응답도 resolve로 처리해 **status를 직접 검사**해야 하고, JSON도 항상 **res.json()을 직접 호출**해야 해 더 저수준 API에 가깝습니다.

</details>

<details>
<summary>인터셉터를 사용하는 방법을 설명해주세요.</summary>

- axios에서는 요청 인터셉터로 Authorization 헤더를 삽입하고, 응답 인터셉터에서 401 발생 시 refresh 로직을 연결해 인증 흐름을 중앙에서 관리했습니다.

- fetch는 인터셉터가 없어, fetch를 래핑한 커스텀 함수를 만들고 그 안에서 공통 헤더, 에러 처리, 인증 로직을 직접 구현하는 방식으로 대응했습니다.

</details>

<details>
<summary>인증 흐름(accessToken/refreshToken)을 어떻게 처리했나요?</summary>

axios 인스턴스의 요청 인터셉터에서 accessToken을 읽어 Authorization에 자동으로 붙였습니다.

401이 발생하면 refreshToken으로 토큰 재발급을 시도하고, 성공 시 원래 요청을 큐에 저장해 순차 재시도했습니다.

동시에 여러 요청이 401을 만들면 refresh 요청이 중복으로 발생하는 문제가 생기는데,
이를 막기 위해 refresh 요청을 한 번만 실행시키고 나머지 요청은 큐에 대기시키는 구조로 **race condition을 해결**했습니다.

refresh가 실패하면 큐에 있던 요청을 모두 reject시키고 로그아웃 또는 인증 초기화를 진행했습니다.

</details>

<details>
<summary>Next.js에서 서버 컴포넌트에서는 axios 대신 fetch를 권장하는 이유는 무엇인가요?</summary>

Next.js는 서버에서 fetch를 사용할 때 자동 캐싱과 revalidate 전략을 제공하기 때문에 SSR 렌더링과 가장 자연스럽게 통합됩니다.

</details>

<details>
<summary>axios 인스턴스를 사용하는 이유는 무엇인가요?</summary>

기본 URL, timeout, 공통 헤더, 인터셉터를 한 번에 관리해 요청 코드의 중복을 줄이고 유지보수성을 높일 수 있기 때문입니다.

</details>

<details>
<summary>timeout을 구현하려면 어떻게 해야 하나요?</summary>

- axios는 기본적으로 timeout 옵션을 지원하기 때문에 `timeout: ms` 값을 설정하면 지정한 시간 안에 응답이 오지 않을 경우 자동으로 요청을 중단하고 에러를 발생시킵니다.
- 반면 fetch는 timeout 기능이 없어 `AbortController`로 직접 구현해야 한다는 점이 차이입니다.

</details>

<details>
<summary>axios의 CancelToken과 fetch의 AbortController의 차이는 무엇인가요?</summary>

- axios의 CancelToken은 axios가 자체적으로 만든 비표준 취소 기능입니다.
  요청을 취소하기 위해 CancelToken 객체를 생성하고 cancel 함수를 호출하는 방식인데, axios 내부에서만 동작해 다른 웹 API와 통합성이 떨어지는 단점이 있었습니다.
- 반면 fetch의 AbortController는 브라우저가 제공하는 표준 취소 API로,
  요청에 signal을 연결한 뒤 controller.abort()를 호출하면 즉시 요청이 중단됩니다.
  AbortController는 fetch뿐 아니라 여러 브라우저 API에서도 공통으로 사용되기 때문에 더 범용적이고, axios 최신 버전도 CancelToken 대신 AbortController 사용을 권장합니다.

</details>

<details>
<summary>요청에 쿠키를 포함시키려면 어떤 설정이 필요한가요?</summary>

- axios는 `withCredentials: true` 옵션을 설정해야 하며,
- fetch는 `credentials: "include"` 설정 시 쿠키가 자동 포함됩니다.
</details>

<details>
<summary>axios와 fetch 중 어떤 것이 성능이 더 좋은가요?</summary>

fetch가 브라우저 내장 API라 더 가볍지만, 성능 차이는 미미하며 실제 선택 기준은 편의성 / 인터셉터 / 인증 구조에 가깝습니다.

하지만 axios를 사용하면 공통 설정, 인터셉터, 인스턴스 기반 구조를 활용해 요청 코드를 모듈화할 수 있어 팀 단위 개발이나 인증이 많은 서비스에서 유지보수성이 크게 올라갑니다.

</details>
